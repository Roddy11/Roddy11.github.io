<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown快速入门</title>
    <url>/2022/03/31/Markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1、代码块："><a href="#1、代码块：" class="headerlink" title="1、代码块："></a>1、代码块：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码块语法：</span></span><br><span class="line">​```java</span><br><span class="line">    </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

 <span id="more"></span> 

<p>1.java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.shell脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//linux下spring项目的启动命令</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">java -jar blog start</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2、标题："><a href="#2、标题：" class="headerlink" title="2、标题："></a>2、标题：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标题</span></span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加粗</span></span><br><span class="line">**等不到天黑**</span><br><span class="line"><span class="comment">//代码高亮</span></span><br><span class="line">==我不是罗迪==</span><br><span class="line"><span class="comment">//删除线</span></span><br><span class="line">~~被删除的文字~~</span><br><span class="line"><span class="comment">//斜体</span></span><br><span class="line">*斜体内容*    </span><br></pre></td></tr></table></figure>


<p><strong>等不到天黑</strong></p>
<p>&#x3D;&#x3D;我不是罗迪&#x3D;&#x3D;</p>
<p><del>被删除的文字</del></p>
<p><em>斜体内容</em></p>
<h2 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引用语法</span><br><span class="line">&gt;作者：叶仁平</span><br><span class="line">&gt;&gt;作者：叶仁平</span><br><span class="line">&gt;&gt;&gt;作者：叶仁平</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：叶仁平</p>
<blockquote>
<p>作者：叶仁平</p>
<blockquote>
<p>作者：叶仁平</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5、分割线"><a href="#5、分割线" class="headerlink" title="5、分割线"></a>5、分割线</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分割线1</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//分割线2</span></span><br><span class="line">***    </span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="6、图片插入"><a href="#6、图片插入" class="headerlink" title="6、图片插入"></a>6、图片插入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在线图片/本地图片</span><br><span class="line">![我的照片]()</span><br></pre></td></tr></table></figure>

<img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.DQcOipe7nLHVtSW3KQs6rQHaEo?pid=ImgDet&amp;rs=1" alt="我的照片" style="zoom:100%;" />

<h2 id="7、超链接"><a href="#7、超链接" class="headerlink" title="7、超链接"></a>7、超链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//超链接语法</span><br><span class="line">[我的github](https://github.com/Roddy11)</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/Roddy11">我的github</a></p>
<h2 id="8、列表语法"><a href="#8、列表语法" class="headerlink" title="8、列表语法"></a>8、列表语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//无序列表</span><br><span class="line">-目录1</span><br><span class="line">-目录2</span><br><span class="line">-目录3</span><br></pre></td></tr></table></figure>

<ul>
<li>目录1<ul>
<li>目录2<ul>
<li>目录3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h2><table>
<thead>
<tr>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>70</td>
<td>80</td>
<td>99</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="一、认识时间复杂度和简单排序算法"><a href="#一、认识时间复杂度和简单排序算法" class="headerlink" title="一、认识时间复杂度和简单排序算法"></a>一、认识时间复杂度和简单排序算法</h2><h3 id="1-认识时间复杂度"><a href="#1-认识时间复杂度" class="headerlink" title="1.认识时间复杂度"></a><strong>1.认识时间复杂度</strong></h3><p>一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。 </p>
<p>时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体 </p>
<p>来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作， </p>
<p>进而总结出常数操作数量的表达式。</p>
 <span id="more"></span> 

<p>在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那 </p>
<p>么时间复杂度为O(f(N))。 </p>
<p>评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行 </p>
<p>时间，也就是“常数项时间”。</p>
<h3 id="2-选择排序、冒泡排序细节的讲解与复杂度分析"><a href="#2-选择排序、冒泡排序细节的讲解与复杂度分析" class="headerlink" title="2.选择排序、冒泡排序细节的讲解与复杂度分析"></a><strong>2</strong>.<strong>选择排序、冒泡排序细节的讲解与复杂度分析</strong></h3><p>​    时间复杂度O(N^2)，额外空间复杂度O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组为空或者数组长度小于2！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-插入排序细节的讲解与复杂度分析"><a href="#3-插入排序细节的讲解与复杂度分析" class="headerlink" title="3.插入排序细节的讲解与复杂度分析"></a><strong>3.插入排序细节的讲解与复杂度分析</strong></h3><p>时间复杂度O(N^2)，额外空间复杂度O(1) </p>
<p>算法流程按照最差情况来估计时间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-二分法的详解与扩展"><a href="#4-二分法的详解与扩展" class="headerlink" title="4.二分法的详解与扩展"></a><strong>4.二分法的详解与扩展</strong></h3><p>​        1）在一个有序数组中，找某个数是否存在 </p>
<p>​        2）在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置 </p>
<p>​        3）局部最小值问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在一个有序数组中，找某个数是否存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; num) &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[L] == num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个有序数组中，找&gt;=某个数最左侧的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在arr上，找满足&gt;=value的最左位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nearestIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-异或运算的性质与扩展"><a href="#5-异或运算的性质与扩展" class="headerlink" title="5.异或运算的性质与扩展"></a><strong>5.异或运算的性质与扩展</strong></h3><p>   1）0^N &#x3D;&#x3D; N   N^N &#x3D;&#x3D; 0 </p>
<p>   2）异或运算满足交换律和结合率 </p>
<p>   3）不用额外变量交换两个数 </p>
<p>   4）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数 </p>
<p>   5）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor = eor ^ arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(eor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> curNum : arr) &#123;</span><br><span class="line">        eor1 ^= curNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor1 &amp; (~eor1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">            eor2 ^= cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(eor1 + <span class="string">&quot;  &quot;</span> + (eor1 ^ eor2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-对数器的概念和使用"><a href="#6-对数器的概念和使用" class="headerlink" title="6.对数器的概念和使用"></a><strong>6.对数器的概念和使用</strong></h3><p>​    1)，有一个你想要测的方法a </p>
<p>​    2)，实现复杂度不好但是容易实现的方法b </p>
<p>​    3)，实现一个随机样本产生器 </p>
<p>​    4)，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样 </p>
<p>​    5)，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b </p>
<p>​    6)，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</p>
<h3 id="7-剖析递归行为和递归行为时间复杂度的估算"><a href="#7-剖析递归行为和递归行为时间复杂度的估算" class="headerlink" title="7.剖析递归行为和递归行为时间复杂度的估算"></a>7.剖析递归行为和递归行为时间复杂度的估算</h3><pre><code> 用递归方法找一个数组中的最大值，系统上到底是怎么做的？ 
</code></pre>
<p>​    master公式的使用 </p>
<p>​    T(N) &#x3D; a*T(N&#x2F;b) + O(N^d) </p>
<p>​    1) log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a)) </p>
<p>​    2) log(b,a) &#x3D; d -&gt; 复杂度为O(N^d * logN) </p>
<p>​    3) log(b,a) &lt; d -&gt; 复杂度为O(N^d)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code06_GetMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123; <span class="comment">//arr[L...R]范围上只有一个数，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> arr[L];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + (R - L) &gt;&gt; <span class="number">1</span>;<span class="comment">//中点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> process(arr, L, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、认识O-NlogN-的排序"><a href="#二、认识O-NlogN-的排序" class="headerlink" title="二、认识O(NlogN)的排序"></a>二、认识O(NlogN)的排序</h2><h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h3><p>​    1）整体就是一个简单递归，左边排好序、右边排好序、让其整体有序 </p>
<p>​    2）让其整体有序的过程里用了排外序方法 </p>
<p>​    3）利用master公式来求解时间复杂度 </p>
<p>​    4）归并排序的实质 </p>
<p>​    时间复杂度O(N*logN)，额外空间复杂度O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> _1.class02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_1_MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">33</span>, <span class="number">95</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(arr, l, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            help[i] = arr[p1];</span><br><span class="line">            i++;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">            help[i] = arr[p2];</span><br><span class="line">            i++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">            arr[l + i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-归并排序的扩展"><a href="#2-归并排序的扩展" class="headerlink" title="2.归并排序的扩展"></a>2.归并排序的扩展</h3><p>​    小和问题和逆序对问题 </p>
<p>​    小和问题 </p>
<p>​    在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组 </p>
<p>​    的小和。求一个数组 的小和。 </p>
<p>​    例子:[1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左 </p>
<p>​    边比4小的数，1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、 </p>
<p>​    2; 所以小和为1+1+3+1+1+3+4+2&#x3D;16 </p>
<p>​    逆序对问题 在一个数组中，左边的数如果比右边的数大，则折两个数 </p>
<p>​    构成一个逆序对，请打印所有逆序对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小和问题</span></span><br><span class="line"><span class="keyword">package</span> _1.class02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_2_SmallSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallSum</span> <span class="operator">=</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(smallSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mergeSort(arr, l, mid)</span><br><span class="line">                + mergeSort(arr, mid + <span class="number">1</span>, r)</span><br><span class="line">                + merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> m + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">            res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">            arr[l + i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-堆"><a href="#3-堆" class="headerlink" title="3.堆"></a>3.堆</h3><p>1，堆结构就是用数组实现的完全二叉树结构 </p>
<p>2，完全二叉树中如果每棵子树的最大值都在顶部就是大根堆 </p>
<p>3，完全二叉树中如果每棵子树的最小值都在顶部就是小根堆 </p>
<p>4，堆结构的heapInsert与heapify操作 </p>
<p>5，堆结构的增大和减少 </p>
<p>6，优先级队列结构，就是堆结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">           swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">           index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> (left + <span class="number">1</span>) &lt; size &amp;&amp; arr[left] &lt; arr[left + <span class="number">1</span>] ? (left + <span class="number">1</span>) : left;</span><br><span class="line">           largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           swap(arr, index, largest);</span><br><span class="line">           index = largest;</span><br><span class="line">           left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h3><p>1，先让整个数组都变成大根堆结构，建立堆的过程: </p>
<p>1)从上到下的方法，时间复杂度为O(N*logN) </p>
<p>2)从下到上的方法，时间复杂度为O(N) </p>
<p>2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调 </p>
<p>整堆，一直周而复始，时间复杂度为O(N*logN) </p>
<p>3，堆的大小减小成0之后，排序完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> &amp;&amp; arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">            swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-堆排序扩展题目"><a href="#5-堆排序扩展题目" class="headerlink" title="5.堆排序扩展题目"></a>5.堆排序扩展题目</h3><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元 </p>
<p>素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的 </p>
<p>排序算法针对这个数据进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code04_SortArrayDistanceLessK</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortedArrDistanceLessK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">		PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; index &lt; Math.min(arr.length, k); index++) &#123;</span><br><span class="line">			heap.add(arr[index]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;</span><br><span class="line">			heap.add(arr[index]);</span><br><span class="line">			arr[i] = heap.poll();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">			arr[i++] = heap.poll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-荷兰国旗问题"><a href="#6-荷兰国旗问题" class="headerlink" title="6.荷兰国旗问题"></a>6.荷兰国旗问题</h3><p>问题一 </p>
<p>给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的 </p>
<p>数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N) </p>
<p>问题二(荷兰国旗问题) </p>
<p>给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放 </p>
<p>在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度 O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> l - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> r + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (l &lt; more) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[l] &lt; p) &#123;</span><br><span class="line">               swap(arr, ++less, l++);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; p) &#123;</span><br><span class="line">               swap(arr, --more, l++);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-随机快速排序（改进的快速排序）"><a href="#7-随机快速排序（改进的快速排序）" class="headerlink" title="7.随机快速排序（改进的快速排序）"></a>7.随机快速排序（改进的快速排序）</h3><p>1）在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分 </p>
<p>成三个部分： </p>
<p>左侧&lt;划分值、中间&#x3D;&#x3D;划分值、右侧&gt;划分值 </p>
<p>2）对左侧范围和右侧范围，递归执行 </p>
<p>3）时间复杂度为O(N*logN)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="三、详解桶排序以及排序内容大总结"><a href="#三、详解桶排序以及排序内容大总结" class="headerlink" title="三、详解桶排序以及排序内容大总结"></a>三、详解桶排序以及排序内容大总结</h2><h3 id="1-比较器的使用"><a href="#1-比较器的使用" class="headerlink" title="1.比较器的使用"></a>1.比较器的使用</h3><p>1）比较器的实质就是重载比较运算符 </p>
<p>2）比较器可以很好的应用在特殊标准的排序上 </p>
<p>3）比较器可以很好的应用在根据特殊标准排序的结构上</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理笔记</title>
    <url>/2022/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-计算机组成原理概论"><a href="#1-计算机组成原理概论" class="headerlink" title="1. 计算机组成原理概论"></a>1. 计算机组成原理概论</h2><p><strong>计算机</strong>：数字电子计算机</p>
<p><strong>组成</strong>：计算机硬件系统的逻辑实现</p>
<p><strong>原理</strong>：不以具体机型为依托的，基本实现原理。</p>
<p>计算机组成原理：掌握如何实现的具体细节。</p>
 <span id="more"></span> 

<h3 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h3><p>计算机系统由两大部分组成：硬件和软件。软件又包括系统软件和应用软件。</p>
<p>系统软件可以管理整个计算机系统：</p>
<ul>
<li><strong>语言处理程序（将高级语言转换为机器可以懂的指令）</strong></li>
<li><strong>操作系统</strong></li>
<li><strong>服务性程序（比如数学库、MPI服务程序进行并行之间的通信）</strong></li>
<li><strong>数据库管理系统</strong></li>
<li><strong>网络软件</strong></li>
</ul>
<p>应用软件是按照任务需要编制成的程序。</p>
<p>可以简单将软硬件看作一个层次结构，<strong>硬件为软件提供接口，系统软件又为应用软件形成接口，来完成不同的程序。</strong></p>
<p>对于计算机的物理结构层次，我们这门课主要研究逻辑层和微电路层的具体实现方式。</p>
<p>计算机系统的指令层次如下图所示</p>
<p><img src="https://pic1.zhimg.com/80/v2-f8f082641a793f54b240a3bedc01be50_720w.jpg"></p>
<p> 操作系统可以管理软硬件的资源。 </p>
<p><img src="https://pic1.zhimg.com/80/v2-3f91e6af54a662b9d5b72731171ef3b4_720w.jpg"></p>
<p>计算机系统结构<strong>定义了系统软硬件的交界面，定义了哪些功能由软件实现，哪些功能由硬件实现</strong>，定义为&#x3D;&#x3D;<strong>程序员所见到的计算机系统的属性概念性的结构与功能特性</strong>&#x3D;&#x3D;。（指令系统，数据类型，寻址技术，I&#x2F;O机理），即程序员需要理解的东西。</p>
<p>计算机组成：实现计算机体系结构所体现的属性，即<strong>具体指令的实现。</strong></p>
<h3 id="1-2-计算机的基本组成"><a href="#1-2-计算机的基本组成" class="headerlink" title="1.2 计算机的基本组成"></a>1.2 计算机的基本组成</h3><h3 id="1-2-1-冯诺依曼结构"><a href="#1-2-1-冯诺依曼结构" class="headerlink" title="1.2.1 冯诺依曼结构"></a>1.2.1 冯诺依曼结构</h3><p><img src="https://pic2.zhimg.com/80/v2-400ee3ebfddf3d69912ac93f011374ed_720w.jpg"></p>
<p>上图实线表示数据流动，虚线表示控制反馈。</p>
<ul>
<li>计算机结构由五大部件组成：<strong>存储器、运算器、控制器、输入设备、输出设备</strong>。</li>
<li><strong>以运算器为中心</strong>，**&#x3D;&#x3D;程序存储在存储器中&#x3D;&#x3D;**。</li>
<li><strong>指令和数据以同等地位</strong>保存在存储器中，可以按照地址寻找。</li>
<li>指令和数据由二进制表示，指令由操作码和地址码组成，<strong>操作码指明指令要干什么，地址码指明操作数的地址。</strong></li>
</ul>
<p>冯诺依曼结构以运算器为中心，容易形成瓶颈。我们可以使用存储器作为中心来进行优化，但是还不够。</p>
<h3 id="1-2-2-现代计算机硬件框图"><a href="#1-2-2-现代计算机硬件框图" class="headerlink" title="1.2.2 现代计算机硬件框图"></a>1.2.2 现代计算机硬件框图</h3><p><img src="https://pic3.zhimg.com/80/v2-69a1d35329ee45fc170771d35a166b86_720w.jpg" alt="img"></p>
<p>指令和数据都是保存在存储器中的。</p>
<h3 id="1-2-3-存储器的基本组成"><a href="#1-2-3-存储器的基本组成" class="headerlink" title="1.2.3 存储器的基本组成"></a>1.2.3 存储器的基本组成</h3><p><img src="https://pic4.zhimg.com/80/v2-944e43e25966b494973463043e549bab_720w.jpg" alt="img"></p>
<p><strong>MAR是存储器地址寄存器，保存了存储单元的地址和编号，长度反映存储单元的个数。</strong></p>
<p><strong>MDR是存储器数据寄存器，保存了要存入存储体的数据或刚从存储体拿出来的数据，长度反映存储字长。</strong></p>
<p>利用MAR和MDR来将数据放入存储器。</p>
<h3 id="1-2-4-运算器的结构"><a href="#1-2-4-运算器的结构" class="headerlink" title="1.2.4 运算器的结构"></a>1.2.4 运算器的结构</h3><p><img src="https://pic3.zhimg.com/80/v2-1dae6cfbd865f753be7315f812069af2_720w.jpg" alt="img"></p>
<p>ALU（算术逻辑单元），通常是一个组合电路，输入撤销，输出也撤销，<strong>因此需要加上寄存器保存参与运算的计算</strong>。</p>
<p>数据寄存器X保存输入参数，ACC为累加寄存器，保存结果，<strong>乘法可能使得数据位数保存不下，使用MQ寄存器保存低位。</strong></p>
<p>上表中存放了不同运算中，运算器的工作过程，以乘法为例，操作过程如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-027a4d6e589fb343988ccfa78f34fc96_720w.jpg" alt="img"></p>
<ul>
<li>首先将被乘数取出来放到ACC中</li>
<li>从指令中的乘数地址M中取出乘数，送入MQ中</li>
<li>将被乘数送到X中</li>
<li>将ACC清零</li>
<li>完成乘法操作，结果由ACC和MQ保存</li>
</ul>
<p>这些操作的过程顺序是由<strong>控制器来控制完成的。</strong></p>
<h3 id="1-2-5-控制器的基本结构"><a href="#1-2-5-控制器的基本结构" class="headerlink" title="1.2.5 控制器的基本结构"></a>1.2.5 控制器的基本结构</h3><p>控制器的功能是<strong>解释指令（完成指令）、保证指令的按序执行</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-8565f5dd792980b286d549bb7e6024a9_720w.jpg" alt="img"></p>
<ul>
<li><strong>PC（程序计数器）寄存器保存了当前指令的地址，进行取指令，PC有计数功能。</strong></li>
<li><strong>IR（指令寄存器）存放当前要执行的指令，将操作码送入CU进行分析。</strong></li>
<li><strong>CU（控制单元）发出控制信号，控制相对应的部件来执行指令。</strong></li>
</ul>
<p>下面以取数指令为例分析指令执行过程（取数送到ACC中）</p>
<p><img src="https://pic1.zhimg.com/80/v2-2daf226d97d2b36ccd8fcdf01a07dab4_720w.jpg" alt="img"></p>
<ol>
<li>PC保存指令的地址，送到MAR进行寻址</li>
<li>MAR根据地址到存储体中找到保存的指令</li>
<li>MDR从存储体中取出指令</li>
<li>送到IR中，IR存放要执行的指令</li>
<li>IR将操作码送入CU中进行分析</li>
<li>同时将地址码送到MAR中找这个数的数据</li>
<li>MAR根据地址到存储体中找到要取的数</li>
<li>MDR保存从存储体中取出的数</li>
<li>CU控制下，将要取的数送到ACC中。</li>
</ol>
<p><strong>CU分析控制这些步骤的过程。</strong></p>
<h3 id="1-3-计算机硬件的主要技术指标"><a href="#1-3-计算机硬件的主要技术指标" class="headerlink" title="1.3 计算机硬件的主要技术指标"></a>1.3 计算机硬件的主要技术指标</h3><ul>
<li>机器字长：CPU一次能处理数据的位数，与CPU中寄存器位数有关。</li>
<li>运算速度：主频、核数以及每个核支持的线程数、CPI（执行一条指令所需的时钟周期数）、MIPS（每秒执行百万条指令）、FLOPS（每秒浮点运算次数）。</li>
<li>存储容量：主存容量（可使用存储单元个数×存储字长来表示存储体容量，MAR * MDR）（也可使用字节数来表示）、辅存容量（字节数表示）。</li>
</ul>
<h2 id="2-计算机的发展以及应用"><a href="#2-计算机的发展以及应用" class="headerlink" title="2. 计算机的发展以及应用"></a>2. 计算机的发展以及应用</h2><h3 id="2-1-计算机的发展史"><a href="#2-1-计算机的发展史" class="headerlink" title="2.1 计算机的发展史"></a>2.1 计算机的发展史</h3><p>第一台计算机，1946年ENIAC，十进制运算。</p>
<p>电子技术的发展与计算机体系结构技术的发展对计算机的发展产生了决定性作用。</p>
<p>根据硬件技术来对计算机进行划分代</p>
<p><strong>电子管→晶体管→中小规模集成电路→大规模集成电路→超大规模集成电路</strong></p>
<p>软件技术的发展：机器语言（面向机器）、汇编语言（面向机器）、高级语言（面向问题）。</p>
<h3 id="2-2-计算机的应用"><a href="#2-2-计算机的应用" class="headerlink" title="2.2 计算机的应用"></a>2.2 计算机的应用</h3><ul>
<li>科学计算和数据处理</li>
<li>工业控制和实时控制</li>
<li>网络技术</li>
<li>虚拟现实</li>
<li>办公自动化和管理信息系统</li>
<li>CAD&#x2F;CAM&#x2F;CIMS</li>
<li>多媒体技术</li>
<li>人工智能</li>
</ul>
<h2 id="3-系统总线"><a href="#3-系统总线" class="headerlink" title="3. 系统总线"></a>3. 系统总线</h2><h3 id="3-1-总线（bus）的基本概念"><a href="#3-1-总线（bus）的基本概念" class="headerlink" title="3.1 总线（bus）的基本概念"></a>3.1 总线（bus）的基本概念</h3><p>总线是连接各个部件的信息传输线，<strong>是各个部件共享的传输介质，</strong>是信号的公共传输线。</p>
<p>如果使用单总线结构（系统总线），那么<strong>同时只能有一对部件进行信号传输</strong>，效率较低，使用双总线结构效率会更高。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9a04dd0d8329e04fd06ec42467131cba_720w.jpg" alt="img"></p>
<p>上面的结构，无法在I&#x2F;O和主存之间进行直接的信息传输，必须要通过CPU。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b5b1ba238025a0f9938165accb1a4f9e_720w.jpg" alt="img"></p>
<h3 id="3-2-总线的分类"><a href="#3-2-总线的分类" class="headerlink" title="3.2 总线的分类"></a>3.2 总线的分类</h3><ul>
<li><p>片内总线：芯片内部的总线。</p>
</li>
<li><p>系统总线：计算机各部件之间的信息传输线。可分为：</p>
</li>
<li><ul>
<li><strong>数据总线</strong>，双向的，一般小于等于机器字长和存储字长。</li>
<li><strong>地址总线</strong>，单向的，与存储地址、I&#x2F;O地址有关。</li>
<li><strong>控制总线</strong>，双向（CPU发出存储器读写指令，总线允许，中断确认等；CPU接收中断请求、总线请求）</li>
</ul>
</li>
<li><p>通信总线：计算机之间或计算机和其它设备之间的通信，并行通信总线和串行通信总线。</p>
</li>
</ul>
<h3 id="3-3-总线的特性和性能指标"><a href="#3-3-总线的特性和性能指标" class="headerlink" title="3.3 总线的特性和性能指标"></a>3.3 总线的特性和性能指标</h3><p>总线印刷到电路板上（主板），其他设备插板插到主板上。</p>
<p><img src="https://pic2.zhimg.com/80/v2-686025071c4309677ef414d14bcd0cf1_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-31dc1a5a161020875b92e8fe70961701_720w.jpg" alt="img"></p>
<p>总线的性能指标：</p>
<ul>
<li>总线宽度：数据线根数，同时可以传输多少位。</li>
<li>标准传输率：每秒传输的最大字节数MBps</li>
<li>时钟同步&#x2F;不同步</li>
<li>总线复用：地址线与数据线是否可以复用</li>
<li>信号线数：地址线、数据线和控制线的总和</li>
<li>总线控制方式</li>
<li>其他指标：负载能力等</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-5d968958b712d0a2724af6824bdd93ee_720w.jpg" alt="img"></p>
<h3 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h3><p><img src="https://pic1.zhimg.com/80/v2-48c250bf81a7d88ca9033cb90f4b8d60_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-b7450aa5377fae2a59d7b034dc1b4a66_720w.jpg" alt="img"></p>
<p><strong>增加了DMA（直接存储器访问）总线，外部设备直接访问存储器内存。</strong>高速设备直接通过DMA访问主存。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e99a5cffacc23efec4bb49fdf16ac7ed_720w.jpg" alt="img"></p>
<p>CPU与cache通过局部总线进行相连，扩展总线将外部设备连接。</p>
<p><img src="https://pic4.zhimg.com/80/v2-5b91de164ae2dff903b0b7b0c0851b7f_720w.jpg" alt="img"></p>
<p>高速设备和低速设备分离，分别连接到高速总线和扩展总线上。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1f7ae7d57def2dc29ed21ef32eccf229_720w.jpg" alt="img"></p>
<p>PCI高速总线来连接高速设备，PCI总线可以通过桥来进行扩展。</p>
<h3 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h3><h3 id="3-5-1-总线判优控制"><a href="#3-5-1-总线判优控制" class="headerlink" title="3.5.1 总线判优控制"></a>3.5.1 总线判优控制</h3><p>通过是否能对总线发出占用请求，我们将设备分为主设备（主模块）和从设备（从模块）。<strong>主设备可以对总线有控制权，从设备响应从主设备发来的总线命令。</strong></p>
<p>总线判优控制可以分为两种：集中式和分布式。下面介绍几种集中式的总线判优控制结构。</p>
<p><img src="https://pic1.zhimg.com/80/v2-861b7aeec653084b2dda2ab9e4ae8130_720w.jpg" alt="img"></p>
<p>主设备通过BR申请总线的控制权，<strong>有设备在使用总线，则设置BS。总线控制部件通过BG来链式查询这些接口是否提出了BR，遇到了BR则交出控制权。</strong></p>
<p><strong>因此，优先顺序则为BG的查询顺序</strong>。这种结构对电路故障特别敏感，尤其是BG，如果BG后面出了问题，会导致后面的设备一直不会响应。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c6994c004889ac4b70e8af961524b90b_720w.jpg" alt="img"></p>
<p>数据线用于数据的传输，地址线用于从设备的查找。<strong>通过设备地址线来查找某个设备是否发出总线请求。计数器的值通过设备地址线进行传输，来查找某个设备是否发出请求。</strong>可以自定义计数器的计数方式，来改变从哪个设备先查询等。</p>
<p><img src="https://pic1.zhimg.com/80/v2-6fc0b9baef4000172b465032bcd6e6e4_720w.jpg" alt="img"></p>
<p>为每个I&#x2F;O接口增加了BR和BG，<strong>通过排队器来进行优先级排队</strong>。这种方式使用的线数较多。</p>
<h3 id="3-5-2-总线通信控制"><a href="#3-5-2-总线通信控制" class="headerlink" title="3.5.2 总线通信控制"></a>3.5.2 总线通信控制</h3><p>为了解决通信双方（主从设备）协调配合的问题。</p>
<p>总线的传输周期（完成一次主从设备完整可靠的传输所需要的时间）：</p>
<ul>
<li>申请分配阶段：主设备申请，总线决定</li>
<li>寻址阶段：主设备向向从设备给出地址和命令</li>
<li>传数阶段：主设备和从设备进行交换数据</li>
<li>结束阶段：主从设备撤销有关信息</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-09b037f3510443143bc0562ae67b0637_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-b9fbb40ece372f60d0c503a8203edd0e_720w.jpg" alt="img"></p>
<ul>
<li>T1，主设备给出地址信号</li>
<li>T2，给出从设备的读命令信号</li>
<li>T3，从设备给出数据，输出到总线，完成数据交换</li>
<li>T4，撤销地址信号，结束周期</li>
</ul>
<p>强制同步，如果设备之间速度不同，快的设备需要等慢的设备。</p>
<p><img src="https://pic2.zhimg.com/80/v2-bf4f0e7fde69e32e3e6c096b5d150a05_720w.jpg" alt="img"></p>
<p><strong>不互锁：不管从设备是否接收到请求信号，过段时间主设备都会撤销请求。不管主设备是否接收到应答信号，从设备多段时间都会撤销应答。</strong></p>
<p>半互锁和全互锁针对上面进行改进。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c350d75aee932c08977c635af7c70739_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-bf899d524112b9cd84b9f79fa2e2545e_720w.jpg" alt="img"></p>
<p>增加等待响应信号，当wait为低电平，则等待一个T。</p>
<p><img src="https://pic3.zhimg.com/80/v2-498179fa698c849afd894fd05900aea6_720w.jpg" alt="img"></p>
<p>使用分离式通信来将总线空闲的时间也充分利用起来。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a5e440385d7b6d3ad44f917e1c23d309_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-f509b451261ca9960f4d801aeddc7543_720w.jpg" alt="img"></p>
<h2 id="4-存储器"><a href="#4-存储器" class="headerlink" title="4. 存储器"></a>4. 存储器</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>按照存取方式对存储器进行分类：</p>
<ul>
<li>存取时间与物理地址无关（随机访问）：随机存储器、只读存储器。</li>
<li>存取时间与物理地址有关（串行访问）：顺序存取存储器（磁带）、直接存取存储器（磁盘）。</li>
</ul>
<p>按照在计算机中的作用分类：</p>
<p><img src="https://pic1.zhimg.com/80/v2-3e474b4e2264a9d5329dbb547d6f66e8_720w.jpg" alt="img"></p>
<p>存储器的层次结构：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1c67cdce3a2f34f0bde957a63c88f7eb_720w.jpg" alt="img"></p>
<ul>
<li>寄存器包括体系结构寄存器和非体系结构寄存器。</li>
<li>一部分缓存放在了CPU之中。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ecb8493e385dd90519547b2260d84a0a_720w.jpg" alt="img"></p>
<ul>
<li>缓存——主存层次，使用硬件方法连接到一个整体（对程序员透明，即不需要了解），速度较快，解决CPU和主存之间速度差距较大的问题，缓存即为cache，CPU可以直接从缓存调用数据，cache和主存也进行数据交换。使用主存储器的实地址和物理地址。</li>
<li>主存——辅存层次，使用软硬件结合方式连接，容量较大，解决容量不足问题。这个层次称为虚拟存储器，使用虚地址和逻辑地址。</li>
</ul>
<h3 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h3><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>主存的基本组成：</p>
<p><img src="https://pic4.zhimg.com/80/v2-a4cb6c6fa5d63b7d76cc8c9c98532a73_720w.jpg" alt="img"></p>
<p>主存与CPU之间的联系：</p>
<p><img src="https://pic1.zhimg.com/80/v2-c14afbf373caeb20cf157df27bbda84c_720w.jpg" alt="img"></p>
<p>主存中存储单元地址的分配：</p>
<ul>
<li>每个字节（8位）一个地址，如果一个存储单元存储32位，即四个字节为一个字，可<strong>以将高位字节&#x2F;低位字节，放在小的地址作为字地址。</strong></li>
</ul>
<p>主存的技术指标：</p>
<p><img src="https://pic2.zhimg.com/80/v2-42cda5798755d4a507b46a0d2dd0f789_720w.jpg" alt="img"></p>
<h3 id="4-2-2-主存储器半导体芯片简介"><a href="#4-2-2-主存储器半导体芯片简介" class="headerlink" title="4.2.2 主存储器半导体芯片简介"></a>4.2.2 主存储器半导体芯片简介</h3><p>基本结构：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b7ff96d3e063a3a156a9994a487b0b00_720w.jpg" alt="img"></p>
<ul>
<li>地址线（单向）给出地址，经过译码驱动电路来选择指定的存储单元，完成数据的读写操作（数据线双向）。</li>
<li>片选线是芯片选择信号，给出这次选择的地址是不是这个芯片的地址。</li>
<li>读写控制线，控制操作允许读还是写。</li>
<li>根据地址线和数据线条数，可以计算出芯片容量。<strong>如果地址线10条，数据线4条，那么芯片容量则为1K×4位。即1K个地址，每个地址数据4位。</strong></li>
</ul>
<p>译码驱动方式：</p>
<p>第一种方法是线选法</p>
<p><img src="https://pic3.zhimg.com/80/v2-72e60fb35e95ccd82f6196065319305a_720w.jpg" alt="img"></p>
<ul>
<li>使用地址译码器，给定输入，输出只有一根线（字线）是有效的，图中一根线中是8个芯片组合成一个字，那么只有一根线的这一组芯片有效。</li>
<li><strong>这种方法，每个字的存储单元都需要一根线，当容量较大的时候，很麻烦。</strong></li>
</ul>
<p>第二种方法是重合法</p>
<p><img src="https://pic4.zhimg.com/80/v2-b3e78113246d8c759c93ac9f54857c93_720w.jpg" alt="img"></p>
<ul>
<li>将所有存储单元布置成二维的阵列，使用两个地址译码器XY，一组(X,Y)对应一个存储单元。</li>
<li>这样会大大降低所需要的线数量。</li>
</ul>
<h3 id="4-2-3-随机存取存储器（RAM）"><a href="#4-2-3-随机存取存储器（RAM）" class="headerlink" title="4.2.3 随机存取存储器（RAM）"></a>4.2.3 随机存取存储器（RAM）</h3><h3 id="4-2-3-1-静态RAM（SRAM）"><a href="#4-2-3-1-静态RAM（SRAM）" class="headerlink" title="4.2.3.1 静态RAM（SRAM）"></a>4.2.3.1 静态RAM（SRAM）</h3><p>SRAM的基本电路：</p>
<p><img src="https://pic1.zhimg.com/80/v2-f91729a10c9c02ac0e0b40eee2873448_720w.jpg" alt="img"></p>
<ul>
<li><strong>使用触发器T1-T4来存储0&#x2F;1，T5、T6控制存储单元读写，实际中会有许多虚线框进行堆叠，T7、T8列开关，一列共用。同样，可以横向进行堆叠，那么行地址选择的这一行，所有存储单元的T5和T6都会导通，但是只有对应列也有效的那个存储单元才进行读写。</strong></li>
<li><strong>通过行选和列选，选中进行读写操作的存储单元。</strong></li>
</ul>
<p>SRAM芯片举例（Intel 2114）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e69116568a98aebf26024116e8306794_720w.jpg" alt="img"></p>
<ul>
<li>WE读写控制信号，CS片选信号，A0-A9为地址线，4个I&#x2F;O数据线。</li>
<li>10根地址线，使用重合法，6线为行地址，4线为列地址，每个列信号控制四列，这样一次就可以选择4位，将这4位看做是一个存储单元。就完成了1K×4位的选择。</li>
</ul>
<h3 id="4-2-3-2-动态RAM（DRAM）"><a href="#4-2-3-2-动态RAM（DRAM）" class="headerlink" title="4.2.3.2 动态RAM（DRAM）"></a>4.2.3.2 动态RAM（DRAM）</h3><p>DRAM的基本电路：</p>
<p><img src="https://pic3.zhimg.com/80/v2-1c1006911b42899ac25b7532eb848f0a_720w.jpg" alt="img"></p>
<ul>
<li>利用电容，如果电容保存了电荷，则认为保存是1，没有电，则认为是0。</li>
<li>保存在Cg上，T1、T2、T3是控制管。</li>
<li><strong>读出信息与原信息相反，需要加非门。</strong></li>
<li><strong>写入信息与输入信息相同。</strong></li>
</ul>
<p>还有一种结构是单管动态RAM：</p>
<p><img src="https://pic3.zhimg.com/80/v2-7d5a3d3ecb3f411a4117c7bfee4558a2_720w.jpg" alt="img"></p>
<ul>
<li>读出数据时，数据线有电，则为1。</li>
<li>写入时，Cs充电为1，放电为0。</li>
</ul>
<p>三管DRAM芯片举例（Intel 1103）：</p>
<p><img src="https://pic2.zhimg.com/80/v2-fb0f1504423e9c9a49b2f1d62e295ae1_720w.jpg" alt="img"></p>
<ul>
<li>因为电容会漏电，刷新放大器会定时对存储的信息进行刷新。</li>
</ul>
<p>单管DRAM芯片举例（Intel 4116 16k×1位）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-33b78430483e07932e1a7ef4947bedd8_720w.jpg" alt="img"></p>
<ul>
<li>只有7根地址线，通过两次，来接受行地址和列地址，存放到对应的缓存器中。</li>
<li>通过行时钟、列时钟、写时钟来控制读写。</li>
</ul>
<p>动态RAM的刷新：</p>
<ul>
<li>每一次刷新只与行地址有关，与列地址没有关系，每次刷新一行。</li>
<li>集中刷新（在某段时间集中刷新所有的电容），这段时间DRAM是不可用的，称为死区。</li>
<li>分散刷新（每次读写操作之后，将某一行刷新），相当于将原来的读写操作的时间变长，把刷新操作放在读写操作中，这样就不存在死区。分散刷新比较频繁，有点过度刷新了。</li>
<li>异步刷新（将上面两种结合），则每隔一段时间对某一行进行刷新，即多个读写操作加一个刷新操作。</li>
</ul>
<h3 id="4-2-3-3-两种RAM的比较"><a href="#4-2-3-3-两种RAM的比较" class="headerlink" title="4.2.3.3 两种RAM的比较"></a>4.2.3.3 两种RAM的比较</h3><p><img src="https://pic4.zhimg.com/80/v2-3cea24c6da2cb4a2d97fbceaf3f26507_720w.jpg" alt="img"></p>
<ul>
<li>DRAM的集成度较高，每个存储单元复杂度较低。</li>
<li>SRAM的速度较快，一般用作缓存。</li>
</ul>
<h3 id="4-2-4-只读存储器（ROM）"><a href="#4-2-4-只读存储器（ROM）" class="headerlink" title="4.2.4 只读存储器（ROM）"></a>4.2.4 只读存储器（ROM）</h3><p>ROM中一般保存系统信息或系统程序。早期是只读的，不可以写，经过多年的发展和改进，现在的ROM可以自己多次读写。</p>
<ul>
<li>掩模ROM（MROM）：只读，不能修改。行列选择线交叉处有MOS管则为1，没有则为0。</li>
<li>PROM（一次性编程）：熔丝断了，则为0，否则为1。可以一次性的破坏性编程。</li>
<li>EPROM（可以多次编程）：N型沟道浮动栅MOS电路。S与D导通为1，不导通为0。</li>
<li>EEPROM（多次性编程）：电可擦写、局部擦写、全部擦写。</li>
<li>Flash Memory（闪存型存储器）：比EEPROM快，具有RAM的一些功能。</li>
</ul>
<h3 id="4-2-5-CPU与存储器的连接"><a href="#4-2-5-CPU与存储器的连接" class="headerlink" title="4.2.5 CPU与存储器的连接"></a>4.2.5 CPU与存储器的连接</h3><p>存储器容量扩展可以通过位扩展（增加存储字长）、字扩展（增加存储字的数量）、同时扩展。</p>
<p>CPU与存储器的连接：</p>
<ul>
<li>地址线的连接：<strong>低位作为地址，高位作为片选信号</strong>。</li>
<li>数据线的连接</li>
<li>读写命令控制线的连接</li>
<li>片选线的连接：<strong>MREQ信号（表示该信号是连接存储器还是I&#x2F;O接口）一定要连接到片选信号中，</strong>使得只有这个信号有效，才是CPU和内存连接工作。</li>
<li>合理选择存储芯片（ROM&#x2F;RAM，芯片的性能参数）</li>
<li>其他：时序、负载</li>
</ul>
<h3 id="4-2-6-存储器的校验"><a href="#4-2-6-存储器的校验" class="headerlink" title="4.2.6 存储器的校验"></a>4.2.6 存储器的校验</h3><p>校验，检测合法代码，对非法代码进行纠错。</p>
<p><strong>编码的纠错、检错能力与编码的最小距离有关。最小距离为任意两组合法代码之间二进制位数的最小差异。</strong> $$ L-1 &#x3D; D + C\ (D≥C) $$ <strong>L为最小距离，D为检测错误的位数，C为纠正错误的位数。</strong></p>
<p>汉明码是具有一位纠错能力的编码，汉明码都采用了奇偶校验和分组校验（分组的奇偶校验，分组之间是有重叠的，校验位放在2 ^ k处，k&#x3D;0,1,2,3…）。</p>
<p>汉明码的分组，将代码中每一位进行分组（1,2,3,4,5,6,7序号），<strong>将每一位的序号进行分组，序号的二进制最右边一位为1的，第一组，右边第二位为1的，第二组……</strong></p>
<p>&#x3D;&#x3D;<strong>最后的校验结果，哪一位是1，那么这位对应的那组中的那个序号的代码位出错。如果出现了多个1，那么就是这几个组中公共的那位出错了。</strong>&#x3D;&#x3D;</p>
<h3 id="4-2-7-提高主存的访问以及存储速度"><a href="#4-2-7-提高主存的访问以及存储速度" class="headerlink" title="4.2.7 提高主存的访问以及存储速度"></a>4.2.7 提高主存的访问以及存储速度</h3><p>CPU速度提升很快，但是存储器的速度提升较慢。</p>
<p><strong>我们可以采用高速器件，采用层次结构（Cache-主存）,&#x3D;&#x3D;调整主存结构。&#x3D;&#x3D;</strong></p>
<ul>
<li>单体多字系统：使得存储器的存储字长大于CPU的字长（比如是CPU字长的4倍），这样一次读取就可以读取多个指令。<strong>但是这样会导致存储器结构复杂， 而且，如果需要执行的指令不是连续存放的，会更麻烦。</strong></li>
<li>多体并行方式：</li>
<li>高位交叉：对各个存储体进行编号，存储体内部自行编号，每个存储体独立，有自己的控制编号。这样CPU给出的地址是<strong>体号+体内地址</strong>，各个存储体可以并行处理。（类似存储器容量的扩展）如果程序指令存方式顺序的，实际上还是在一个存储体中，并无法提升存储体速度。</li>
<li>低位交叉：<strong>体内地址+体号</strong>，使用横向的编码，比如存储体为M0-M3，那么第一个地址为M0的第一个位置，第二个地址为M1的第一个位置……这样<strong>M0中所有地址后两位都为00，M1都为01，M2都为10，M3都为11。后两位给出了存储体的选择地址。</strong>这样如果程序指令顺序存放的地址，实际上是不同存储体并行处理，这样就提升了效率，流水操作。</li>
</ul>
<h3 id="4-3-高速缓冲存储器（Cache）"><a href="#4-3-高速缓冲存储器（Cache）" class="headerlink" title="4.3 高速缓冲存储器（Cache）"></a>4.3 高速缓冲存储器（Cache）</h3><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><p>CPU与主存（DRAM）之间存在速度差异，为了避免CPU“空等”的现象，使用cache。</p>
<p><img src="https://pic4.zhimg.com/80/v2-353ef48785f13a861a6c7098e01cf40b_720w.jpg" alt="img"></p>
<p><strong>程序访问的局部性原理</strong>：</p>
<ul>
<li>时间的局部性：当前正在使用的指令或数据，会在不久的将来还会使用到，那么应该把这种数据或指令放在缓存中。</li>
<li>空间的局部性：当前正在使用的指令或数据，不久的将来，相邻的指令或数据会使用到，那么应该把当前和相邻的指令和数据放到缓存中。</li>
</ul>
<p>cache的工作原理：</p>
<p><strong>把主存和cache分成大小相等的块</strong>，每个块大小相等，主存的块数量远远大于cache的块数量。**&#x3D;&#x3D;主存与cache之间的信息传送是按块传送，块内地址不变，cache的每个块的标记，标记了这个块是主存的哪个块。&#x3D;&#x3D;**</p>
<p>主存块调入了缓存（即cache标记了），称为命中，CPU可直接在缓存中取得数据；如果没有调入，称为未命中。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b389e6288a972d06339a6a02668b9b12_720w.jpg" alt="img"></p>
<p>我们希望，每次执行程序，都尽可能的在cache中提取数据，这样速度会很快。<strong>CPU欲访问的信息在Cache中的比率称为命中率，命中率与Cache的容量和块长有关。</strong>一般每块取4-8个字，一般为一个存取周期内从主存调出的信息长度。</p>
<p>cache与主存的访问效率：</p>
<p><strong>这里面平均访问时间为每次访问的平均时间</strong>（可能从cache，可能从主存）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-483109d42dab83c244559504f862bf9b_720w.jpg" alt="img"></p>
<h3 id="4-3-2-cache的基本结构与读写操作"><a href="#4-3-2-cache的基本结构与读写操作" class="headerlink" title="4.3.2 cache的基本结构与读写操作"></a>4.3.2 cache的基本结构与读写操作</h3><p>cache的基本结构：</p>
<p><img src="https://pic1.zhimg.com/80/v2-01dc495db6a09ddf0022618f1bb88640_720w.jpg" alt="img"></p>
<p>读写操作：</p>
<p><img src="https://pic3.zhimg.com/80/v2-61c29bfc2dcc23820a116b253e1dfc4a_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-2e4806efb2c9888730795934df565fa6_720w.jpg" alt="img"></p>
<ul>
<li>前者时刻保持了cache和主存的一致，后者只写cache中，当cache中退出时才写回主存。</li>
</ul>
<p>cache的改进：</p>
<ul>
<li>增加cache的级数：片内cache，片外cache。</li>
<li>分立缓存：指令cache，数据cache。</li>
</ul>
<h3 id="4-3-3-cache-主存的地址映射"><a href="#4-3-3-cache-主存的地址映射" class="headerlink" title="4.3.3 cache-主存的地址映射"></a>4.3.3 cache-主存的地址映射</h3><p>即主存的任意一块加载到cache中的哪块。</p>
<p>直接映射：</p>
<p><strong>即主存中任意一个块，只能映射到指定的一个cache块中，</strong>cache块可以是一对多的。相当于将主存分区，每个区内的这些块，对应于cache的所有块；<strong>这样在cache的标记中，有t位的标记，表示当前该cache块存放的是主存哪个区的对应位置信息。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-b4ae19aa355063f31023956d9df31399_720w.jpg" alt="img"></p>
<hr>
<p>这种方法cache块的利用率比较低，且可能会冲突。</p>
<p>全相联映射：</p>
<p><strong>主存中任意一个块，可以被放入cache中的任意一个块中。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-cdf526e1135e3779f38c0f1d70867524_720w.jpg" alt="img"></p>
<p>这样的话，<strong>虽然块的利用率高了，但是因为块可以映射到任意一个位置，如果查询某个主存块是否已经放入cache，需要比较所有的cache标记，速度较慢。</strong></p>
<p>**&#x3D;&#x3D;组相联映射&#x3D;&#x3D;**：</p>
<p>与直接映射相似，**&#x3D;&#x3D;将cache分组，每个组可以有多个块；将主存分区，每个区的大小为cache的组数&#x3D;&#x3D;<strong>。这样每个区的第0块，可以放入cache第0组的任何一个位置，</strong>因为每个组有多个块，解决了直接映射的冲突问题；想查询某个主存的块是否放入了cache，只需要在对应的组进行查询即可，解决了全相联映射的问题。**</p>
<p><img src="https://pic2.zhimg.com/80/v2-8bf0c9b2d66ba574d6c7d8b0f39004d5_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-f97734f6f2adaff46b770237f2722735_720w.jpg" alt="img"></p>
<h3 id="4-3-4-替换算法"><a href="#4-3-4-替换算法" class="headerlink" title="4.3.4 替换算法"></a>4.3.4 替换算法</h3><p>如果内存块满了，如何替换，将谁弹出。</p>
<p><strong>先进先出（FIFO）算法</strong></p>
<p><strong>近期最少使用（LRU）算法</strong></p>
<h3 id="4-4-辅助存储器"><a href="#4-4-辅助存储器" class="headerlink" title="4.4 辅助存储器"></a>4.4 辅助存储器</h3><p>辅助存储器的主要作用是保存程序、文档和影音资料，<strong>不能直接与CPU交换信息，需要调入主存才能进行读写。</strong></p>
<p>包括磁盘存储器和光盘存储器等。</p>
<h2 id="5-输入输出系统"><a href="#5-输入输出系统" class="headerlink" title="5. 输入输出系统"></a>5. 输入输出系统</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p><strong>发展概况：</strong></p>
<ul>
<li>早期CPU与I&#x2F;O设备串行工作，分散连接。使用程序查询方式连接。</li>
<li>后来使用总线连接（一条总线可以连接多个设备），出现了I&#x2F;O接口和DMA控制器，并行工作。</li>
<li>具有通道结构的阶段。</li>
<li>具有I&#x2F;O处理机的阶段（I&#x2F;O的独立性更强，使用I&#x2F;O处理器）。</li>
</ul>
<p><strong>I&#x2F;O系统的组成：</strong></p>
<ul>
<li><p>I&#x2F;O软件：</p>
</li>
<li><ul>
<li>CPU中的I&#x2F;O指令，来控制外部设备与主机协调工作，**格式为&#x3D;&#x3D;操作码+命令码+设备码&#x3D;&#x3D;**。</li>
<li>通道指令，通道自身的指令。</li>
</ul>
</li>
<li><p>I&#x2F;O硬件：</p>
</li>
<li><ul>
<li>设备以及I&#x2F;O接口，或者设备以及设备控制器，通道。</li>
</ul>
</li>
</ul>
<p><strong>I&#x2F;O设备与主机的联系方式：</strong></p>
<ul>
<li>对I&#x2F;O设备进行编址：<strong>统一编址（将I&#x2F;O地址放在内存的地址空间中，可以直接使用指令对外部设备进行存取数），不统一编址（需要使用专门的I&#x2F;O指令来调用设备）。</strong></li>
<li>设备选址：使用设备选择电路识别某个设备是否被选中。</li>
<li>数据传送方式：串行（一位一位传输）&#x2F;并行（多位同时传输）。</li>
</ul>
<p><strong>联络方式：</strong></p>
<ul>
<li>立即响应，接收到数据&#x2F;指令，直接响应。</li>
<li>异步工作，使用应答信号，可以并行也可以串行（I&#x2F;O设备与接口之间）</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-36018d99ff90a6a72e0d9566a3c2a933_720w.jpg" alt="img"></p>
<ul>
<li>同步工作，使用同步时标。</li>
</ul>
<p><strong>I&#x2F;O设备与主机的连接方式：</strong>分散连接（辐射式连接，每台设备都配有一套控制线路和信号线），总线连接。</p>
<p><strong>I&#x2F;O设备与主机信息传送的控制方式：</strong></p>
<ul>
<li>程序查询方式（CPU与I&#x2F;O串行工作，<strong>CPU需要等待，效率很低</strong>，CPU连接I&#x2F;O设备和内存）</li>
<li>程序中断方式（部分并行，<strong>CPU被一定程度解放，在IO设备自身准备的时候，CPU可以先进行自己的工作，当IO与主机进行信息交换的时候，CPU暂停自身程序，来参与信息交换</strong>）。</li>
<li>DMA方式（使外部设备与内存建立连接，解放cpu，**主存与IO之间有一条直接数据通道，通过DMA控制器可以直接进行数据交换，&#x3D;&#x3D;采用周期窃取，借用一个存取周期，使得DMA控制总线，完成数据在IO和主存之间的传送&#x3D;&#x3D;**，在这个周期中，CPU不能控制总线，但可以继续执行不需要访存的指令）。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-c8814fbc3f16c95db1e05626741ba498_720w.jpg" alt="img"></p>
<h3 id="5-2-外部设备"><a href="#5-2-外部设备" class="headerlink" title="5.2 外部设备"></a>5.2 外部设备</h3><ul>
<li>输入设备：键盘、鼠标、触摸屏</li>
<li>输出设备：显示器、打印机</li>
<li>其他：A&#x2F;D,D&#x2F;A转换器，终端，汉字处理</li>
<li>多媒体技术：VR等</li>
</ul>
<h3 id="5-3-I-x2F-O接口"><a href="#5-3-I-x2F-O接口" class="headerlink" title="5.3 I&#x2F;O接口"></a>5.3 I&#x2F;O接口</h3><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>为什么要设置接口：</p>
<ul>
<li>实现设备的选择</li>
<li>实现数据缓冲，达到速度匹配</li>
<li>实现数据串&#x2F;并格式转换</li>
<li>实现电平转换（主机和IO设备工作电平可能不一致）</li>
<li>传送控制命令</li>
<li>反映设备的状态（忙、就绪、中断请求）</li>
</ul>
<h3 id="5-3-2-接口的功能和组成"><a href="#5-3-2-接口的功能和组成" class="headerlink" title="5.3.2 接口的功能和组成"></a>5.3.2 接口的功能和组成</h3><p>主机通过IO总线与IO设备相连接。</p>
<p><img src="https://pic1.zhimg.com/80/v2-234b9a9141dabb3978007f891e1a90c8_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-049a5f99304a3a6a6fa3e540ebd7859e_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-50f0d2effcdf192b2efa20964052a8a9_720w.jpg" alt="img"></p>
<p>五大部分：<strong>数据缓冲寄存器、设备状态标记、控制逻辑电路、设备选择电路、命令寄存器和命令译码器。</strong></p>
<h3 id="5-3-3-接口类型"><a href="#5-3-3-接口类型" class="headerlink" title="5.3.3 接口类型"></a>5.3.3 接口类型</h3><ul>
<li>按照数据传送方式：串行&#x2F;并行</li>
<li>按照功能选择的灵活性：可编程接口&#x2F;不可编程接口</li>
<li>按通用性：通用接口&#x2F;专用接口</li>
<li>按数据传送的控制方式：中断接口&#x2F;DMA接口</li>
</ul>
<h3 id="5-4-程序查询方式"><a href="#5-4-程序查询方式" class="headerlink" title="5.4 程序查询方式"></a>5.4 程序查询方式</h3><p><img src="https://pic2.zhimg.com/80/v2-a3845c55270c15d3d1c93bda1307cfa1_720w.jpg" alt="img"></p>
<p><strong>程序查询方式的接口电路：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-02069a45157ce0961a13a2c881601ec9_720w.jpg" alt="img"></p>
<ul>
<li>当D等于1的时候，IO完成了送入数据到DBR，<strong>此时CPU通过数据线读入数据，在D等于1之前，CPU一直在原地踏步等待。</strong></li>
</ul>
<h3 id="5-5-程序中断方式"><a href="#5-5-程序中断方式" class="headerlink" title="5.5 程序中断方式"></a>5.5 程序中断方式</h3><h3 id="5-5-1-中断的概念"><a href="#5-5-1-中断的概念" class="headerlink" title="5.5.1 中断的概念"></a>5.5.1 中断的概念</h3><p>CPU在执行程序的时候，<strong>遇到特殊事件或异常事件，暂停原来的程序，去处理这个事件（执行中断服务程序），之后再继续执行原来的程序。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-ed5ead354e598f429c5d2fbb5fc5c16e_720w.jpg" alt="img"></p>
<h3 id="5-5-2-I-x2F-O中断的产生"><a href="#5-5-2-I-x2F-O中断的产生" class="headerlink" title="5.5.2 I&#x2F;O中断的产生"></a>5.5.2 I&#x2F;O中断的产生</h3><p><img src="https://pic3.zhimg.com/80/v2-21b5873456d87e7ba9dc462989f79262_720w.jpg" alt="img"></p>
<h3 id="5-5-3-程序中断方式的接口电路"><a href="#5-5-3-程序中断方式的接口电路" class="headerlink" title="5.5.3 程序中断方式的接口电路"></a>5.5.3 程序中断方式的接口电路</h3><ul>
<li>配置中断请求触发器和中断屏蔽触发器（如果目前执行的程序比请求的设备优先级高，则屏蔽该中断请求）</li>
<li>排队器（有多个中断的话，需要使用排队器，根据优先级进行排队）</li>
<li>中断向量地址形成部件（形成中断服务程序的入口地址）</li>
</ul>
<p><strong>配置中断请求触发器和中断屏蔽触发器：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-c24a7e7bd53d7dfa4240dab976d1659c_720w.jpg" alt="img"></p>
<p><strong>排队器：</strong></p>
<p>排队器可以使用硬件电路来实现（在CPU内或接口电路中），也可以在软件中实现。</p>
<p>链式排队器，<strong>输出只有一位是高电平，其他都是低电平，高电平表示此时最高优先级的中断。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-ab622ca1a033ab52bc812bee17af7638_720w.jpg" alt="img"></p>
<p><strong>中断向量地址形成部件：</strong></p>
<p>找到中断服务程序的入口地址，同样可以使用软件或硬件方法（硬件向量法）。</p>
<p><strong>硬件向量法由硬件产生向量地址，再由向量地址找到入口地址。</strong></p>
<p>中断向量地址形成部件的<strong>输入为排队器的输出</strong>（只有一位是高电平，其他都是低电平），&#x3D;&#x3D;<strong>输出为该种中断的向量地址，再通过向量地址，找到该种中断的中断服务程序的入口地址。</strong>&#x3D;&#x3D;</p>
<p><img src="https://pic3.zhimg.com/80/v2-882c410475b3f0119b6ca28550ef0942_720w.jpg" alt="img"></p>
<h3 id="5-5-4-I-x2F-O中断处理过程"><a href="#5-5-4-I-x2F-O中断处理过程" class="headerlink" title="5.5.4 I&#x2F;O中断处理过程"></a>5.5.4 I&#x2F;O中断处理过程</h3><p><img src="https://pic2.zhimg.com/80/v2-6e0573d5842b488b3b4832ca6fb445d9_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-7d7ab148498ac3048a68e578f0fadf3d_720w.jpg" alt="img"></p>
<h3 id="5-5-5-中断服务程序流程"><a href="#5-5-5-中断服务程序流程" class="headerlink" title="5.5.5 中断服务程序流程"></a>5.5.5 中断服务程序流程</h3><p><img src="https://pic2.zhimg.com/80/v2-2d97e87947354b4eaa9dd08b23b70701_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f3f3d63c25f2077e0fc31053ce2c19f4_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c64231e9418cf7eb85a2ba6e2d7ec135_720w.jpg" alt="img"></p>
<h3 id="5-6-DMA（直接存储器访问）方式"><a href="#5-6-DMA（直接存储器访问）方式" class="headerlink" title="5.6 DMA（直接存储器访问）方式"></a>5.6 DMA（直接存储器访问）方式</h3><h3 id="5-6-1-DMA方式的特点"><a href="#5-6-1-DMA方式的特点" class="headerlink" title="5.6.1 DMA方式的特点"></a>5.6.1 DMA方式的特点</h3><p><img src="https://pic4.zhimg.com/80/v2-9227e4cde1f4b33b4f38d010019fad73_720w.jpg" alt="img"></p>
<p>程序中断方式必须使用CPU来作为缓冲（即使是主存和IO之间进行信息交换）。</p>
<p>DMA方式，不需要CPU作为缓冲。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f6741cf48a31210b6e257e0b9a9b84b1_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-2f1017e17df182ab9429359649b47a79_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-832462276ad36e49d68737e7dc30df55_720w.jpg" alt="img"></p>
<ul>
<li>这种方法的实用性不强。</li>
</ul>
<h3 id="5-6-2-DMA接口的功能和组成"><a href="#5-6-2-DMA接口的功能和组成" class="headerlink" title="5.6.2 DMA接口的功能和组成"></a>5.6.2 DMA接口的功能和组成</h3><p><img src="https://pic1.zhimg.com/80/v2-e848ed9bf4bb8e6ae13579260d54a240_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-32ddddbf1c7cb853cb6cb3fcb9ff032b_720w.jpg" alt="img"></p>
<ul>
<li>AR：地址寄存器，WC：计数器，对传输数据量计数。</li>
<li>BR：数据缓冲器，DAR：设备地址寄存器，供设备选择电路使用；对于硬盘等设备，可以保存扇区号等。</li>
<li>DMA控制逻辑：完成与设备之间的请求回答，与总线的请求回答。</li>
<li>中断机构：传输结束之后的后续处理。</li>
</ul>
<h3 id="5-6-3-DMA的工作过程"><a href="#5-6-3-DMA的工作过程" class="headerlink" title="5.6.3 DMA的工作过程"></a>5.6.3 DMA的工作过程</h3><p><strong>DMA的传送过程</strong>：<strong>预处理、数据传送、后处理。</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-742b30c0695d121fe5cb564d17b8736f_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-1a1e25ed9572b59ef4b628189823800e_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-54fc05c234015ac602e81a08fff0ae20_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-cc3a9d2c01fe5198070dcc7196ec725c_720w.jpg" alt="img"></p>
<p><strong>DMA接口与系统的连接方式：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-161ece29eeada9301c4280a7313e2795_720w.jpg" alt="img"></p>
<ul>
<li>多个DMA接口连在一起，共享一条请求线。各DMA同样有优先级顺序。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-b9b57b9ea08c8ba41c3934c190e477d6_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-38326dc785a0b2e2c4b395966cf8138c_720w.jpg" alt="img"></p>
<h3 id="5-6-4-DMA接口的类型"><a href="#5-6-4-DMA接口的类型" class="headerlink" title="5.6.4 DMA接口的类型"></a>5.6.4 DMA接口的类型</h3><p><img src="https://pic4.zhimg.com/80/v2-8e8b0eb2842291a42685d4ee48324b3f_720w.jpg" alt="img"></p>
<ul>
<li>一个接口连了多个设备，但是每次只能与一个设备使用。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-45250bc057df82c94407bceb1c3f409e_720w.jpg" alt="img"></p>
<ul>
<li>每个通道有多个子通道，子通道可以并行使用。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-250ecbfe831995cc07959343b504c23d_720w.jpg" alt="img"></p>
<h2 id="6-计算机的运算方法"><a href="#6-计算机的运算方法" class="headerlink" title="6. 计算机的运算方法"></a>6. 计算机的运算方法</h2><h3 id="6-1-无符号数和有符号数"><a href="#6-1-无符号数和有符号数" class="headerlink" title="6.1 无符号数和有符号数"></a>6.1 无符号数和有符号数</h3><h3 id="6-1-1-无符号数"><a href="#6-1-1-无符号数" class="headerlink" title="6.1.1 无符号数"></a>6.1.1 无符号数</h3><p>没有正负号的数据，<strong>寄存器的位数即为无符号数的表示范围。</strong></p>
<h3 id="6-1-2-有符号数"><a href="#6-1-2-有符号数" class="headerlink" title="6.1.2 有符号数"></a>6.1.2 有符号数</h3><p>分为符号部分和数值部分。</p>
<p>机器数<strong>保存符号、小数点位置以及数值</strong>。计算机中<strong>没有</strong>专门的硬件保存小数点，都是以约定的形式给出。</p>
<p><strong>原码表示法：</strong></p>
<p>整数：&#x3D;&#x3D;<strong>符号位+，+数值。符号位0为正，1为负。</strong>&#x3D;&#x3D;逗号将符号位和数值分隔开，数值其实是数的绝对值。</p>
<p>小数：&#x3D;&#x3D;<strong>符号位+.+小数部分，符号位0为正，1为负。</strong>&#x3D;&#x3D;小数点将符号位和小数部分分隔开。</p>
<p><strong>上面的逗号和小数点，都不需要在计算机中存储，这里是方便人来阅读。</strong></p>
<p>使用原码进行加法的时候，结果的符号可正可负，希望找到一个与负数等价的正数来替代这个负数，这样就可以使得减法变成加法，即补码表示法。</p>
<p><strong>补码表示法：</strong></p>
<p>整数：<strong>正数的补码与原码一致，负数的补码为它的原码，除符号位以外，各位取反，最后加1。</strong></p>
<p>小数：<strong>正数的补码与原码一致，负数的补码为它的原码，除符号位以外，各位取反，最后加1。</strong></p>
<p><strong>反码表示法：</strong></p>
<p>正数的反码就是原码，负数的反码，将原码除符号位外，所有位取反。</p>
<p><img src="https://pic3.zhimg.com/80/v2-d897d8301ade757735da507c16e5cc5e_720w.jpg" alt="img"></p>
<p><strong>移码表示法（只有整数形式定义）：</strong></p>
<p>补码很难直接判断其真值大小。</p>
<p><img src="https://pic3.zhimg.com/80/v2-6a3cdf6050e60506e92dd16a157e2b6e_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-2d9837b1a6bedaf32be3f0fb589de95a_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-394d544564c5217eee08b41b26e4f029_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ed12f9fda7ee5912620a894f5a2193e1_720w.jpg" alt="img"></p>
<h3 id="6-2-数的定点表示和浮点表示"><a href="#6-2-数的定点表示和浮点表示" class="headerlink" title="6.2 数的定点表示和浮点表示"></a>6.2 数的定点表示和浮点表示</h3><h3 id="6-2-1-定点表示"><a href="#6-2-1-定点表示" class="headerlink" title="6.2.1 定点表示"></a>6.2.1 定点表示</h3><p>小数点按照约定方式标出，没有硬件完成小数点，根据设计人员的约定来进行表示。</p>
<p>小数点可放在数符和数值之间（小数定点机），或数值之后（整数定点机）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-6e8acba8b8fc1dded67e97f753ec5977_720w.jpg" alt="img"></p>
<h3 id="6-2-2-浮点表示"><a href="#6-2-2-浮点表示" class="headerlink" title="6.2.2 浮点表示"></a>6.2.2 浮点表示</h3><p>定点表示的数，表示范围小，为了表示两个大小相差很大的数据，需要很长的机器字长。数据存储单元的利用率很低。</p>
<p>浮点数的一般形式 $$ N &#x3D; S×r^j $$ S为尾数，j为阶码，r为尾数的基值，计算机中r通常取2,4,8,16。<strong>在计算机中，S为小数，可正可负；j为整数，可正可负。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-2009b694f8408aa43ffad17e1cc32506_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-ec6810b1fcde4b5b448e56e5c7fd1394_720w.jpg" alt="img"></p>
<p>对浮点数进行规格化，是为了尽可能保证数据的精度，让有效的位数尽可能多。</p>
<p><img src="https://pic3.zhimg.com/80/v2-14d223a976be94b4544f5c9194fcce7e_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-6bc74400fdf3408fc608f1abe72d9ead_720w.jpg" alt="img"></p>
<h3 id="6-3-定点运算"><a href="#6-3-定点运算" class="headerlink" title="6.3 定点运算"></a>6.3 定点运算</h3><h3 id="6-3-1-移位运算"><a href="#6-3-1-移位运算" class="headerlink" title="6.3.1 移位运算"></a>6.3.1 移位运算</h3><p>数据相对于小数点进行左移&#x2F;右移（小数点不动）。左移，绝对值扩大，右移，绝对值缩小。移位与加减法配合，能够实现乘除法运算。</p>
<p><img src="https://pic3.zhimg.com/80/v2-99ed7169acfb00d5d23a71ef346ee12a_720w.jpg" alt="img"></p>
<ul>
<li>注意，&#x3D;&#x3D;符号位保持不变&#x3D;&#x3D;。</li>
</ul>
<p><strong>算数移位的硬件实现：</strong></p>
<p>即，左移，最高位扔掉，其他位左移，末尾补0&#x2F;1。</p>
<p>右移，最低位扔掉，其他位右移，高位补0&#x2F;1。</p>
<p><img src="https://pic1.zhimg.com/80/v2-653e755f9801caab4583a36a8cbda674_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-cd77d50aaada2fb7146cbd52dd0a86b5_720w.jpg" alt="img"></p>
<h3 id="6-3-2-加减法运算"><a href="#6-3-2-加减法运算" class="headerlink" title="6.3.2 加减法运算"></a>6.3.2 加减法运算</h3><p>主要是使用补码进行加减法运算，因为可以将减法变为加法。</p>
<p><img src="https://pic3.zhimg.com/80/v2-e65743521c23abe2e32f8ee8393a25a2_720w.jpg" alt="img"></p>
<p>还需要判断处理溢出。</p>
<p><img src="https://pic1.zhimg.com/80/v2-33b395859242666145fd1b1c5b1776b0_720w.jpg" alt="img"></p>
<p><strong>两个同符号的数，数值运算产生了进位，进位到了符号位，改变了符号位，则就出现了溢出。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-9d5763771e2521ef64139e69067539a0_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-0467e3da10cb7cd7d759085ed9d5416c_720w.jpg" alt="img"></p>
<p>核心是n+1位加法器，两个寄存器保存参与计算的数据。  </p>
<h3 id="6-3-3-乘法运算"><a href="#6-3-3-乘法运算" class="headerlink" title="6.3.3 乘法运算"></a>6.3.3 乘法运算</h3><p>模拟笔算乘法的过程，符号位进行单独处理（异或电路），可以将乘数放到移位寄存器中。</p>
<p><img src="https://pic4.zhimg.com/80/v2-22a4364f5174c4d7d78c48d996089be3_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-2d665149b1a2f1f24edb23c4ef0daa57_720w.jpg" alt="img"></p>
<ul>
<li>n是参加运算的数的数值部分长度。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-2d74e4b2493b2bf1a6460478cc49fb29_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9a6df8722fd24f77d5679af7c1079364_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-4bf21278b48c18784327f09da3c47165_720w.jpg" alt="img"></p>
<h3 id="6-3-4-除法运算"><a href="#6-3-4-除法运算" class="headerlink" title="6.3.4 除法运算"></a>6.3.4 除法运算</h3><p>二进制的除法比十进制简单得多，商只会上0&#x2F;1。</p>
<p><img src="https://pic4.zhimg.com/80/v2-8621ac43a4e2b546e48fed304433010b_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-7a5e8396ed8594c5f5002c25f015f2bd_720w.jpg" alt="img"></p>
<ul>
<li>小数除法，小数都是小于1的，因此默认被除数小于除数，这样结果还是小于1的。</li>
</ul>
<p>恢复余数法：余数为正，上商1；余数为负，上商0，恢复余数。</p>
<p>不恢复余数法（加减交替法）</p>
<p><img src="https://pic3.zhimg.com/80/v2-111286030a80c2c5d3cf0569934d52be_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-6e6b4b38431bbb932c680ea7ae1a3f66_720w.jpg" alt="img"></p>
<h3 id="6-4-浮点四则运算"><a href="#6-4-浮点四则运算" class="headerlink" title="6.4 浮点四则运算"></a>6.4 浮点四则运算</h3><p>浮点数的加减运算：</p>
<p><img src="https://pic2.zhimg.com/80/v2-35da1e201bf44b2d582f91694d84e905_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-d421ec2c547508394693892c9839ea02_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-bc1bffdde6824ccc16625e8b5866fb15_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-616d0f28ff6f144b64461d550df77240_720w.jpg" alt="img"></p>
<h3 id="6-5-算术逻辑单元（ALU）"><a href="#6-5-算术逻辑单元（ALU）" class="headerlink" title="6.5 算术逻辑单元（ALU）"></a>6.5 算术逻辑单元（ALU）</h3><h3 id="6-5-1-ALU电路"><a href="#6-5-1-ALU电路" class="headerlink" title="6.5.1 ALU电路"></a>6.5.1 ALU电路</h3><p><img src="https://pic4.zhimg.com/80/v2-0bad4e319a1da81cc6a670bfdb479903_720w.jpg" alt="img"></p>
<p>Ai和Bi两个输入，进行计算的两个数值，F为输出结果，K控制进行什么计算。</p>
<h3 id="6-5-2-快速进位链"><a href="#6-5-2-快速进位链" class="headerlink" title="6.5.2 快速进位链"></a>6.5.2 快速进位链</h3><p><img src="https://pic4.zhimg.com/80/v2-ce99c34604d325ca6e0ac2ab24f81a1b_720w.jpg" alt="img"></p>
<ul>
<li>C为进位，需要等低位的计算完之后，才能进行这一位的计算，因此需要更快的进位。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-b88b52250375a02d1753fba8a94700b5_720w.jpg" alt="img"></p>
<ul>
<li>进位链是影响加法速度的瓶颈</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-8346609c9d5f78ac5f05b0bf8b041f87_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-cec52432cf0f836a068aa8613ca01b54_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4e16fbfa2525a9e894876b0a8bb5ec07_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-8f5d21ebfa2b0f3c83045122ccfa4828_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-7ac74dc29c0ecbb5871fe7a90cd741b7_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-30b1db9095be53de9df3a66f1f11271c_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-b4dbabc10878c88e8be6b5e84aa4c3f5_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-c67441181c3e0442c0966d8315862aa7_720w.jpg" alt="img"></p>
<h2 id="7-指令系统"><a href="#7-指令系统" class="headerlink" title="7. 指令系统"></a>7. 指令系统</h2><p>指令系统是计算机软硬件的交汇面。</p>
<h3 id="7-1-机器指令"><a href="#7-1-机器指令" class="headerlink" title="7.1 机器指令"></a>7.1 机器指令</h3><h3 id="7-1-1-指令的一般格式"><a href="#7-1-1-指令的一般格式" class="headerlink" title="7.1.1 指令的一般格式"></a>7.1.1 指令的一般格式</h3><p><img src="https://pic1.zhimg.com/80/v2-98a6b474fc548fba56b432a5389d10a0_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-1a356f0b44baf334e727b419899d927d_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-1350227e0717ed0bef5146fa366b56db_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-8fd5bc6e4948cec19da7b918cc9eedef_720w.jpg" alt="img"></p>
<h3 id="7-1-2-指令字长"><a href="#7-1-2-指令字长" class="headerlink" title="7.1.2 指令字长"></a>7.1.2 指令字长</h3><p>指令的字长取决于：操作码的长度，操作数地址的长度，操作数地址的个数。</p>
<p>指令字长可以是固定的（指令字长&#x3D;存储字长），也可以是可变的，按照字节的倍数进行变化。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3dd663a9f1cd87d5a5bf0855dc1310a2_720w.jpg" alt="img"></p>
<h3 id="7-2-操作数类型和操作种类"><a href="#7-2-操作数类型和操作种类" class="headerlink" title="7.2 操作数类型和操作种类"></a>7.2 操作数类型和操作种类</h3><h3 id="7-2-1-操作数类型"><a href="#7-2-1-操作数类型" class="headerlink" title="7.2.1 操作数类型"></a>7.2.1 操作数类型</h3><ul>
<li>地址：无符号整数（绝对地址），有符号数（相对地址）</li>
<li>数字：定点数、浮点数、十进制数</li>
<li>字符：ASCII</li>
<li>逻辑数：逻辑运算</li>
</ul>
<h3 id="7-2-2-数据在存储器中的存放方式"><a href="#7-2-2-数据在存储器中的存放方式" class="headerlink" title="7.2.2 数据在存储器中的存放方式"></a>7.2.2 数据在存储器中的存放方式</h3><p><img src="https://pic3.zhimg.com/80/v2-c8b0cf805c761ac8cfd3a49e5bd82d92_720w.jpg" alt="img"></p>
<p>字节编址：</p>
<p><img src="https://pic3.zhimg.com/80/v2-258c0ae86a0cf5dced8ff61f21ebcace_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-911639d4ea60b7941bf4ff489bae0479_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-79758c0730be6c72e2448c820211e89e_720w.jpg" alt="img"></p>
<h3 id="7-2-3-操作类型"><a href="#7-2-3-操作类型" class="headerlink" title="7.2.3 操作类型"></a>7.2.3 操作类型</h3><p><img src="https://pic3.zhimg.com/80/v2-e80d2179db474bd214ab55d85b6081aa_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-60331452311ef076ab8f69b884c199d3_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-62ca2b1d52b8951bf9d334c65737be64_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-3b36fb82b72d8e520b6d826dc1f46ad9_720w.jpg" alt="img"></p>
<h3 id="7-3-寻址方式"><a href="#7-3-寻址方式" class="headerlink" title="7.3 寻址方式"></a>7.3 寻址方式</h3><p>确定本条指令的操作数地址，或下一条指令的指令地址。</p>
<p>可分为指令的寻址和数据寻址</p>
<h3 id="7-3-1-指令寻址"><a href="#7-3-1-指令寻址" class="headerlink" title="7.3.1 指令寻址"></a>7.3.1 指令寻址</h3><p>顺序寻址&#x2F;跳跃寻址。</p>
<p>pc程序计数器。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c0c57fba32931971dfa3acc8c60fbbb5_720w.jpg" alt="img"></p>
<h3 id="7-3-2-数据寻址"><a href="#7-3-2-数据寻址" class="headerlink" title="7.3.2 数据寻址"></a>7.3.2 数据寻址</h3><p><img src="https://pic3.zhimg.com/80/v2-54356fae3d68588119f0215e70b3306e_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-57878ba3ec2d0e02530ee8b41a8c2bd7_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-dea762b7cbe150b8d1a291c10e788a69_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-fe04753ed352f51476c52422044327f4_720w.jpg" alt="img"></p>
<ul>
<li>操作数的有效地址保存在另一个位置，再去这个位置找到有效地址EA，访存两次。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-9cf702816cd97ee18002f54bbc658ff2_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-fc3d5c688eeac38569482de915cac3aa_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-cdcaae570fc9396a3e379c3cb1866ba8_720w.jpg" alt="img"></p>
<ul>
<li>BR是基址，A相当于偏移量，形式地址。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-82486c9a347dcb7f4c7d4fc5c5a90169_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4445ed987460133a438626a3b6ecd4be_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-6ea74f28c9b588e400dc13e75f97f349_720w.jpg" alt="img"></p>
<ul>
<li>相对于当前PC值。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-495c7c8224b8abb4eab61310bcde6d44_720w.jpg" alt="img"></p>
<h3 id="7-4-指令格式举例"><a href="#7-4-指令格式举例" class="headerlink" title="7.4 指令格式举例"></a>7.4 指令格式举例</h3><p><img src="https://pic3.zhimg.com/80/v2-7f557e8b2a25dafbeec9ccef53a9de02_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-352cd052c7d2762782e62da5affa44c4_720w.jpg" alt="img"></p>
<h3 id="7-5-RISC（精简指令集计算机）技术"><a href="#7-5-RISC（精简指令集计算机）技术" class="headerlink" title="7.5 RISC（精简指令集计算机）技术"></a>7.5 RISC（精简指令集计算机）技术</h3><p><img src="https://pic1.zhimg.com/80/v2-4a2e7799e675ef547d04a89bf7504ac8_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-5b0294e195a58d9df758b0db7bd35451_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-cbb90ab791b3c9c93805cd2317238377_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c1a931e604616c339419883553d2e0f9_720w.jpg" alt="img"></p>
<h2 id="8-CPU的结构与功能"><a href="#8-CPU的结构与功能" class="headerlink" title="8. CPU的结构与功能"></a>8. CPU的结构与功能</h2><h3 id="8-1-CPU的结构"><a href="#8-1-CPU的结构" class="headerlink" title="8.1 CPU的结构"></a>8.1 CPU的结构</h3><h3 id="8-1-1-CPU的功能"><a href="#8-1-1-CPU的功能" class="headerlink" title="8.1.1 CPU的功能"></a>8.1.1 CPU的功能</h3><p><img src="https://pic4.zhimg.com/80/v2-c8d59c52ce03b8660c9e5294f610645b_720w.jpg" alt="img"></p>
<h3 id="8-1-2-CPU结构框图"><a href="#8-1-2-CPU结构框图" class="headerlink" title="8.1.2 CPU结构框图"></a>8.1.2 CPU结构框图</h3><p><img src="https://pic2.zhimg.com/80/v2-73181cfcc27e2207c1f8f222d8b67375_720w.jpg" alt="img"></p>
<ul>
<li>IR指令寄存器，PC程序计数器</li>
</ul>
<h3 id="8-1-3-CPU的寄存器"><a href="#8-1-3-CPU的寄存器" class="headerlink" title="8.1.3 CPU的寄存器"></a>8.1.3 CPU的寄存器</h3><p><img src="https://pic3.zhimg.com/80/v2-95cb86b429d0859197376e68df522c8e_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f74c63b293116496b2bfc879cc9ae9b8_720w.jpg" alt="img"></p>
<h3 id="8-1-4-其他"><a href="#8-1-4-其他" class="headerlink" title="8.1.4 其他"></a>8.1.4 其他</h3><p>其他部分还包括CU（控制单元）、中断系统以及ALU。</p>
<p><strong>CU产生全部指令执行的时候的微操作命令序列，可使用组合逻辑设计或微程序设计。</strong></p>
<h3 id="8-2-指令周期"><a href="#8-2-指令周期" class="headerlink" title="8.2 指令周期"></a>8.2 指令周期</h3><h3 id="8-2-1-基本概念"><a href="#8-2-1-基本概念" class="headerlink" title="8.2.1 基本概念"></a>8.2.1 基本概念</h3><p><img src="https://pic1.zhimg.com/80/v2-b7d7e0c28a00121c7e79aaa71b931568_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-69f06b5dae753a813d73c9d73afb1667_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4e068b10aded51c176b0f53166c95ac3_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d632bdba372b27770d4f6954f95ddac1_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9dd83563b97ad61a54969dace6e91ca0_720w.jpg" alt="img"></p>
<h3 id="8-2-2-指令周期的数据流"><a href="#8-2-2-指令周期的数据流" class="headerlink" title="8.2.2 指令周期的数据流"></a>8.2.2 指令周期的数据流</h3><p><img src="https://pic1.zhimg.com/80/v2-16bc0563fc33b007f63f2d9e63426f68_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-ffe1f1639490e88d147dca09c4c2de47_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-33dbaa90facba4a2495551882c24f90f_720w.jpg" alt="img"></p>
<h3 id="8-3-指令流水"><a href="#8-3-指令流水" class="headerlink" title="8.3 指令流水"></a>8.3 指令流水</h3><p><img src="https://pic2.zhimg.com/80/v2-9c16393a72d6dec738963ea01109597d_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-949473d8f05b3a4d70456e9d50928e99_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-2f10fa304075e6bc122a6e389b4b0684_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-cd39fea3beccf163fd0d6def48a60201_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ad13acd1809dd1fad491f9714442f599_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-becee89f33a1e5ea3df31f3b9092e7ba_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5ffd433f519357b941ad2d4210c62d33_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-893f271bc6c0a6feae3ea44895ce9f17_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-4c4c40a9d617570797b2f88cd8e8b525_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-bf6629730222b07b5e76f581d72526ec_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-8af1daee44b1b31895f74c3a6153d196_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-1748e609006890cae417637268e3dc98_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-a1973374365a3c82bca9e67894cdfda3_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-594cc4e23c8d23c851371b284ad6bc09_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5d76326753b746899842a3ad471b5dec_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-086cb08b406587df59d147ad04ceca37_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-eb8c96a902a9ba0b4dc2909dc98b3dca_720w.jpg" alt="img"></p>
<h3 id="8-4-中断系统"><a href="#8-4-中断系统" class="headerlink" title="8.4 中断系统"></a>8.4 中断系统</h3><h3 id="8-4-1-概述"><a href="#8-4-1-概述" class="headerlink" title="8.4.1 概述"></a>8.4.1 概述</h3><p><img src="https://pic1.zhimg.com/80/v2-80d57c2b31ef27adc9ab7c679be9b0d8_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-250f0412c444ce2f9a891190dc20c3ec_720w.jpg" alt="img"></p>
<h3 id="8-4-2-中断请求标记和中断判优逻辑"><a href="#8-4-2-中断请求标记和中断判优逻辑" class="headerlink" title="8.4.2 中断请求标记和中断判优逻辑"></a>8.4.2 中断请求标记和中断判优逻辑</h3><p><img src="https://pic2.zhimg.com/80/v2-182ff5dc96c0788a2631a09787962ae9_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-9979d4fc77823677663af765135194de_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-d997cb8203c7b804b8515e26dba50ef2_720w.jpg" alt="img"></p>
<h3 id="8-4-3-中断服务程序入口地址查询"><a href="#8-4-3-中断服务程序入口地址查询" class="headerlink" title="8.4.3 中断服务程序入口地址查询"></a>8.4.3 中断服务程序入口地址查询</h3><p><img src="https://pic1.zhimg.com/80/v2-7e2503776d875f089d09543062b8608c_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-68e36f17805e16ac5e2e127e6344fa05_720w.jpg" alt="img"></p>
<h3 id="8-4-4-中断响应"><a href="#8-4-4-中断响应" class="headerlink" title="8.4.4 中断响应"></a>8.4.4 中断响应</h3><p><img src="https://pic2.zhimg.com/80/v2-cfab9df5aba6657f37b912518a762a11_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-63c5a6c2a3765c312d85c4a48cb57b53_720w.jpg" alt="img"></p>
<ul>
<li><p>中断隐指令不是实际的指令，而是硬件直接实现的。</p>
</li>
<li><h3 id="8-4-5-保护现场和恢复现场"><a href="#8-4-5-保护现场和恢复现场" class="headerlink" title="8.4.5 保护现场和恢复现场"></a>8.4.5 保护现场和恢复现场</h3><p><img src="https://pic3.zhimg.com/80/v2-c0e5720e9e3654d4fa42bd2fbdb9c43e_720w.jpg" alt="img"></p>
<h3 id="8-4-6-多重中断"><a href="#8-4-6-多重中断" class="headerlink" title="8.4.6 多重中断"></a>8.4.6 多重中断</h3><p><img src="https://pic3.zhimg.com/80/v2-882d0f7425bfc56051ccd580d83a3cde_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-68f647f033e41b0cf03994ba1841b91b_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e0e4e703ba8ef0593e12564e45f67334_720w.jpg" alt="img"></p>
<ul>
<li>通过屏蔽触发器，设置中断屏蔽字，来调整中断的优先级（中断处理的优先级。不是响应的优先级）。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b3cc033a886f5ec6bbf5cd4a7f964404_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-4bc3e67c760a0096729e35c1178c30ad_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-2030b13c2f5eae15eb67b615b41e4fc1_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-10fe213183c5b3f71d10eb25d793dbd7_720w.jpg" alt="img"></p>
<h2 id="9-控制单元的功能"><a href="#9-控制单元的功能" class="headerlink" title="9. 控制单元的功能"></a>9. 控制单元的功能</h2><h3 id="9-1-微操作命令的分析"><a href="#9-1-微操作命令的分析" class="headerlink" title="9.1 微操作命令的分析"></a>9.1 微操作命令的分析</h3><p>完成一条指令分为四个周期：<strong>取指周期、间址周期、执行周期、中断周期。</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-cbb164e1850bc8f37d5498ec2fe0afcf_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-75272039372621007a4554e02dbfb467_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4c6567a97b236e05174123a140221ee6_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b772034c369be1600ba3080f27fadaa3_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-c4faa85fec57c43725466face1829180_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-31cb07c191bcdc5cd668166c4787ad61_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e3f0d0f1ec7a9c3563c31f2a22df2363_720w.jpg" alt="img"></p>
<h3 id="9-2-控制单元的功能"><a href="#9-2-控制单元的功能" class="headerlink" title="9.2 控制单元的功能"></a>9.2 控制单元的功能</h3><p>发出各种控制命令和微指令。</p>
<p><img src="https://pic2.zhimg.com/80/v2-92f9d2ca8721bc62a10c859dcb0da399_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-90bb51feab78c7390e4e01cf30f1866f_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-36c2c4aacffc7e7c43f97164b447ebae_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-7c7fbfdf28804adfee9b7f01efe9c64b_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f1a6d5d012376115300119419afd15d0_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-dfb799edfaf102f4e8973f368c00fc99_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-f13c6d91223963c75cf74d9ba2093ce2_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-945eea3400501415e948088622558fce_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-de7ff8a76adac22577d542cac866c1ae_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-05b22c2344be072bf7ccf6e0bfe658e1_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-6ba1fd7fd49c2dd0d560ecf29cbe84ab_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-46c0e6e495df3496358098356e89437a_720w.jpg" alt="img"></p>
<h2 id="10-控制单元的设计"><a href="#10-控制单元的设计" class="headerlink" title="10. 控制单元的设计"></a>10. 控制单元的设计</h2><h3 id="10-1-组合逻辑设计"><a href="#10-1-组合逻辑设计" class="headerlink" title="10.1 组合逻辑设计"></a>10.1 组合逻辑设计</h3><p><img src="https://pic3.zhimg.com/80/v2-afcdb84d70aba264c94c8bfff7b4d8da_720w.jpg" alt="img"></p>
<ul>
<li><strong>操作码译码只有一条有效，为高电平，对应操作为什么，CU给出对应的一个或几个操作控制信号。</strong>如果是几个都有效，说明这个节拍下，这几个可以并行处理。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-c73a54ec82d4bf5866530b173091ad71_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-0050f5c44453167baf1ee347b30f6208_720w.jpg" alt="img"></p>
<ul>
<li>蓝色的C为控制信号，都是由CU在时钟和IR操作码的控制下，在相应节拍给出的。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-bc2e80321efaf02d3d707a038fd60000_720w.jpg" alt="img"></p>
<ul>
<li>可以并行的微操作，尽可能安排在同一个节拍内。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-f11dd68c4e3c8245d4b0962e7d7a3c8a_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b816d2c4fed11a5f8094e111ef0eb7e3_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-3ce870f40742455d23b1be36d0cf62f2_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-307d20fe27c73c90c3650c5838cd2bcf_720w.jpg" alt="img"></p>
<ul>
<li>1.累加器清零</li>
<li>2.ACC按位取反</li>
<li>3.算术右移操作</li>
<li>4.循环左移操作</li>
<li>5.停机指令</li>
<li>6.加法操作，T0，取操作数，将指令地址码送入MAR，同时读信号；T1，内存中的数据送入MDR；T2，累加器中内容和MDR中数据相加，放在累加器中。</li>
<li>7.将累加器中保存的数据，送到地址为X内存中。</li>
<li>8.load，把内存地址为x的内存中数据，取到累加器中。</li>
<li>9.跳转到给定的地址X</li>
<li>10.分支指令，条件转移，如果上条计算指令结果小于0，则跳到X处</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-cbc0a0637644cd09325e9218cbf719e3_720w.jpg" alt="img"></p>
<p>组合逻辑设计步骤：</p>
<ul>
<li>列出操作的时间表</li>
<li>写出微操作命令的最简表达式</li>
<li>画出逻辑图</li>
</ul>
<h3 id="10-2-微程序设计"><a href="#10-2-微程序设计" class="headerlink" title="10.2 微程序设计"></a>10.2 微程序设计</h3><p>采用微程序设计的方法来实现控制器。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ff433902ea666675f621610151ccb174_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-82a7909d71ee6e6e656768e183efec1f_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-63c59321455516bf050b876d2280f06f_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-cdc52466c06d7ec139de56e63edccc4d_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-288ca719664f9942395818a51f69fc2a_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-d20d3629effd03eacb4fb371d008a947_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-6abed604804893e2835d9d0813fbec01_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5b6419bf237035ed8350f2bee32305d8_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-ae6becb1050d9bf3f42e50ccb23e6424_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f5a0e27e24c66cf765ecc9fb4bf3dad8_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8ec25c5c29ff19fdc37255a43fd558e1_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0266561975bc190b465bf9f75139517a_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-4d988f79331211ea72422a3d7221f824_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-65dabbe80ada4860c1fc99af68e4cd5d_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e7c9426dd54938c3392ee7c9f409f81e_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d5fe8ab2aed1d9db05889bac4f66835d_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-93a53006aae7efca0a3fc3ac78f1b914_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-70c1a78b8f90710483eb238e06d95840_720w.jpg" alt="img"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Operating System</title>
    <url>/2022/04/12/Operating-System/</url>
    <content><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote>
<p>第一章的主要内容是 : 操作系统的一些知识</p>
</blockquote>
<h3 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h3><p>用户角度：操作系统是一个控制软件</p>
<ul>
<li>管理应用程序</li>
<li>为应用程序提供服务</li>
<li>杀死应用程序</li>
<li><span id="more"></span></li>
</ul>
<p>程序角度：操作系统是资源管理器</p>
<ul>
<li>管理外设、分配资源</li>
<li>抽象<ul>
<li>将CPU抽象成进程</li>
<li>将磁盘抽象成文件</li>
<li>将内存抽象成地址空间</li>
</ul>
</li>
</ul>
<h3 id="操作系统层次"><a href="#操作系统层次" class="headerlink" title="操作系统层次"></a>操作系统层次</h3><p>位于硬件之上，应用程序之下。</p>
<h3 id="操作系统的界面和内核"><a href="#操作系统的界面和内核" class="headerlink" title="操作系统的界面和内核"></a>操作系统的界面和内核</h3><p>Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。</p>
<h3 id="操作系统内部组件"><a href="#操作系统内部组件" class="headerlink" title="操作系统内部组件"></a>操作系统内部组件</h3><ul>
<li>CPU调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与设备驱动</li>
</ul>
<h3 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h3><ul>
<li>并发<ul>
<li>一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU)</li>
<li>需要OS管理和调度</li>
</ul>
</li>
<li>共享<ul>
<li>“同时”共享</li>
<li>互斥共享</li>
</ul>
</li>
<li>虚拟<ul>
<li>让每一个用户觉得的有一个计算机专门为他服务</li>
</ul>
</li>
<li>异步<ul>
<li>程序是走走停停，而不是一直运行</li>
</ul>
</li>
</ul>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><blockquote>
<p>第二章的主要内容是 : 操作系统的异常&#x2F;中断&#x2F;系统调用</p>
</blockquote>
<h2 id="探究计算机启动过程"><a href="#探究计算机启动过程" class="headerlink" title="探究计算机启动过程"></a>探究计算机启动过程</h2><p><strong>作用解析</strong></p>
<p>Disk : 存放OS和Bootloader</p>
<p>BOIS : 基于I&#x2F;O处理系统</p>
<p>Bootloader : 加载OS，将OS放入内存</p>
<p><strong>结构</strong></p>
<p>Disk</p>
<p>|___ OS</p>
<p>|___ Bootloader</p>
<p><strong>开机流程</strong></p>
<ol>
<li>BIOS<ul>
<li>开机后，寻找显卡和执行BIOS (此时, <code>CS : IP = 0xF000 : 0xFFF0</code>, CS&#x2F;IP 两个寄存器)</li>
<li>将Bootloader从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512M字节的内存)</li>
<li>跳转到 <code>CS : IP = 0x0000 : 0x7C00</code></li>
</ul>
</li>
<li>Bootloader<ul>
<li>将操作系统的代码和数据从硬盘加载到内存中</li>
<li>跳转到操作系统的起始地址</li>
</ul>
</li>
</ol>
<h2 id="中断、异常、系统调用"><a href="#中断、异常、系统调用" class="headerlink" title="中断、异常、系统调用"></a>中断、异常、系统调用</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断来源于外设，来自不同的硬件设备的计时器和网络的中断。</p>
<p><strong>中断流程</strong></p>
<p>硬件：设置中断标记（CPU初始化）</p>
<ol>
<li>将内部、外部事件设置中断标记</li>
<li>中断事件的ID</li>
</ol>
<p>软件</p>
<ol>
<li>保存当前处理状态（寄存器之类的一些数据）</li>
<li>根据中断事件的ID跳转到中断服务程序，中断服务程序处理</li>
<li>清楚中断标记</li>
</ol>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。</p>
<p><strong>异常处理流程</strong></p>
<ol>
<li>保存现场</li>
<li>异常处理<ol>
<li>杀死了产生异常的程序</li>
<li>重新执行异常指令</li>
</ol>
</li>
<li>恢复现场</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用来源于应用程序，应用程序主动向操作系统发出服务请求。程序访问主要是通过高层次的API，而不是直接调用系统调用函数。</p>
<p><strong>APIs</strong></p>
<ul>
<li>Win32 API 用于Windows</li>
<li>POSIX API 用于 POSIX-based systems（包括UNIX，LINUX，Mac OS X）</li>
<li>Java API 用于JAVA虚拟机</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>通常情况下，每个系统调用有对应的序号<ul>
<li>系统调用接口根据这些序号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中预期的系统调用<ul>
<li>并返回系统调用的状态和其他任何返回值</li>
</ul>
</li>
<li>用户不需要知道系统调用是如何实现的<ul>
<li>只需要获取API和了解操作系统将什么作为返回结果</li>
<li>操作系统接口的细节大部分都隐藏在API中</li>
</ul>
</li>
</ul>
<p><strong>用户态</strong>：操作系统运行中，CPU处于的特权级别，不能直接执行特权指令</p>
<p><strong>内核态</strong>：操作系统运行中，CPU处于的特权级别，可以执行任何一条指令</p>
<p><strong>系统调用</strong>：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销</p>
<p><strong>跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性）</strong></p>
<ul>
<li>在执行时间上的开销超过程序调用</li>
<li>开销：<ul>
<li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈</li>
<li>验证参数</li>
<li>内核态映射到用户态的地址空间（更新页面映射权限）</li>
<li>内核态独立地址空间（TLB）</li>
</ul>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th>类型</th>
<th>源头</th>
<th>处理时间</th>
<th>响应</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对应用程序透明</td>
</tr>
<tr>
<td>异常</td>
<td>应用程序意向不到的行为</td>
<td>同步</td>
<td>杀死或重新执行指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序请求系统提供服务</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody></table>
<blockquote>
<p>异步：应用程序不知道什么时候会发生中断</p>
</blockquote>
<blockquote>
<p>同步：执行到某一条指令一定会发生该事件</p>
</blockquote>
<h3 id="为什么应用程序不能直接访问硬件？"><a href="#为什么应用程序不能直接访问硬件？" class="headerlink" title="为什么应用程序不能直接访问硬件？"></a>为什么应用程序不能直接访问硬件？</h3><ul>
<li>在计算机运行时，内核是被信任的第三方</li>
<li>只有内核可以执行特权指令</li>
<li>为了方便应用程序</li>
</ul>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><blockquote>
<p>第三章的主要内容是 : 操作系统的物理内存管理</p>
</blockquote>
<h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><ol>
<li>CPU</li>
<li>内存</li>
<li>I&#x2F;O</li>
</ol>
<h2 id="内存分层体系"><a href="#内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h2><h3 id="内存分层体系-1"><a href="#内存分层体系-1" class="headerlink" title="内存分层体系"></a>内存分层体系</h3><p>运行内存(主存) &#x2F; 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.</p>
<p>CPU可以访问的内存包括两大类 : 寄存器 &#x2F; cache(L1缓存 &#x2F; L2缓存)</p>
<p><strong>层次</strong></p>
<p>微处理器(CPU访问)</p>
<p>|___CPU寄存器 &#x2F; L1缓存</p>
<p>|___L2缓存</p>
<p>主存(程序访问)</p>
<p>磁盘(程序访问)</p>
<blockquote>
<p>从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。</p>
</blockquote>
<h3 id="内存管理目标"><a href="#内存管理目标" class="headerlink" title="内存管理目标"></a>内存管理目标</h3><ul>
<li>抽象：逻辑地址空间</li>
<li>保护：独立地址空间</li>
<li>共享：访问相同内存</li>
<li>虚拟：更多的地址空间</li>
</ul>
<h3 id="内存管理方法"><a href="#内存管理方法" class="headerlink" title="内存管理方法"></a>内存管理方法</h3><ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
<blockquote>
<p>实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求</p>
</blockquote>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>地址空间的定义</p>
<ul>
<li>物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] )</li>
<li>逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )</li>
</ul>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p>内存碎片问题指的是空闲的内存无法被利用</p>
<ul>
<li>外部碎片 : 分配单元间的未使用内存</li>
<li>内部碎片 : 分配单元内的未使用内存</li>
</ul>
<h3 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h3><p>分区的动态分配方式有以下三种 :</p>
<ol>
<li>第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序</li>
<li>最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序</li>
<li>最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序</li>
</ol>
<p>分配方式的区别</p>
<table>
<thead>
<tr>
<th>分配方式</th>
<th>第一匹配分配</th>
<th>最优适配分配</th>
<th>最差适配分配</th>
</tr>
</thead>
<tbody><tr>
<td>分配方式实现需求</td>
<td>1. 按地址排序的空闲块列表 2. 分配需要寻找一个合适的分区 3. 重分配需要检查是否可以合并相邻空闲分区</td>
<td>1. 按尺寸排序的空闲块列表 2. 分配需要寻找一个合适的分区 3. 重分配需要检查是否可以合并相邻空闲分区</td>
<td>1. 按尺寸排序的空闲块列表 2. 分配最大的分区 3. 重分配需要检查是否可以合并相邻空闲分区</td>
</tr>
<tr>
<td>优势</td>
<td>简单 &#x2F; 易于产生更大空闲块</td>
<td>比较简单 &#x2F; 大部分分配是小尺寸时高效</td>
<td>分配很快 &#x2F; 大部分分配是中尺寸时高效</td>
</tr>
<tr>
<td>劣势</td>
<td>产生外部碎片 &#x2F; 不确定性</td>
<td>产生外部碎片 &#x2F; 重分配慢 &#x2F; 产生很多没用的微小碎片</td>
<td>产生外部碎片 &#x2F; 重分配慢 &#x2F; 易于破碎大的空闲块以致大分区无法被分配</td>
</tr>
</tbody></table>
<blockquote>
<p>三种分配方式并无优劣之分，因为我们无法判断内存请求的大小</p>
</blockquote>
<h2 id="碎片整理方法"><a href="#碎片整理方法" class="headerlink" title="碎片整理方法"></a>碎片整理方法</h2><p>可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p>
<ol>
<li><p>压缩式碎片整理</p>
<ul>
<li>重置程序以合并碎片</li>
<li>要求所有程序是动态可重置的</li>
<li>问题 :<ul>
<li>何时重置 ? (在程序处于等待状态时才可以重置)</li>
<li>需要考虑内存拷贝的开销</li>
</ul>
</li>
</ul>
</li>
<li><p>交换式碎片整理</p>
<ul>
<li><p>运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存</p>
</li>
<li><p>问题 :</p>
<ul>
<li>哪些程序应该被回收 ?</li>
</ul>
</li>
<li><p>情况 :</p>
<p>运行中 : P3</p>
<p>等待中 : P1 P2 P4</p>
<p>内存分布 -&gt; 主存 : OS &#x2F; P1 &#x2F; P3 &#x2F; P2 &#x2F; P4 磁盘 : 空</p>
<p>当P3程序需要更大的内存时 -&gt;</p>
<p>内存分布 -&gt; 主存 : OS &#x2F; P1 &#x2F; P3 &#x2F; P2 磁盘 : P4</p>
</li>
</ul>
</li>
</ol>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><blockquote>
<p>第四章的主要内容是：操作系统的非连续内存分配</p>
</blockquote>
<p>第三章介绍的是连续内存管理, 即 : 操作系统加载到内存以及程序加载到内存中时, 分配一块连续的空闲(内存)块. 但是容易出现碎片问题, 这一章介绍的非连续内存分配可以有效的减少碎片的出现.</p>
<h2 id="非连续内存分配的必要性"><a href="#非连续内存分配的必要性" class="headerlink" title="非连续内存分配的必要性"></a>非连续内存分配的必要性</h2><h3 id="连续内存分配的缺点"><a href="#连续内存分配的缺点" class="headerlink" title="连续内存分配的缺点"></a>连续内存分配的缺点</h3><ol>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片 &#x2F; 内碎片的问题</li>
</ol>
<h3 id="非连续内存分配的优点"><a href="#非连续内存分配的优点" class="headerlink" title="非连续内存分配的优点"></a>非连续内存分配的优点</h3><ol>
<li>一个程序的物理地址空间是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据(共享库等…)</li>
<li>支持动态加载和动态链接</li>
</ol>
<h3 id="非连续内存分配的缺点"><a href="#非连续内存分配的缺点" class="headerlink" title="非连续内存分配的缺点"></a>非连续内存分配的缺点</h3><ol>
<li>建立虚拟地址和物理地址的转换难度大<ul>
<li>软件方案</li>
<li>硬件方案(采用硬件方案) : 分段 &#x2F; 分页</li>
</ul>
</li>
</ol>
<h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h3><p><strong>段 :</strong> 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 &#x2F; 栈 &#x2F; .bss &#x2F; .data 等</p>
<p>**分段 : ** 更好的分离和共享</p>
<p>程序的分段地址空间如下图所示 :</p>
<p><a href="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067"><img src="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067" alt="img"></a></p>
<p><strong>分段寻址方案</strong></p>
<p>逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联.</p>
<p>一个段 : 一个内存”块”</p>
<p>程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址)</p>
<p>操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制)</p>
<p>物理地址 : 段表中的起始地址 + 二元组中的偏移地址</p>
<h3 id="分页-Paging"><a href="#分页-Paging" class="headerlink" title="分页(Paging)"></a>分页(Paging)</h3><h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>划分物理内存至固定大小的帧(Frame)</p>
<ul>
<li>大小是2的幂, 512 &#x2F; 4096 &#x2F; 8192</li>
</ul>
<p>划分逻辑地址空间至相同大小的页(Page)</p>
<ul>
<li>大小是2的幂, 512 &#x2F; 4096 &#x2F; 8192</li>
</ul>
<p>建立方案 → 转换逻辑地址为物理地址(pages to frames)</p>
<ul>
<li>页表</li>
<li>MMU &#x2F; TLB</li>
</ul>
<p><strong>帧(Frame)</strong></p>
<p>物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移)</p>
<p>帧号 : F位, 共有2^F个帧</p>
<p>帧内偏移 : S位, 每帧有2^S个字节</p>
<p>物理地址 &#x3D; 2^S * f + o</p>
<p>(例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧 物理地址 &#x3D; (3,6) 物理地址 &#x3D; 2^9 * 3 + 6 &#x3D; 1542)</p>
<blockquote>
<p>分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定</p>
</blockquote>
<p><strong>页(Page)</strong></p>
<p>一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 &#x3D; 帧内偏移的大小 页号大小 &lt;&gt; 帧号大小</p>
<p>一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移)</p>
<p>页号 : P位, 共有2^P个页</p>
<p>页内偏移 : S位, 每页有2^S个字节</p>
<p>虚拟地址 &#x3D; 2^S * p + o</p>
<h4 id="页寻址方案"><a href="#页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案</h4><p>操作系统维护一张页表, 页表保存了逻辑地址——物理地址之间的映射关系</p>
<p>存储 : (页号, 帧号)</p>
<ul>
<li>逻辑地址空间应当大于物理内存空间</li>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存(有助于减少碎片的产生)</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<h3 id="页表-Page-Table"><a href="#页表-Page-Table" class="headerlink" title="页表(Page Table)"></a>页表(Page Table)</h3><h4 id="页表概述"><a href="#页表概述" class="headerlink" title="页表概述"></a>页表概述</h4><p>每一个运行的程序都有一个页表</p>
<ul>
<li>属于程序运行状态, 会动态变化</li>
<li>PTBR : 页表基址寄存器</li>
</ul>
<p><strong>转换流程</strong></p>
<p>CPU根据程序的page的页号的若干位, 计算出索引值index, 在页表中搜索这个index, 得到的是帧号, 帧号和原本的offset组成物理地址.</p>
<p>页表中还有一些特殊标志位</p>
<ul>
<li>dirty bit,</li>
<li>resident bit, (0 : 对应的物理页帧在内存中不存在 ; 1 : 存在)</li>
<li>clock &#x2F; reference bit</li>
</ul>
<p><strong>转换实例</strong></p>
<p>16位地址的系统</p>
<ul>
<li>32KB的物理内存</li>
<li>每页的 1024 byte</li>
</ul>
<p>逻辑地址空间 : (4, 0) … (3, 1023)</p>
<p>页表 :</p>
<p>Flags | Frame nums</p>
<p>1 0 1 0 0 0 0 0 → 内存访问异常(可能要杀死程序)</p>
<p>0 1 1 0 0 1 0 0 → 页帧是4 偏移是 1023 → 物理地址 (4, 1023)</p>
<h4 id="分页机制的性能问题"><a href="#分页机制的性能问题" class="headerlink" title="分页机制的性能问题"></a>分页机制的性能问题</h4><p>访问一个内存单元需要2次内存访问</p>
<ul>
<li>一次用于获取页表项</li>
<li>一次用于访问数据</li>
</ul>
<p>页表可能非常大</p>
<ul>
<li>64位机器如果每页1024字节, 那么一个页表的大小会是多少？(2^64 &#x2F; 2^10 &#x3D; 2^54 存放不下)</li>
<li>每一个运行的程序都需要有一个页表</li>
</ul>
<p>如何处理？</p>
<ul>
<li>缓存(Caching)</li>
<li>间接(Indirection)访问</li>
</ul>
<h4 id="转换后备缓冲区-TLB"><a href="#转换后备缓冲区-TLB" class="headerlink" title="转换后备缓冲区(TLB)"></a>转换后备缓冲区(TLB)</h4><p>缓解时间问题</p>
<p>Translation Look-aside Buffer(TLB) 是一个缓冲区. CPU中有快表TLB(可以将经常访问的页表存放在这边)</p>
<p>缓存近期访问的页帧转换表项</p>
<ul>
<li>TLB使用关联内存实现, 具备快速访问性能</li>
<li>如果TLB命中, 物理页号可以很快被获取</li>
<li>如果TLB未命中, 对应的表项被更新到TLB中(x86的CPU由硬件实现, 其他的可能是由操作系统实现)</li>
</ul>
<h4 id="二级-x2F-多级页表"><a href="#二级-x2F-多级页表" class="headerlink" title="二级&#x2F;多级页表"></a>二级&#x2F;多级页表</h4><p>时间换空间</p>
<p>二级页表</p>
<ul>
<li>将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.</li>
<li>一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号</li>
<li>节约了一定的空间, 在一级页表中如果resident bit &#x3D; 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留</li>
</ul>
<p>多级页表</p>
<ul>
<li>通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”</li>
</ul>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>解决大地址空间问题</p>
<p>目的 : 根据帧号获得页号</p>
<p>反向页表只需要存在一张即可</p>
<ul>
<li>有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表</li>
<li>不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间</li>
</ul>
<h5 id="基于页寄存器-Page-Registers-的方案"><a href="#基于页寄存器-Page-Registers-的方案" class="headerlink" title="基于页寄存器(Page Registers)的方案"></a>基于页寄存器(Page Registers)的方案</h5><p>存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小.</p>
<p>每一个帧和一个寄存器关联, 寄存器内容包括 :</p>
<ul>
<li>resident bit : 此帧是否被占用</li>
<li>occupier : 对应的页号 p</li>
<li>protection bits : 保护位</li>
</ul>
<p>实例 :</p>
<ul>
<li>物理内存大小是 : 4096 * 4096 &#x3D; 4K * 4KB &#x3D; 16 MB</li>
<li>页面大小是 : 4096 bytes &#x3D; 4 KB</li>
<li>页帧数 : 4096 &#x3D; 4 K</li>
<li>页寄存器使用的空间(假设8 bytes &#x2F; register) : 8 * 4096 &#x3D; 32 Kbytes</li>
<li>页寄存器带来的额外开销 : 32K &#x2F; 16M &#x3D; 0.2%</li>
<li>虚拟内存大小 : 任意</li>
</ul>
<p>优势 :</p>
<ul>
<li>转换表的大小相对于物理内存来说很小</li>
<li>转换表的大小跟逻辑地址空间的大小无关</li>
</ul>
<p>劣势 :</p>
<ul>
<li>需要的信息对调了, 即根据帧号可以找到页号</li>
<li>如何转换回来? (如何根据页号找到帧号)</li>
<li>在需要在反向页表中搜索想要的页号</li>
</ul>
<h5 id="基于关联内存-associative-memory-的方案"><a href="#基于关联内存-associative-memory-的方案" class="headerlink" title="基于关联内存(associative memory)的方案"></a>基于关联内存(associative memory)的方案</h5><p>硬件设计复杂, 容量不大, 需要放置在CPU中</p>
<ul>
<li>如果帧数较少, 页寄存器可以被放置在关联内存中</li>
<li>在关联内存中查找逻辑页号<ul>
<li>成功 : 帧号被提取</li>
<li>失败 : 页错误异常 (page fault)</li>
</ul>
</li>
<li>限制因素:<ul>
<li>大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)</li>
</ul>
</li>
</ul>
<h5 id="基于哈希-hash-的方案"><a href="#基于哈希-hash-的方案" class="headerlink" title="基于哈希(hash)的方案"></a>基于哈希(hash)的方案</h5><p>哈希函数 : h(PID, p) 从 PID 标号获得页号</p>
<p>在反向页表中通过哈希算法来搜索一个页对应的帧号</p>
<ul>
<li>对页号做哈希计算, 为了在帧表中获取对应的帧号</li>
<li>页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数</li>
<li>为了查找页 i , 执行下列操作 :<ul>
<li>计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器</li>
<li>检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败</li>
</ul>
</li>
</ul>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><blockquote>
<p>第五章的主要内容是：操作系统的虚拟内存管理技术</p>
</blockquote>
<h2 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h2><p>使用硬盘&#x2F;磁盘使更多的程序在有限的内存中运行</p>
<p>理想的存储器 : 更大更快更便宜和非易失性的存储区</p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中</p>
<p>目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用.</p>
<p>原理 :</p>
<p>把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行.</p>
<ul>
<li>必要部分(常用功能)的代码和数据常驻内存;</li>
<li>可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存;</li>
<li>不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区.</li>
</ul>
<blockquote>
<p>也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区.</p>
</blockquote>
<p>实例 :</p>
<p>A(20k) <em><strong>*B(50k) ____ D(30k) | ____ C(30k) ____ E(20k) |*</strong></em> F(40k)</p>
<p>因此不需要将整个程序190k的数据全部放入内存中, 而是划分为 常驻区(20k) 覆盖区0(50k) 覆盖区1(40k) 压缩至了110k的内存空间使用</p>
<p>缺点 :</p>
<ul>
<li>由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度;</li>
<li>覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省.</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中</p>
<p>目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源</p>
<p>原理 :</p>
<p>可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间.</p>
<p>存在问题 :</p>
<ul>
<li>交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出;</li>
<li>交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取</li>
<li>程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法</li>
</ul>
<h2 id="覆盖技术和交换技术的对比"><a href="#覆盖技术和交换技术的对比" class="headerlink" title="覆盖技术和交换技术的对比"></a>覆盖技术和交换技术的对比</h2><p>特点 :</p>
<ul>
<li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构.</li>
<li>交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构.</li>
<li>换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部.</li>
</ul>
<p>在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :</p>
<ul>
<li>覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担.</li>
<li>交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销.</li>
</ul>
<h2 id="虚拟内存管理技术"><a href="#虚拟内存管理技术" class="headerlink" title="虚拟内存管理技术"></a>虚拟内存管理技术</h2><p>如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术</p>
<ul>
<li><p>目标</p>
<p>像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉.</p>
<p>像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换.</p>
</li>
<li><p>程序局部性原理</p>
<p>程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域.</p>
<ul>
<li>时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ;</li>
<li>空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内.</li>
</ul>
<p>程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果.</p>
<p>实例 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述 :</span><br><span class="line">页面大小为4k, 分配给每个进程的物理页面是1. </span><br><span class="line">在一个进程中, 定义了如下的二维数组 int A[1024][1024]. 该数组按行存放在内存, 每一行放在一个页面中.</span><br><span class="line">考虑一下程序的编写方法对缺页率的影响?</span><br><span class="line"></span><br><span class="line">程序编写方法1 : (发生了1024*1024次缺页中断)</span><br><span class="line">for(j = 0; j &lt; 1024; j++)</span><br><span class="line">		for(i = 0; i &lt; 1024; i++)</span><br><span class="line">				A[i][j] = 0;</span><br><span class="line"></span><br><span class="line">程序编写方法2 : (发生了1024次缺页中断)</span><br><span class="line">for(i = 0; i &lt; 1024; i++)</span><br><span class="line">		for(j = 0; j &lt; 1024; j++)</span><br><span class="line">				A[i][j] = 0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本概念</p>
<p>可以在页式或段式内存管理的基础上实现</p>
<ul>
<li>在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行;</li>
<li>在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序;</li>
<li>另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段.</li>
</ul>
</li>
<li><p>基本特征</p>
<ul>
<li>大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB.</li>
<li>部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的;</li>
<li>不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性.</li>
</ul>
</li>
<li><p>虚拟页式内存管理</p>
<p>页式内存管理</p>
<p>页表 : 完成逻辑页到物理页帧的映射</p>
<p>根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址.</p>
<p>虚拟页式内存管理</p>
<ul>
<li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能.</p>
</li>
<li><p>基本思路</p>
<ul>
<li>当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.</li>
<li>在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行.</li>
</ul>
</li>
<li><p>页表表项</p>
<p>逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号</p>
<p>驻留位 : 表示该页是在内存中还是在外存.</p>
<p>保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等</p>
<p>修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存</p>
<p>访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法.</p>
</li>
<li><p>缺页中断处理过程 :</p>
<ol>
<li>如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步;</li>
<li>采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存;</li>
<li>对q所对应的页表项修改, 把驻留位置为0;</li>
<li>将需要访问的页p装入到物理页面f当中;</li>
<li>修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f;</li>
<li>重新运行被中断是指令.</li>
</ol>
<blockquote>
<p>在何处保存未被映射的页?</p>
<ul>
<li>能够简单地识别在二级存储器中的页</li>
<li>交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面</li>
</ul>
</blockquote>
<p>后备存储(二级存储) :</p>
<ul>
<li>一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置</li>
<li>代码段 : 映射到可执行二进制文件</li>
<li>动态加载的共享库程序段 : 映射到动态调用的库文件</li>
<li>其他段 : 可能被映射到交换文件(swap file)</li>
</ul>
</li>
<li><p>虚拟内存性能</p>
<p>为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)</p>
<p>EAT &#x3D; 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率</p>
<p>实例 :</p>
<p>访存时间 : 10 ns</p>
<p>磁盘访问时间 : 5 ms</p>
<p>参数 p &#x3D; page fault 几率</p>
<p>参数 q &#x3D; dirty page 几率(对页面写操作)</p>
<p>EAT &#x3D; 10*(1-p) + 5000000<em>p</em>(1+q)</p>
</li>
</ul>
</li>
</ul>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><blockquote>
<p>第六章的主要内容是：操作系统的虚拟内存管理技术中的页面置换算法</p>
</blockquote>
<h2 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h2><p>功能 : 当缺页中断发生, 需要调入新的页面而内存已满时, 选择内存当中哪个物理页面被置换.</p>
<p>目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数). 具体来说, 把未来不再使用的或短期内较少使用的页面换出, 通常只能在局部性原理指导下依据过去的统计数据来进行预测.</p>
<p>页面锁定 : 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程. 实现的方式是 : 在页表中添加锁定标记位(lock bit).</p>
<h2 id="实验设置与评价方法"><a href="#实验设置与评价方法" class="headerlink" title="实验设置与评价方法"></a>实验设置与评价方法</h2><p>实例 :</p>
<p>记录一个进程对页访问的一个轨迹</p>
<ul>
<li>举例 : 虚拟地址跟踪(页号, 偏移)…<ul>
<li>(3,0) (1,9) (4,1) (2,1) (5,3) (2,0) …</li>
</ul>
</li>
<li>生成的页面轨迹<ul>
<li>3, 1, 4, 2, 5, 2, 1, …</li>
</ul>
</li>
</ul>
<p>模拟一个页面置换的行为并且记录产生页缺失数的数量</p>
<ul>
<li>更少的缺失, 更好的性能</li>
</ul>
<h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>基本思路 : 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面.</p>
<p>这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.</p>
<p>可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法)</p>
<h3 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h3><p>基本思路 : 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾.</p>
<p>性能较差, 调出的页面有可能是经常要访问的页面. 并且有 belady现象. FIFO算法很少单独使用.</p>
<h3 id="最近最久未使用算法"><a href="#最近最久未使用算法" class="headerlink" title="最近最久未使用算法"></a>最近最久未使用算法</h3><p>LRU(Least Recently Used)</p>
<p>基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰.</p>
<p>它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问.</p>
<p>LRU算法需要记录各个页面使用时间的先后顺序, 开销比较大.</p>
<p>两种可能的实现方法是 :</p>
<ul>
<li>系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面.</li>
<li>设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的.</li>
</ul>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>基本思路 :</p>
<p>需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为0. 然后如果这个页面被访问, 则把该位置设为1;</p>
<p>把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来);</p>
<p>当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格.</p>
<p>流程 :</p>
<p>如果访问页在物理内存中, 访问位置1.</p>
<p>如果不在物理页, 从指针当前指向的物理页开始, 如果访问位0, 替换当前页, 指针指向下一个物理页; 如果访问位为1, 置零以后访问下一个物理页再进行判断. 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换.</p>
<h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页.</p>
<p>used dirty → used dirty</p>
<p>0 0 replace</p>
<p>0 1 0 0</p>
<p>1 0 0 0</p>
<p>1 1 0 1</p>
<p>相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会.</p>
<h3 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h3><p>Least Frequently used, LFU</p>
<p>基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰.</p>
<p>实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 当发生缺页中断时, 淘汰计数值最小的那个页面.</p>
<p>LRU和LFU的对比 : LRU考察的是多久未访问, 时间越短越好. 而LFU考察的是访问的次数和频度, 访问次数越多越好.</p>
<h3 id="Belady现象-科学家名字"><a href="#Belady现象-科学家名字" class="headerlink" title="Belady现象(科学家名字)"></a>Belady现象(科学家名字)</h3><p>在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象;</p>
<p>出现原因 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的.</p>
<h3 id="LRU-x2F-FIFO-和-Clock-的比较"><a href="#LRU-x2F-FIFO-和-Clock-的比较" class="headerlink" title="LRU &#x2F; FIFO 和 Clock 的比较"></a>LRU &#x2F; FIFO 和 Clock 的比较</h3><p>LRU和FIFO都是先进先出的思路, 只不过LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法.</p>
<p>例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 …</p>
<h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立?</p>
<ul>
<li>如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断.</li>
<li>如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型.</li>
</ul>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>工作集 : 一个进程当前正在使用的逻辑页面集合.</p>
<p>可以使用一个二元函数 W(t, delta) 来表示 :</p>
<p>t 是当前的执行时刻;</p>
<p>delta 称为工作集窗口, 即一个定长的页面访问的时间窗口;</p>
<p>W(t, delta) &#x3D; 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)</p>
<p>|W(t, delta)| 是工作集的大小, 即逻辑页的数量.</p>
<p>工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值.</p>
<h3 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h3><p>常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.</p>
<ul>
<li>工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法;</li>
<li>如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);</li>
<li>当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降.</li>
</ul>
<h3 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h3><p>当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃.</p>
<h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>可变分配策略 : 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.</p>
<ul>
<li>可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面.</li>
<li>优缺点 : 性能较好, 但增加了系统开销.</li>
<li>具体实现 : 可以使用缺页率算法来动态调整常驻集的大小.</li>
</ul>
<p>缺页率 : 表示 “缺页次数 &#x2F; 内存访问次数”</p>
<p>影响因素 : 页面置换算法, 分配给进程的物理页面数目, 页面本身的大小, 程序的编写方法.</p>
<h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><ul>
<li>如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”.</li>
<li>产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.</li>
</ul>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><blockquote>
<p>第七章的主要内容是：进程</p>
</blockquote>
<h2 id="进程-process-描述"><a href="#进程-process-描述" class="headerlink" title="进程(process)描述"></a>进程(process)描述</h2><h3 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3><p>进程 : 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>进程包括 :</p>
<ul>
<li>程序的代码</li>
<li>程序处理的数据</li>
<li>程序计数器中的值, 指示下一条将运行的指令</li>
<li>一组通用的寄存器的当前值, 堆, 栈</li>
<li>一组系统资源(如打开的文件)</li>
</ul>
<p>进程和程序的联系 :</p>
<ul>
<li>程序是产生进程的基础</li>
<li>程序的每次运行构成不同的进程</li>
<li>进程是程序功能的体现</li>
<li>通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序.</li>
</ul>
<p>进程和程序的区别 :</p>
<ul>
<li>进程是动态的, 程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 &#x2F; 用户态.</li>
<li>进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存.</li>
<li>进程和程序的组成不同 : 进程的组成包括程序, 数据和进程控制块(进程状态信息)</li>
</ul>
<h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><p><strong>动态性</strong> : 可动态地创建, 结果进程;</p>
<p><strong>并发性</strong> : 进程可以被独立调度并占用处理机运行; (并发:一段, 并行:一时刻)</p>
<p><strong>独立性</strong> : 不同进程的工作不相互影响;(页表是保障措施之一)</p>
<p><strong>制约性</strong> : 因访问共享数据, 资源或进程间同步而产生制约.</p>
<blockquote>
<p>抛出了一个问题 : 如果你要设计一个OS, 怎么样来实现其中的进程管理机制?</p>
</blockquote>
<h3 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h3><p>描述进程的数据结构 : 进程控制块 (Process Control Block)</p>
<p>操作系统为每个进程都维护了一个PCB, 用来保存与该进程有关的各种状态信息.</p>
<p><strong>进程控制块 :</strong> 操作系统管理控制进程运行所用的信息集合.</p>
<p>进程的创建 : 为该进程生成一个PCB</p>
<p><strong>进程的终止 :</strong> 回收它的PCB</p>
<p><strong>进程的组织管理 :</strong> 通过对PCB的组织管理来实现</p>
<p>(PCB具体包含什么信息? 如何组织的? 进程的状态转换?)</p>
<p><strong>PCB有以下三大类信息 :</strong></p>
<ul>
<li>进程标志信息. 如本进程的标志, 本进程的产生者标志(父进程标志). 用户标志</li>
<li>处理机状态信息保存区 : 保存进程的运行现场信息 :<ul>
<li>用户可见寄存器. 用户程序可以使用的数据, 地址等寄存器</li>
<li>控制和状态寄存器. 如程序计数器(PC), 程序状态字(PSW)</li>
<li>栈指针. 过程调用, 系统调用, 中断处理和返回时需要用到它</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>调度和状态信息. 用于操作系统调度进程并占用处理机使用.</li>
<li>进程间通信信息. 为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中.</li>
<li>存储管理信息. 包含有指向本进程映像存储空间的数据结构.</li>
<li>进程所用资源. 说明由进程打开, 使用的系统资源. 如打开的文件等.</li>
<li>有关数据结构的链接信息. 进程可以连接到一个进程队列中, 或连接到相关的其他进程的PCB.</li>
</ul>
</li>
</ul>
<p><strong>进程的组织方式</strong></p>
<p>链表 : 同一状态的进程其PCB成一链表, 多个状态对应多个不同的链表.(各状态的进程形成不同的链表 : 就绪链表, 阻塞链表)</p>
<p>索引表 : 同一状态的进程归入一个index表(由index指向PCB), 多个状态对应多个不同的index表(各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表)</p>
<h2 id="进程状态-state"><a href="#进程状态-state" class="headerlink" title="进程状态(state)"></a>进程状态(state)</h2><h3 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>引起进程创建的3个主要事件 :</p>
<ul>
<li>系统初始化;</li>
<li>用户请求创建一个新进程;</li>
<li>正在运行的进程执行了创建进程的系统调用.</li>
</ul>
<h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p>内核选择一个就绪的进程, 让它占用处理机并执行</p>
<p>(为何选择?如何选择?)</p>
<h4 id="进程等待-阻塞"><a href="#进程等待-阻塞" class="headerlink" title="进程等待(阻塞)"></a>进程等待(阻塞)</h4><p>在以下情况下, 进程等待(阻塞):</p>
<ol>
<li>请求并等待系统服务, 无法马上完成</li>
<li>启动某种操作, 无法马上完成</li>
<li>需要的数据没有到达</li>
</ol>
<p>进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生.</p>
<h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>唤醒进程的原因 :</p>
<ol>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
<li>将该进程的PCB插入到就绪队列</li>
</ol>
<p>进程只能被别的进程或操作系统唤醒</p>
<h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p>在以下四种情况下, 进程结束 :</p>
<ul>
<li>正常退出(自愿)</li>
<li>错误退出(自愿)</li>
<li>致命错误(强制性)</li>
<li>被其他进程杀死(强制性)</li>
</ul>
<h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p><strong>进程的三种基本状态 :</strong> 进程在生命结束前处于三种基本状态之一.</p>
<p>不同系统设置的进程状态数目不同.</p>
<p><strong>三种基本状态</strong></p>
<ol>
<li>运行状态(Running) : 当一个进程正在处理机上运行时</li>
<li>就绪状态(Ready) : 一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行</li>
<li>等待状态(阻塞状态 Blocked) : 一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入&#x2F;输出完成.</li>
</ol>
<p><strong>进程其它的基本状态</strong></p>
<p>创建状态(New) : 一个进程正在被创建, 还没被转到就绪状态之前的状态</p>
<p>结束状态(Exit): 一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致.</p>
<p><strong>可能的状态变化如下 :</strong></p>
<p>NULL → New : 一个新进程被产生出来执行一个程序</p>
<p>New → Ready: 当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态</p>
<p>Ready → Running : 处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行</p>
<p>Running → Exit : 当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理</p>
<p>Running → Ready : 处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机</p>
<p>Running → Blocked: 当进程请求某样东西且必须等待时</p>
<p>Blocked → Ready : 当进程要等待某事件到来时, 它从阻塞状态变到就绪状态</p>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p>进程挂起, 为了合理且充分地利用系统资源.</p>
<p>进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上.(把进程放到磁盘上)</p>
<p><strong>两种挂起状态</strong></p>
<ol>
<li>阻塞挂起状态 : 进程在外存并等待某事件的出现;</li>
<li>就绪挂起状态 : 进程在外存, 但只要进入内存, 即可运行.</li>
</ol>
<p><strong>与挂起相关的状态转换</strong></p>
<p><strong>挂起 :</strong> 把一个进程从内存转到外存, 可能有以下几种情况 :</p>
<ul>
<li>阻塞到阻塞挂起 : 没有进程处于就绪状态或就绪进程要求更多内存资源时, 会进行这种转换, 以提交新进程或运行时就绪进程.</li>
<li>就绪到就绪挂起 : 当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级就绪进程时, 系统会选择挂起低优先级就绪进程.</li>
<li>运行到就绪挂起 : 对抢先式分时系统, 当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时, 系统可能会把运行进程转导就绪挂起状态.</li>
</ul>
<p><strong>在外存时的状态转换 :</strong></p>
<ul>
<li>阻塞挂起到就绪挂起 : 当有阻塞挂起因相关事件出现时, 系统会把阻塞挂起进程转换为就绪挂起进程.</li>
</ul>
<p><strong>解挂, 激活 :</strong> 把一个进程从外存转到内存; 可能有以下几种情况 :</p>
<ul>
<li>就绪挂起到就绪 : 没有就绪进程或挂起就绪进程优先级高于就绪进程时, 会进行这种转换.</li>
<li>阻塞挂起到阻塞 : 当一个进程释放足够内存时, 系统会把一个高优先级阻塞挂起(系统认为会很快出现所等待的事件)进程转换为阻塞进程.</li>
</ul>
<blockquote>
<p>抛出一个问题 : OS怎么通过PCB和定义的进程状态来管理PCB, 帮助完成进程的调度过程?</p>
</blockquote>
<h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><ul>
<li>由操作系统来维护一组队列, 用来表示系统当中所有进程的当前状态;</li>
<li>不同的状态分别用不同的队列来表示(就绪队列, 各种类型的阻塞队列);</li>
<li>每个进程的PCB都根据它的状态加入到相应的队列当中, 当一个进程的状态发生变化时, 它的PCB从一个状态中脱离出来, 加入到另外一个队列.</li>
</ul>
<h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h2><h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程?"></a>为什么使用线程?</h3><p>实例 : 编写一个MP3播放软件.</p>
<p>核心功能 : (1)从MP3音频文件中读取数据; (2)对数据进行解压缩; (3)把解压缩后的音频数据播放出来.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单进程方式</span><br><span class="line">while(1)&#123;</span><br><span class="line">	Read();</span><br><span class="line">	Decompress();</span><br><span class="line">	Play();</span><br><span class="line">&#125;</span><br><span class="line">//问题: 播放出来的声音能否连贯? 各个函数之间不是并发执行, 影响资源的使用效率.</span><br><span class="line">//多进程</span><br><span class="line">//进程1</span><br><span class="line">while(1)&#123;</span><br><span class="line">	Read();</span><br><span class="line">&#125;</span><br><span class="line">//进程2</span><br><span class="line">while(1)&#123;</span><br><span class="line">	Decompress();</span><br><span class="line">&#125;</span><br><span class="line">//进程3</span><br><span class="line">while(1)&#123;</span><br><span class="line">	Play();</span><br><span class="line">&#125;</span><br><span class="line">//问题: 进程之间如何通信,共享数据?另外,维护进程的系统开销较大:</span><br><span class="line">//创建进程时,分配资源,建立PCB;撤销进程时,回收资源,撤销PCB;进程切换时,保存当前进程的状态信息</span><br></pre></td></tr></table></figure>

<p>因此需要提出一种新的实体, 满足以下特征:</p>
<ol>
<li>实体之间可以并发执行;</li>
<li>实体之间共享相同的地址空间.</li>
</ol>
<p>这实体就是线程.</p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程是进程当中的一条执行流程.</p>
<p>从两个方面重新理解进程:</p>
<ol>
<li>从资源组合的角度: 进程把一组相关的资源组合起来,构成了一个资源平台(环境),包括地址空间(代码段,数据段),打开的文件等各种资源;</li>
<li>从运行的角度: 代码在这个资源平台上的一条执行流程(线程).</li>
</ol>
<p>线程 &#x3D; 进程 - 共享资源</p>
<h3 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h3><p>线程的优点:</p>
<ul>
<li>一个进程中可以同时存在多个线程;</li>
<li>各个线程之间可以并发地执行;</li>
<li>各个线程之间可以共享地址空间和文件等资源.</li>
</ul>
<p>线程的缺点:</p>
<ul>
<li><p>一个线程崩溃, 会导致其所属进程的所有线程崩溃.(给它了”权限”就得有更高的”责任”)</p>
</li>
<li><p>线程所需的资源</p>
<p>不同的线程需要独立的寄存器和堆栈, 共享代码,数据和文件等.</p>
</li>
</ul>
<h3 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h3><ul>
<li>进程是资源分配单位, 线程是CPU调度单位;</li>
<li>进程拥有一个完整的资源平台, 而线程只独享必不可少的资源, 如寄存器和栈;</li>
<li>线程同样具有就绪,阻塞和执行三种基本状态,同样具有状态之间的转换关系;</li>
<li>线程能减少并发执行的时间和空间开销:<ul>
<li>线程的创建时间比进程短;(直接利用所属进程的一些状态信息)</li>
<li>线程的终止时间比进程短;(不需要考虑把这些状态信息给释放)</li>
<li>同一进程内的线程切换时间比进程短;(同一进程不同线程的切换不需要切换页表)</li>
<li>由于同一进程的各线程之间共享内存和文件资源, 可直接进行不通过内核的通信.(直接通过内存地址读写资源)</li>
</ul>
</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式:</p>
<ul>
<li>用户线程 : 在用户空间实现; POSIX Pthreads, Mach C-threads, Solaris threads</li>
<li>内核线程 : 在内核中实现; Windows, Solaris, Linux</li>
<li>轻量级进程: 在内核中实现,支持用户线程; Solaris</li>
</ul>
<p><strong>用户线程</strong></p>
<p>操作系统只能看到进程, 看不到线程, 线程的TCB在线程库中实现;</p>
<p>在用户空间实现的线程机制, 它不依赖于操作系统的内核, 由一组用户级的线程库来完成线程的管理, 包括进程的创建,终止,同步和调度等.</p>
<ul>
<li>由于用户线程的维护由相应的进程来完成(通过线程库函数),不需要操作系统内核了解用户进程的存在,可用于不支持线程技术的多进程操作系统;</li>
<li>每个进程都需要它自己私有的线程控制块(TCB)列表,用来跟踪记录它的各个线程的状态信息(PC,栈指针,寄存器),TCB由线程库函数来维护;</li>
<li>用户线程的切换也是由线程库函数来完成,无需用户态&#x2F;核心态切换,所以速度特别快;</li>
<li>允许每个进程拥有自定义的线程调度算法.</li>
</ul>
<p>用户线程的缺点:</p>
<ul>
<li>阻塞性的系统调用如何实现?如果一个线程发起系统调用而阻塞,则整个进程在等待;</li>
<li>当一个线程开始运行时,除非它主动地交出CPU的使用权,否则它所在的进程当中的其他线程将无法运行;</li>
<li>由于时间片分配给进程,所以与其他进程比,在多线程执行时,每个线程得到的时间片较少,执行会较慢.</li>
</ul>
<p><strong>内核线程</strong></p>
<p>操作系统能够看到进程也可能看到线程,线程在内核中实现;</p>
<p>内核线程是在操作系统的内核当中实现的一种线程机制,由操作系统的内核来完成线程的创建,终止和管理.</p>
<ul>
<li>在支持内核线程的操作系统中,由内核来维护进程和线程的上下文信息(PCB和TCB);</li>
<li>线程的创建,终止和切换都是通过系统调用,内核函数的方式来进行,由内核来完成,因此系统开销较大;</li>
<li>在一个进程当中,如果某个内核线程发起系统调用而被阻塞,并不会影响其他内核线程的运行;</li>
<li>时间片分配给线程,多线程的进程获得更多CPU时间;</li>
<li>Windows NT 和 Windows 2000&#x2F;XP 支持内核线程.</li>
</ul>
<p><strong>轻量级进程</strong></p>
<p>它是内核支持的用户线程.一个进程可以有一个或多个轻量化进程,每个量级进程由一个单独的内核线程来支持.(Solaris,Linux)</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>停止当前运行进程(从运行状态变成其他状态),并且调度其他进程(转变为运行状态)</p>
<ul>
<li>必须在切换之前存储许多部分的进程上下文</li>
<li>必须能够在之后恢复他们,所以进程不能显示它曾经被暂停过</li>
<li>必须快速(上下文切换时非常频繁)</li>
</ul>
<p>需要存储什么上下文?</p>
<ul>
<li>寄存器(PC,SP…),CPU状态等信息</li>
<li>一些时候可能会费时,所以我们应该尽可能避免</li>
</ul>
<p>操作系统为活跃进程准备了进程控制块</p>
<p>操作系统将进程控制块放置在一个合适的队列中</p>
<ul>
<li>就绪队列</li>
<li>等待IO队列(每个设备的队列)</li>
<li>僵尸队列</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>fork()的简单实现</p>
<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和CPU寄存器到子进程</li>
<li>开销昂贵</li>
</ul>
<p>在99%的情况下,我们在调用fork()之后调用exec()</p>
<ul>
<li>在fork()操作中内存复制是没有作用的</li>
<li>子进程将可能关闭打开的文件和连接</li>
<li>开销因此是最高的</li>
<li>为什么不能结合它们在一个调用中(OS&#x2F;2, windows)?</li>
</ul>
<p>vfork()</p>
<ul>
<li>一个创建进程的系统调用,不需要创建一个同样的内存映像</li>
<li>一些时候称为轻量级fork()</li>
<li>子进程应该几乎立即调用exec()</li>
<li>现在不再使用如果我们使用 copy on write 技术</li>
</ul>
<h3 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h3><p>系统调用exec()加载程序取代当前运行的进程</p>
<p>exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)</p>
<p>它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)</p>
<p>如果调用成功(相同的进程,不同的程序)</p>
<p>代码,stack,heap重写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pid = fork(); //创建子进程</span><br><span class="line">if(pid == 0) &#123;    //子进程</span><br><span class="line">	exec_status = exec(&quot;calc&quot;, argc, argv0,argv1,...);</span><br><span class="line">	printf(&quot;Why would I execute?&quot;);</span><br><span class="line">&#125; else if(pid &gt; 0) &#123; //父进程</span><br><span class="line">	printf(&quot;Whose your daddy?&quot;);</span><br><span class="line">	...</span><br><span class="line">	child_status = wait(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h3><p>wait()系统调用是被父进程用来等待子进程的结束</p>
<ul>
<li>一个子进程向父进程返回一个值,所以父进程必须接受这个值并处理</li>
<li>wait()系统调用担任这个要求<ul>
<li>它使父进程去睡眠来等待子进程的结束</li>
<li>当一个子进程调用exit()的时候,操作系统解锁父进程,并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起)如果这里没有子进程存活,wait()立刻返回</li>
<li>当然,如果这里有为父进程的僵尸等待,wait()立即返回其中一个值(并且解除僵尸状态)</li>
</ul>
</li>
<li>进程结束执行之后,它调用exit()</li>
<li>这个系统调用:<ul>
<li>将这程序的”结果”作为一个参数</li>
<li>关闭所有打开的文件,连接等等</li>
<li>释放内存</li>
<li>释放大部分支持进程的操作系统结构</li>
<li>检查是否父进程是存活着的:<ul>
<li>如果是的话,它保留结果的值直到父进程需要它;在这种情况里,进程没有真正死亡,但是它进入了僵尸状态</li>
<li>如果没有,它释放所有的数据结构,这个进程死亡</li>
</ul>
</li>
<li>清理所有等待的僵尸进程</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集(资源回收)</li>
</ul>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><blockquote>
<p>第八章的主要内容是：调度算法(感觉清华这门课程前几章比较精彩,后续讲的有点混乱)</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="上下文切换-1"><a href="#上下文切换-1" class="headerlink" title="上下文切换"></a>上下文切换</h3><ul>
<li>切换CPU的当前任务, 从一个进程&#x2F;线程到另一个</li>
<li>保存当前进程&#x2F;线程在PCB&#x2F;TCB中的执行上下文(CPU状态)</li>
<li>读取下一个进程&#x2F;线程的上下文</li>
</ul>
<h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><ul>
<li>从就绪队列中挑选一个进程&#x2F;线程作为CPU将要运行的下一个进程&#x2F;线程</li>
<li>调度程序: 挑选进程&#x2F;线程的内核函数(通过一些调度策略)</li>
<li>什么时候进行调度?</li>
</ul>
<h3 id="内核运行调度程序的条件-满足一条即可"><a href="#内核运行调度程序的条件-满足一条即可" class="headerlink" title="内核运行调度程序的条件(满足一条即可)"></a>内核运行调度程序的条件(满足一条即可)</h3><ul>
<li>一个进程从运行状态切换到等待状态</li>
<li>一个进程被终结</li>
</ul>
<h3 id="不可抢占"><a href="#不可抢占" class="headerlink" title="不可抢占"></a>不可抢占</h3><ul>
<li>调度程序必须等待事件结束</li>
</ul>
<h3 id="可以抢占"><a href="#可以抢占" class="headerlink" title="可以抢占"></a>可以抢占</h3><ul>
<li>调度程序在中断被相应后执行</li>
<li>当前的进程从运行切换到就绪, 或者一个进程从等待切换到就绪</li>
<li>当前运行的进程可以被换出</li>
</ul>
<h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><ul>
<li><p>调度策略</p>
<p>人们通常都需要”更快”的服务</p>
<p>什么是更快?</p>
<ul>
<li>传输文件时的高带宽</li>
<li>玩游戏时的低延迟</li>
<li>这两个因素是独立的</li>
</ul>
<p>和水管类比</p>
<ul>
<li>低延迟: 喝水的时候想要一打开水龙头水就流出来</li>
<li>高带宽: 给游泳池充水时希望从水龙头里同时流出大量的水,并且不介意是否存在延迟</li>
</ul>
<p>我们的目标:</p>
<ul>
<li>减少响应时间: 及时处理用户的输出并且尽快将输出提供给用户</li>
<li>减少平均响应时间的波动: 在交互系统中,可预测性比高差异性低平均更重要</li>
<li>增加吞吐量: 减少开销(操作系统开销,上下文切换);系统资源的高效率用(CPU,IO设备)</li>
<li>减少等待时间: 减少每个进程的等待时间</li>
</ul>
</li>
<li><p>程序执行模型</p>
<p>执行模型 : 程序在CPU突发和IO中交替</p>
<ul>
<li>每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU</li>
<li>在时间分片机制下,线程可能在结束当前CPU突发前被迫放弃CPU</li>
</ul>
</li>
<li><p>评价指标</p>
<p>CPU使用率: CPU处于忙状态所占时间的百分比</p>
<p>吞吐量: 在单位时间内完成的进程数量</p>
<p>周转时间: 一个进程从初始化到结束,包括所有等待时间所花费的时间</p>
<p>等待时间: 进程在就绪队列中的总时间</p>
<p>响应时间: 从一个请求被提交到产生第一次相应所花费的总时间</p>
<p>各指标在操作系统上的表现:</p>
<p>低延迟调度增加了交互式表现(如果移动了鼠标,但是屏幕中的光标却没动,我们可能会重启电脑)</p>
<p>操作系统需要保证低吞吐量不受影响(我想要结束长时间的编程,所以操作系统必须不时进行调度,即使存在许多交互任务)</p>
<p>吞吐量是操作系统的计算带宽</p>
<p>响应时间是操作系统的计算延迟</p>
</li>
<li><p>公平的目标</p>
<p>举例:</p>
<ul>
<li>保证每个进程占用相同的CPU时间</li>
<li>这公平嘛?如果一个用户比其他用户运行更多的进程怎么办</li>
</ul>
<p>举例:</p>
<ul>
<li>保证每个进程都等待相同的时间</li>
</ul>
<p>公平通常会增加平均响应时间</p>
</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul>
<li><p><strong>FCFS(先来先服务)</strong></p>
<p>First come, First Served</p>
<p>如果进程在执行中阻塞,队列中的下一个会得到CPU</p>
<p>优点: 简单</p>
<p>缺点:</p>
<ul>
<li>平均等待时间波动较大</li>
<li>花费时间少的任务可能排在花费时间长的任务后面</li>
<li>可能导致IO和CPU之间的重叠处理(CPU密集型进程会导致IO设备闲置时,IO密集型进程也在等待)</li>
</ul>
</li>
<li><p><strong>SPN(SJF) SRT(短进程优先(短作业优先)短剩余时间优先)[最优平均等待时间]</strong></p>
<p>Shortest Process Next(Shortest Job First) Shortest Remaining Time</p>
<p>选择预测的完成时间来将任务入队</p>
<p>可以是抢占的或者是不可抢占的</p>
<p>可能导致饥饿</p>
<ul>
<li>连续的短任务流会使场任务饥饿</li>
<li>短任务可用时的任何场任务的CPU时间都会增加平均等待时间</li>
</ul>
<p>需要预测未来</p>
<ul>
<li>怎么预估下一个CPU突发的持续时间</li>
<li>简单的解决: 询问用户</li>
<li>如果用户欺骗就杀死进程</li>
<li>如果不知道怎么办?</li>
</ul>
</li>
<li><p><strong>HRRN(最高响应比优先)</strong></p>
<p>Highest Response Ratio Next</p>
</li>
<li><p><strong>Round Robin(轮循)</strong></p>
<p>使用时间切片和抢占来轮流执行任务</p>
<p>在叫做量子(或者时间切片)的离散单元中分配处理器</p>
<p>时间片结束时,切换到下一个准备好的进程</p>
<p>花销: 额外的上下文切换</p>
<p>时间量子太大:</p>
<ul>
<li>等待时间过长</li>
<li>极限情况退化成FCFS</li>
</ul>
<p>时间量子太小:</p>
<ul>
<li>反应迅速</li>
<li>吞吐量由于大量的上下文切换开销受到影响</li>
</ul>
<p>目标:</p>
<ul>
<li>选择一个合适的时间量子</li>
<li>经验规则: 维持上下文切换开销处于1%以内</li>
</ul>
</li>
<li><p><strong>Multilevel Feedback Queues(多级反馈队列)</strong></p>
<p>优先级队列中的轮循</p>
<p>就绪队列被划分成独立的队列: 比如前台(交互),后台(批处理)</p>
<p>每个队列拥有自己的调度策略: 比如前台(RR),后台(FCFS)</p>
<p>调度必须在队列间进行:</p>
<ul>
<li>固定优先级: 先处理前台,然后处理后台;可能导致饥饿</li>
<li>时间切片: 每个队列都得到一个确定的能够调度其进程的CPU总时间;比如80%使用RR的前台,20%使用FCFS的后台</li>
</ul>
<p>一个进程可以在不同的队列中移动</p>
<p>例如,n级优先级-优先级调度在所有级别中,RR在每个级别中</p>
<ul>
<li>时间量子大小随优先级级别增加而增加</li>
<li>如果任务在当前的时间量子中没有完成,则降到下一个优先级</li>
</ul>
<p>优点: CPU密集型任务的优先级下降很快;IO密集型任务停留在高优先级</p>
</li>
<li><p><strong>Fair Share Scheduling(公平共享调度)</strong></p>
<p>FSS控制用户对系统资源的访问</p>
<ul>
<li>一些用户组比其他用户组更重要</li>
<li>保证不重要的组无法垄断资源</li>
<li>未使用的资源按照每个组所分配的资源的比例来分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
</li>
</ul>
<h2 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h2><p>确定性建模: 确定一个工作量,然后计算每个算法的表现</p>
<p>队列模型: 用来处理随机工作负载的数学方法</p>
<p>实现&#x2F;模拟: 建立一个允许算法运行实际数据的系统;最灵活,最具一般性</p>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><ul>
<li><p>实时系统</p>
<p>定义: 正确性依赖于其时间和功能两方面的一个操作系统</p>
<p>性能指标: 时间约束的及时性;速度和平均性能相对不重要</p>
<p>主要特征: 时间约束的可预测性</p>
<p>分类:</p>
<ul>
<li>强实时系统: 需要在保证时间内完成重要的任务,必须完成</li>
<li>弱实时系统: 要求重要的进程的优先级更高,尽量完成,并非必须</li>
</ul>
<p>任务(工作单元): 一次计算,一次文件读取,一次信息传递等</p>
<p>属性: 去的进展所需要的资源;定时参数.</p>
</li>
<li><p>单调速率(RM)</p>
<ul>
<li>最佳静态优先级调度</li>
<li>通过周期安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期最短的任务</li>
</ul>
</li>
<li><p>截止日期最早优先(EDF)</p>
<ul>
<li>最佳的动态优先级调度</li>
<li>Deadline越早优先级越高</li>
<li>执行Deadline最早的任务</li>
</ul>
</li>
</ul>
<h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>多处理器的CPU调度更复杂:</p>
<ul>
<li>多个相同的单处理器组成一个多处理器</li>
<li>优点: 复杂共享</li>
</ul>
<p>对称多处理器(SMP)</p>
<ul>
<li>每个处理器运行自己的调度程序</li>
<li>需要在调度程序中同步</li>
</ul>
<h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p>可以发生在任务基于优先级的可抢占的调度机制中</p>
<p>当系统内的环境强制使高优先级任务等待低优先级任务时发生</p>
<h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><blockquote>
<p>第九章的主要内容是：同步</p>
</blockquote>
<h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>第一章到第八章内容, 到目前为止</p>
<ul>
<li>多道程序设计: 现代操作系统的重要特性</li>
<li>并行很有用(为什么?) 提示: 多个并发实体: CPU IO 用户 等</li>
<li>进程,线程: 操作系统抽象出来用于支持多道程序设计</li>
<li>CPU调度: 实现多道程序设计的机制</li>
<li>调度算法: 不同的策略</li>
</ul>
<p>独立的线程:</p>
<ul>
<li>不和其他线程共享资源或状态</li>
<li>确定性: 输入状态决定结果</li>
<li>可重现: 能够重现起始条件, IO</li>
<li>调度顺序不重要</li>
</ul>
<p>合作线程:</p>
<ul>
<li>在多个线程中共享状态</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
<p>不确定性和不可重现意味着bug可能是间歇性发生的</p>
<p>进程,线程;计算机,设备需要合作</p>
<p>合作优点:</p>
<ol>
<li>共享资源<ul>
<li>一台电脑,多个用户</li>
<li>一个银行存款余额,多台ATM机</li>
<li>嵌入式系统</li>
</ul>
</li>
<li>加速<ul>
<li>IO操作和计算可以重叠</li>
<li>多处理器</li>
</ul>
</li>
<li>模块化<ul>
<li>将大程序分解成小程序 gcc会调用cpp,cc1,cc2,as,ld</li>
<li>使系统易于扩展</li>
</ul>
</li>
</ol>
<p>程序可以调用函数fork()来创建一个新的进程</p>
<ul>
<li>操作系统需要分配一个新的并且唯一的进程ID</li>
<li>因此在内核中,这个系统调用会运行 new_pid &#x3D; next_pid++;</li>
<li>翻译成机器指令:<ul>
<li>Load next_pid Reg1</li>
<li>STORE Reg1 new_pid</li>
<li>INC Reg1</li>
<li>STORE Reg1 next_pid</li>
</ul>
</li>
</ul>
<p>假设两个进程并发执行</p>
<ul>
<li>如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102</li>
<li>可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101</li>
</ul>
<p>无论多个线程的指令序列怎样交替执行,程序都必须正常工作</p>
<ul>
<li>多线程程序具有不确定性和不可重现的特点</li>
<li>不经过专门设计,调试难度很高</li>
</ul>
<p>不确定性要求并行程序的正确性</p>
<ul>
<li>先思考清楚问题,把程序的行为设计清楚</li>
<li>切忌给予着手编写代码,碰到问题再调试</li>
</ul>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>前面的现象称为Race Condition(竞态条件)</p>
<p>系统缺陷: 结果依赖于并发执行或者时间的顺序,时间</p>
<ul>
<li>不确定性</li>
<li>不可重现</li>
</ul>
<p>怎么样避免竞态?</p>
<p>Atomic Operator(原子操作)</p>
<p>原子操作是指一次不存在任何终端或者失败的执行</p>
<ul>
<li>该执行成功结束</li>
<li>或者根本没有执行</li>
<li>并且不应发生任何部分执行的状态</li>
</ul>
<p>实际上操作往往不是原子的</p>
<ul>
<li>有些看上去是原子操作,实际上不是</li>
<li>连x++这样的简单语句,实际上是由三条指令构成的</li>
<li>有时候甚至连单条假期指令都不是原子的(Pipeline,super-scalar,out-of-order,pape fault)</li>
</ul>
<p>临界区(Critical section)是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域</p>
<p>互斥(Mutual exclusion)是指当一个 进程处于临界区并访问共享资源时,没有其他进程会处于临界区并且访问任何相同的共享资源</p>
<p>死锁(Dead lock)是指两个或以上进程,在相互等待完成特定任务,而最终没法将自身任务进行下去</p>
<p>饥饿(Starvation)是指一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>互斥: 同一时间临界区中最多存在一个线程</p>
<p>Progress: 如果一个线程想要进入临界区,那么它最终会成功</p>
<p>有限等待: 如果一个线程i处于入口区,那么在i的请求被接受之前,其他线程进入临界区的时间是有限制的</p>
<p>无忙等待(可选): 如果一个进程在等待进入临界区,那么在它可以进入之前会被挂起</p>
<h2 id="方法1-禁用硬件中断"><a href="#方法1-禁用硬件中断" class="headerlink" title="方法1:禁用硬件中断"></a>方法1:禁用硬件中断</h2><p>没有中断,没有上下文切换,因此没有并发</p>
<ul>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>大多数现代计算机体系结构都提供指令来完成</li>
</ul>
<p>进入临界区</p>
<ul>
<li>禁用中断</li>
</ul>
<p>离开临界区</p>
<ul>
<li>开启中断</li>
</ul>
<p>一旦中断被禁用,线程就无法被停止</p>
<ul>
<li>整个系统都会为你停下来</li>
<li>可能导致其他线程处于饥饿状态</li>
</ul>
<p>要是临界区可以任意长怎么办?</p>
<ul>
<li>无法限制响应中断所需的时间(可能存在硬件影响)</li>
</ul>
<p>要小心使用,适合于较小的操作</p>
<h2 id="方法2-基于软件的解决方案"><a href="#方法2-基于软件的解决方案" class="headerlink" title="方法2:基于软件的解决方案"></a>方法2:基于软件的解决方案</h2><p>满足进程Pi和Pj之间互斥的经典的基于软件的解决方法(1981年)</p>
<p>使用两个共享数据项</p>
<ul>
<li>int turn; &#x2F;&#x2F;指示该谁进入临界区</li>
<li>bool flag[]; &#x2F;&#x2F;指示进程是否准备好进入临界区</li>
</ul>
<p>进入临界区:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag[i] = true;</span><br><span class="line">turn = j;</span><br><span class="line">while(flag[j] &amp;&amp; turn == j);</span><br></pre></td></tr></table></figure>

<p>退出临界区:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag[i] = false;</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	flag[i] = true;</span><br><span class="line">	turn = j;</span><br><span class="line">	while(flag[j] &amp;&amp; turn == j);</span><br><span class="line">	CRITICAL SECTION</span><br><span class="line">	flag[i] = false;</span><br><span class="line">	REMAINDER SECTION</span><br><span class="line">&#125;while(true);</span><br></pre></td></tr></table></figure>

<p>Bakery 算法(N个进程的临界区)</p>
<ul>
<li>进入临界区之前,进程接收一个数字</li>
<li>得到的数字最小的进入临界区</li>
<li>如果进程Pi和Pj收到相同的数字,那么如果i&lt;j,Pi先进入临界区,否则Pj先进入临界区</li>
<li>编号方案总是按照枚举的增加顺序生成数字</li>
</ul>
<p>Dekker算法(1965): 第一个针对双线程例子的正确解决方案</p>
<p>Bakery算法(1979): 针对n线程的临界区问题解决方案</p>
<p>复杂: 需要两个进程的共享数据项</p>
<p>需要忙等待: 浪费CPU时间</p>
<p>没有硬件保证的情况下无真正的软件解决方案: Perterson算法需要原子的LOAD和STORE指令</p>
<h2 id="方法3-更高级的抽象"><a href="#方法3-更高级的抽象" class="headerlink" title="方法3:更高级的抽象"></a>方法3:更高级的抽象</h2><p>硬件提供了一些原语</p>
<ul>
<li>像中断禁用, 原子操作指令等</li>
<li>大多数现代体系结构都这样</li>
</ul>
<p>操作系统提供更高级的编程抽象来简化并行编程</p>
<ul>
<li>例如,锁,信号量</li>
<li>从硬件原语中构建</li>
</ul>
<p>锁是一个抽象的数据结构</p>
<ul>
<li>一个二进制状态(锁定,解锁),两种方法</li>
<li>Lock::Acquire() 锁被释放前一直等待,然后得到锁</li>
<li>Lock::Release() 锁释放,唤醒任何等待的进程</li>
</ul>
<p>使用锁来编写临界区</p>
<ul>
<li><p>前面的例子变得简单起来:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock_next_pid-&gt;Acquire();</span><br><span class="line">new_pid = next_pid++;</span><br><span class="line">lock_next_pid-&gt;Release();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>大多数现代体系结构都提供特殊的原子操作指令</p>
<ul>
<li>通过特殊的内存访问电路</li>
<li>针对单处理器和多处理器</li>
</ul>
<p>Test-and-Set 测试和置位</p>
<ul>
<li>从内存中读取值</li>
<li>测试该值是否为1(然后返回真或假)</li>
<li>内存值设置为1</li>
</ul>
<p>交换</p>
<ul>
<li>交换内存中的两个值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool TestandSet(bool *target)&#123;</span><br><span class="line">		bool rv = *target;</span><br><span class="line">		*target = true;</span><br><span class="line">		return rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Exchange(bool *a, bool *b)&#123;</span><br><span class="line">		bool tmp = *a;</span><br><span class="line">		*a = *b;</span><br><span class="line">		*b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>总结</p>
<p>锁是更高等级的编程抽象</p>
<ul>
<li>互斥可以使用锁来实现</li>
<li>通常需要一定等级的硬件支持</li>
</ul>
<p>常用的三种实现方法</p>
<ul>
<li>禁用中断(仅限于单处理器)</li>
<li>软件方法(复杂)</li>
<li>原子操作指令(单处理器或多处理器均可)</li>
</ul>
<p>可选的实现内容:</p>
<ul>
<li>有忙等待</li>
<li>无忙等待</li>
</ul>
</li>
</ul>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><blockquote>
<p>第十章的主要内容是：信号量和管程</p>
</blockquote>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量的抽象数据类型</p>
<ul>
<li>一个整形(sem),具有两个原子操作</li>
<li>P(): sem减一,如果sem&lt;0,等待,否则继续</li>
<li>V(): sem加一,如果sem≤0,唤醒一个等待的P</li>
</ul>
<p>信号量是整数</p>
<p>信号量是被保护的变量</p>
<ul>
<li>初始化完成后,唯一改变一个信号量的值的办法是通过P()和V()</li>
<li>操作必须是原子</li>
</ul>
<p>P()能够阻塞,V()不会阻塞</p>
<p>我们假定信号量是公平的</p>
<ul>
<li>没有线程被阻塞在P()仍然堵塞如果V()被无限频繁调用(在同一个信号量)</li>
<li>在实践中,FIFO经常被使用</li>
</ul>
<p>两个类型信号量</p>
<ul>
<li>二进制信号量: 可以是0或1</li>
<li>计数信号量: 可以取任何非负数</li>
<li>两者相互表现(给定一个可以实现另一个)</li>
</ul>
<p>信号量可以用在2个方面</p>
<ul>
<li>互斥</li>
<li>条件同步(调度约束——一个线程等待另一个线程的事情发生)</li>
</ul>
<h2 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h2><ol>
<li><p>用二进制信号量实现的互斥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutex = new Semaphore(1);</span><br><span class="line"></span><br><span class="line">mutex-&gt;P();</span><br><span class="line">...</span><br><span class="line">mutex-&gt;V();</span><br></pre></td></tr></table></figure>
</li>
<li><p>用二进制信号量实现的调度约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">condition = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">//Thread A</span><br><span class="line">...</span><br><span class="line">condition-&gt;P(); //等待线程B某一些指令完成之后再继续运行,在此阻塞</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//Thread B</span><br><span class="line">...</span><br><span class="line">condition-&gt;V(); //信号量增加唤醒线程A</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个线程等待另一个线程处理事情</p>
<p>比如生产东西或消费东西(生产者消费者模式),互斥(锁机制)是不够的</p>
<p>有界缓冲区的生产者-消费者问题</p>
<ul>
<li>一个或者多个生产者产生数据将数据放在一个缓冲区里</li>
<li>单个消费者每次从缓冲区取出数据</li>
<li>在任何一个时间只有一个生产者或消费者可以访问该缓冲区</li>
</ul>
<p>正确性要求</p>
<ul>
<li>在任何一个时间只能有一个线程操作缓冲区(互斥)</li>
<li>当缓冲区为空时,消费者必须等待生产者(调度,同步约束)</li>
<li>当缓存区满,生产者必须等待消费者(调度,同步约束)</li>
</ul>
<p>每个约束用一个单独的信号量</p>
<ul>
<li>二进制信号量互斥</li>
<li>一般信号量 fullBuffers</li>
<li>一般信号了 emptyBuffers</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BoundedBuffer&#123;</span><br><span class="line">		mutex = new Semaphore(1);</span><br><span class="line">		fullBuffers = new Semaphore(0);   //说明缓冲区初始为空</span><br><span class="line"> 		emptyBuffers = new Semaphore(n);  //同时可以有n个生产者来生产</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c)&#123;</span><br><span class="line">		emptyBuffers-&gt;P();</span><br><span class="line">		mutex-&gt;P();</span><br><span class="line">		Add c to the buffer;</span><br><span class="line">		mutex-&gt;V();</span><br><span class="line">		fullBuffers-&gt;V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c)&#123;</span><br><span class="line">		fullBuffers-&gt;P();</span><br><span class="line">		mutex-&gt;P();</span><br><span class="line">		Remove c from buffer;</span><br><span class="line">		mutex-&gt;V();</span><br><span class="line">		emptyBuffers-&gt;V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h2><p>使用硬件原语</p>
<ul>
<li>禁用中断</li>
<li>原子指令</li>
</ul>
<p>类似锁</p>
<ul>
<li>禁用中断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Semaphore&#123;</span><br><span class="line">		int sem;</span><br><span class="line">		WaitQueue q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">		--sem;</span><br><span class="line">		if(sem &lt; 0)&#123;</span><br><span class="line">				Add this thread t to q;</span><br><span class="line">				block(p);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">		++sem;</span><br><span class="line">		if(sem &lt;= 0)&#123;</span><br><span class="line">				Remove a thread t from q;</span><br><span class="line">				wakeup(t);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量的双用途</p>
<ul>
<li>互斥和条件同步</li>
<li>但等待条件是独立的互斥</li>
</ul>
<p>读,开发代码比较困难</p>
<ul>
<li>程序员必须非常精通信号量</li>
</ul>
<p>容易出错</p>
<ul>
<li>使用的信号量已经被另一个线程占用</li>
<li>忘记释放信号量</li>
</ul>
<p>不能够处理死锁问题</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>目的: 分离互斥和条件同步的关注</p>
<p>什么是管程</p>
<ul>
<li>一个锁: 指定临界区</li>
<li>0或者多个条件变量: 等待,通知信号量用于管程并发访问共享数据</li>
</ul>
<p>一般方法</p>
<ul>
<li>收集在对象,模块中的相关共享数据</li>
<li>定义方法来访问共享数据</li>
</ul>
<p>Lock</p>
<ul>
<li>Lock::Acquire() 等待直到锁可用,然后抢占锁</li>
<li>Lock::Release() 释放锁,唤醒等待者如果有</li>
</ul>
<p>Condition Variable</p>
<ul>
<li>允许等待状态进入临界区<ul>
<li>允许处于等待(睡眠)的线程进入临界区</li>
<li>某个时刻原子释放锁进入睡眠</li>
</ul>
</li>
<li>Wait() operation<ul>
<li>释放锁,睡眠,重新获得锁放回</li>
</ul>
</li>
<li>Signal() operation(or broadcast() operation)<ul>
<li>唤醒等待者(或者所有等待者),如果有</li>
</ul>
</li>
</ul>
<p>实现</p>
<ul>
<li>需要维持每个条件队列</li>
<li>线程等待的条件等待signal()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Condition&#123;</span><br><span class="line">		int numWaiting = 0;</span><br><span class="line">		WaitQueue q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Condition::Wait(lock)&#123;</span><br><span class="line">		numWaiting++;</span><br><span class="line">		Add this thread t to q;</span><br><span class="line">		release(lock);</span><br><span class="line">		schedule(); //need mutex</span><br><span class="line">		require(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::Signal()&#123;</span><br><span class="line">		if(numWaiting &gt; 0)&#123;</span><br><span class="line">				Remove a thread t from q;</span><br><span class="line">				wakeup(t); //need mutex</span><br><span class="line">				numWaiting--;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管程解决生产者-消费者问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BoundedBuffer&#123;</span><br><span class="line">		Lock lock;</span><br><span class="line">		int count = 0;  //buffer 为空</span><br><span class="line">		Condition notFull, notEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c)&#123;</span><br><span class="line">		lock-&gt;Acquire();    //管程的定义:只有一个线程能够进入管程</span><br><span class="line">		while(count == n)</span><br><span class="line">				notFull.Wait(&amp;lock); //释放前面的锁</span><br><span class="line">		Add c to the buffer;</span><br><span class="line">		count++;</span><br><span class="line">		notEmpty.Signal();</span><br><span class="line">		lock-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c)&#123;</span><br><span class="line">		lock-&gt;Acquire();</span><br><span class="line">		while(count == 0)</span><br><span class="line">				notEmpty.Wait(&amp;lock);</span><br><span class="line">		Remove c from buffer;</span><br><span class="line">		count--;</span><br><span class="line">		notFull.Signal();</span><br><span class="line">		lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发,调试并行程序很难</p>
<ul>
<li>非确定性的交叉指令</li>
</ul>
<p>同步结构</p>
<ul>
<li>锁: 互斥</li>
<li>条件变量: 有条件的同步</li>
<li>其他原语: 信号量</li>
</ul>
<p>怎么样有效地使用这些结构</p>
<ul>
<li>制定并遵循严格的程序设计风格,策略</li>
</ul>
<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ol>
<li><p>读者-写者问题</p>
<p>动机: 共享数据的访问</p>
<p>两种类型的使用者: 读者(不修改数据) 写者(读取和修改数据)</p>
<p>问题的约束:</p>
<ul>
<li>允许同一时间有多个读者,但在任何时候只有一个写者</li>
<li>当没有写者时,读者才能访问数据</li>
<li>当没有读者和写者时,写者才能访问数据</li>
<li>在任何时候只能有一个线程可以操作共享变量</li>
</ul>
<p>多个并发进程的数据集共享</p>
<ul>
<li>读者: 只读数据集;他们不执行任何更新</li>
<li>写者: 可以读取和写入</li>
</ul>
<p>共享数据</p>
<ul>
<li>数据集</li>
<li>信号量CountMutex初始化为1</li>
<li>信号量WriteMutex初始化为1</li>
<li>整数Rcount初始化为0(当前读者个数)</li>
</ul>
<p>读者优先设计</p>
<p>只要有一个读者处于活动状态, 后来的读者都会被接纳.如果读者源源不断的出现,那么写者使用处于阻塞状态.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//信号量实现</span><br><span class="line">//writer</span><br><span class="line">sem_wait(WriteMutex);</span><br><span class="line">write;</span><br><span class="line">sem_post(WriteMutex);</span><br><span class="line"></span><br><span class="line">//reader</span><br><span class="line">sem_wait(CountMutex);</span><br><span class="line">if(Rcount == 0)</span><br><span class="line">		sem_wait(WriteMutex); //确保后续不会有写者进入</span><br><span class="line">++Rcount;</span><br><span class="line">read;</span><br><span class="line">--Rcount;</span><br><span class="line">if(Rcount == 0)</span><br><span class="line">		sem_post(WriteMutex); //全部读者全部离开才能唤醒写者</span><br><span class="line">sem_post(CountMutex);</span><br></pre></td></tr></table></figure>

<p>写者优先设计</p>
<p>一旦写者就绪,那么写者会尽可能的执行写操作.如果写者源源不断的出现的话,那么读者就始终处于阻塞状态.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//writer</span><br><span class="line">Database::Write()&#123;</span><br><span class="line">		Wait until readers/writers;</span><br><span class="line">		write database;</span><br><span class="line">		check out - wake up waiting readers/writers;</span><br><span class="line">&#125;</span><br><span class="line">//reader</span><br><span class="line">Database::Read()&#123;</span><br><span class="line">		Wait until no writers;</span><br><span class="line">		read database;</span><br><span class="line">		check out - wake up waiting writers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//管程实现</span><br><span class="line">AR = 0; // # of active readers</span><br><span class="line">AW = 0; // # of active writers</span><br><span class="line">WR = 0; // # of waiting readers</span><br><span class="line">WW = 0; // # of waiting writers</span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br><span class="line">Lock lock;</span><br><span class="line">//writer</span><br><span class="line">Public Database::Write()&#123;</span><br><span class="line">		//Wait until no readers/writers;</span><br><span class="line">		StartWrite();</span><br><span class="line">		write database;</span><br><span class="line">		//check out - wake up waiting readers/writers;</span><br><span class="line">		DoneWrite();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::StartWrite()&#123;</span><br><span class="line">		lock.Acquire();</span><br><span class="line">		while((AW + AR) &gt; 0)&#123;</span><br><span class="line">				WW++;</span><br><span class="line">				okToWrite.wait(&amp;lock);</span><br><span class="line">				WW--;		</span><br><span class="line">		&#125;</span><br><span class="line">		AW++;</span><br><span class="line">		lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::DoneWrite()&#123;</span><br><span class="line">		lock.Acquire();</span><br><span class="line">		AW--;</span><br><span class="line">		if(WW &gt; 0)&#123;</span><br><span class="line">				okToWrite.signal();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(WR &gt; 0)&#123;</span><br><span class="line">				okToRead.broadcast(); //唤醒所有reader </span><br><span class="line">		&#125;</span><br><span class="line">		lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reader</span><br><span class="line">Public Database::Read()&#123;</span><br><span class="line">		//Wait until no writers;</span><br><span class="line">		StartRead();</span><br><span class="line">		read database;</span><br><span class="line">		//check out - wake up waiting writers;</span><br><span class="line">		DoneRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::StartRead()&#123;</span><br><span class="line">		lock.Acquire();</span><br><span class="line">		while(AW + WW &gt; 0)&#123;    //关注等待的writer,体现出写者优先</span><br><span class="line">				WR++;</span><br><span class="line">				okToRead.wait(&amp;lock);</span><br><span class="line">				WR--;</span><br><span class="line">		&#125;</span><br><span class="line">		AR++;</span><br><span class="line">		lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Database::DoneRead()&#123;</span><br><span class="line">		lock.Acquire();</span><br><span class="line">		AR--;</span><br><span class="line">		if(AR == 0 &amp;&amp; WW &gt; 0)&#123;  //只有读者全部没有了,才需要唤醒</span><br><span class="line">				okToWrite.signal();</span><br><span class="line">		&#125;</span><br><span class="line">		lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>哲学家就餐问题(学习自 <a href="http://github.com/cyc2018">github.com&#x2F;cyc2018</a>)</p>
<p>共享数据:</p>
<ul>
<li>Bowl of rice(data set)</li>
<li>Semaphone fork [5] initialized to 1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define N 5</span><br><span class="line">#define LEFT (i + N - 1) % N // 左邻居</span><br><span class="line">#define RIGHT (i + 1) % N    // 右邻居</span><br><span class="line">#define THINKING 0</span><br><span class="line">#define HUNGRY   1</span><br><span class="line">#define EATING   2</span><br><span class="line">typedef int semaphore;</span><br><span class="line">int state[N];                // 跟踪每个哲学家的状态</span><br><span class="line">semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span><br><span class="line">semaphore s[N];              // 每个哲学家一个信号量</span><br><span class="line"></span><br><span class="line">void philosopher(int i) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void take_two(int i) &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void put_two(i) &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void eat(int i) &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span><br><span class="line">void check(i) &#123;         </span><br><span class="line">    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><blockquote>
<p>第十一章的主要内容是：死锁和进程通信</p>
</blockquote>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源</p>
<p>示例:</p>
<ul>
<li>系统有2个磁带驱动器</li>
<li>P1和P2各有一个,都需要另外一个</li>
</ul>
<h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>资源类型R1,R2,..,Rm(CPU, memory space, IO devices)</p>
<p>每个资源类型Ri有Wi个实例.</p>
<p>每个进程使用资源如下:</p>
<ul>
<li>require,get ← free resource</li>
<li>use,hold ← requested,used resource</li>
<li>release ← free resource</li>
</ul>
<p>可重复使用的资源</p>
<ul>
<li>在一个时间只能有一个进程使用且不能被删除</li>
<li>进程获得资源,后来释放由其他进程重用</li>
<li>处理器,IO通道,主和副存储器,设备和数据结构,如文件,数据库和信号量</li>
<li>如果每个进程拥有一个资源并请求其他资源,死锁可能发生</li>
</ul>
<p>使用资源</p>
<ul>
<li>创建和销毁</li>
<li>在IO缓存区的中断,信号,消息,信息</li>
<li>如果接收消息阻塞可能会发生死锁</li>
<li>可能少见的组合事件会引起死锁</li>
</ul>
<p>资源分配图</p>
<p>一组顶点V和边E的集合</p>
<ul>
<li>V有两种类型:<ul>
<li>P&#x3D;{P1,P2,…,Pn},集合包括系统中的所有进程</li>
<li>R&#x3D;{R1,R2,…,Rm},集合包括系统中的所有资源类型</li>
</ul>
</li>
<li>requesting,claiming edge - directed edge Pi → Rj</li>
<li>assignment,holding edge - directed edge Rj → Pi</li>
</ul>
<p>基本情况</p>
<p>如果图中不包含循环:</p>
<ul>
<li>没有死锁</li>
</ul>
<p>如果图中包含循环:</p>
<ul>
<li>如果每个资源类只有一个实例,那么死锁</li>
<li>如果每个资源类有几个实例,可能死锁</li>
</ul>
<h2 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h2><p>死锁出现一定会出现以下四个条件,但是出现以下四个条件不一定死锁:</p>
<ul>
<li>互斥: 在一个时间只能有一个进程使用资源</li>
<li>持有并等待: 进程保持至少一个资源正在等待获取其他进程持有的额外资源</li>
<li>无抢占: 一个资源只能被进程资源释放,进程已经完成了它的任务之后</li>
<li>循环等待: 存在等待进程集合{P0,P1,…,Pn},P0正在等待P1所占用的资源,P1正在等待P2占用的资源…Pn-1在等待Pn的资源,Pn正在等待P0所占用的资源</li>
</ul>
<h2 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h2><p>常见方法</p>
<ul>
<li>确保系统永远不会进入死锁状态</li>
<li>运行系统进入死锁状态,然后恢复.</li>
<li>忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统,包括UNIX</li>
</ul>
<h3 id="Deadlock-Prevention-预防"><a href="#Deadlock-Prevention-预防" class="headerlink" title="Deadlock Prevention 预防"></a>Deadlock Prevention 预防</h3><p>限制申请方式</p>
<ul>
<li>互斥 - 共享资源不是必须的,必须占用非共享资源</li>
<li>占用并等待 - 必须保证当一个进程请求的资源,它不持有任何其他资源<ul>
<li>需要进程请求并分配其所有资源,它开始执行之前或允许进程请求资源仅当进程没有资源</li>
<li>资源利用率低,可能发生饥饿</li>
</ul>
</li>
<li>无抢占 -<ul>
<li>如果进程占有某些资源,并请求其他不能被立即分配的资源,则释放当前正占有的资源</li>
<li>被抢占资源添加到资源列表中</li>
<li>只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行</li>
</ul>
</li>
<li>循环等待 - 对所有资源类型进行排序,并要求每个进程按照资源的顺序进行申请</li>
</ul>
<h3 id="Deadlock-Avoidance-避免"><a href="#Deadlock-Avoidance-避免" class="headerlink" title="Deadlock Avoidance 避免"></a>Deadlock Avoidance 避免</h3><p>需要系统具有一些额外的先验信息提供</p>
<ul>
<li>最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目</li>
<li>资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求</li>
<li>死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态</li>
<li>当一个进程请求可用资源,系统必须判断立即分配是否能使系统处于安全状态</li>
<li>系统处于安全状态指: 针对所有进程,存在安全序列</li>
<li>序列&lt;P1,P2,…,Pn&gt;是安全的: 针对每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,其中j&lt;i.<ul>
<li>如果Pi资源的需求不是立即可用,那么Pi可以等到所有Pj完成</li>
<li>当Pi完成后,Pi+1可以得到所需要的资源,执行,返回所分配的资源,并终止.</li>
<li>用同样的方法,Pi+2,Pi+3和Pn能获得其所需的资源.</li>
</ul>
</li>
<li>如果系统处于安全状态→无死锁</li>
<li>如果系统处于不安全状态→可能死锁</li>
<li>避免死锁: 确保系统永远不会进入不安全状态</li>
</ul>
<h3 id="Deadlock-Detection-检测"><a href="#Deadlock-Detection-检测" class="headerlink" title="Deadlock Detection 检测"></a>Deadlock Detection 检测</h3><p>每个资源类型单一实例</p>
<p>Maintain wait-for graph</p>
<ul>
<li>节点是进程</li>
<li>Pi→Pj: Pi等待Pj</li>
</ul>
<p>定期调用检测算法来搜索图中是否存在循环</p>
<p>算法需要n^2次操作,n是图中顶点的数目</p>
<p>数据结构:</p>
<ul>
<li>Available: 长度为M的向量表示每种类型可用资源的数量</li>
<li>Allocation: 一个nxm矩阵定义了当前分配给各个进程每种类型资源的数量,如果Alocation[i, j] &#x3D; k, 进程Pi拥有资源Rj的k个实例</li>
<li>Request: 一个nxm矩阵表示各进程的当前请求.如果Request[i, j] &#x3D; k,表示进程Pi请求k个资源Pj的实例</li>
</ul>
<p>具体算法(跳过了,看视频)</p>
<p>检查算法使用</p>
<p>何时,使用什么样的频率来检测依赖于:</p>
<ul>
<li>死锁多久可能会发生?</li>
<li>多少进程需要被回滚? one for each disjoint cycle</li>
</ul>
<p>如果检测算法多次被调用,有可能是资源图有多个循环,所以我们无法分辨出多个可能死锁进程中的哪些”造成”死锁</p>
<h3 id="Recovery-from-Deadlock-恢复"><a href="#Recovery-from-Deadlock-恢复" class="headerlink" title="Recovery from Deadlock 恢复"></a>Recovery from Deadlock 恢复</h3><p>终止所有的死锁进程</p>
<p>在一个时间内终止一个进程直到死锁消除</p>
<p>终止进程的顺序应该是:</p>
<ul>
<li>进程的优先级</li>
<li>进程运行了多久以及需要多少时间才能完成</li>
<li>进程占用的资源</li>
<li>进程完成需要的资源</li>
<li>多少进程需要被终止</li>
<li>进程是交互还是批处理</li>
</ul>
<p>选择一个受孩子 - 最小的成本</p>
<p>回滚 - 返回到一些安全状态,重启进程到安全状态</p>
<p>饥饿 - 同一进程可能一直被选作受害者,包括回滚的数量</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程通信的机制及同步</p>
<p>不使用共享变量的进程通信</p>
<p>IPC facility 提供2个操作:</p>
<ul>
<li>send(message) - 消息大小固定或者可变</li>
<li>receive(message)</li>
</ul>
<p>如果P和Q想通信,需要:</p>
<ul>
<li>在它们之间建立通信链路</li>
<li>通过send&#x2F;recevie交换消息</li>
</ul>
<p>通信链路的实现</p>
<ul>
<li>物理(例如,共享内存,硬件总线)</li>
<li>逻辑(例如,逻辑属性)</li>
</ul>
<h3 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h3><p>进程必须正确的命名对方:</p>
<ul>
<li>send(P, message) - 发送消息到进程P</li>
<li>receive(Q, message) - 从进程Q接收信息</li>
</ul>
<p>通信链路的属性</p>
<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链路存在</li>
<li>链路可以是单向的,但通常是双向的</li>
</ul>
<h3 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h3><p>定向从消息队列接收消息</p>
<ul>
<li>每个消息对垒都有一个唯一的ID</li>
<li>只有它们共享了一个消息队列,进程才能够通信</li>
</ul>
<p>通信链路的属性</p>
<ul>
<li>只有进程共享一个共同的消息队列,才建立链路</li>
<li>链接可以与许多进程相关联</li>
<li>每对进程可以共享多个通信链路</li>
<li>链接可以是单向或者双向</li>
</ul>
<p>操作</p>
<ul>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接收消息</li>
<li>销毁消息队列</li>
</ul>
<p>原语的定义如下:</p>
<ul>
<li><p>send(A, message)</p>
</li>
<li><p>receive(A, message)</p>
</li>
<li><p>通信链路缓冲</p>
<p>通信链路缓存大小:</p>
<ol>
<li>0容量 - 0 message : 发送方必须等待接收方</li>
<li>有限容量 - n messages的有限长度 : 发送方必须等待,如果队列满</li>
<li>无限容量 - 无限长度 : 发送方不需要等待</li>
</ol>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号Signal</p>
<ul>
<li>软件中断通知事件处理</li>
<li>Examples: SIGFPE, SIGKILL, SIGUSRI, SIGSTOP, SIGCONT</li>
</ul>
<p>接收到信号时会发生什么?</p>
<ul>
<li>catch: 指定信号处理函数被调用</li>
<li>ignore: 依靠操作系统的默认操作(abort, memory dump, suspend or resume process)</li>
<li>mask: 闭塞信号因此不会传送(可能是暂时的,当处理同样类型的信号)</li>
</ul>
<p>不足:</p>
<ul>
<li>不能传输要交换的任何数据</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>数据交换</p>
<p>子进程从父进程继承文件描述符(0 stdin, 1 stdout, 2 stderr)</p>
<p>进程不知道(或不关心)从键盘,文件,程序读取或写入到终端,文件,程序.</p>
<p>例如: $ ls | more (两个进程, 管道是缓存,对于ls来说是stdout,对于more来说是stdin )</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列按FIFO来管理消息</p>
<ul>
<li>message: 作为一个字节序列存储</li>
<li>message queues: 消息数组</li>
<li>FIFO &amp; FILO configuration</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>进程</p>
<ul>
<li>每个进程都有私有地址空间</li>
<li>在每个地址空间内,明确地设置了共享内存段</li>
</ul>
<p>优点</p>
<ul>
<li>快速,方便地共享数据</li>
</ul>
<p>不足</p>
<ul>
<li>必须同步数据访问</li>
</ul>
<p>最快的方法</p>
<p>一个进程写另一个进程立即可见</p>
<p>没有系统调用干预</p>
<p>没有数据复制</p>
<p>不提供同步</p>
<ul>
<li>Socket</li>
</ul>
<h1 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h1><blockquote>
<p>第十二章的主要内容是：文件管理</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h3><p>文件系统: 一种用于持久性存储的系统抽象</p>
<ul>
<li>在存储上: 组织,控制,导航,访问和检索数据</li>
<li>在大多数计算机系统包含文件系统</li>
<li>个人电脑,服务器,笔记本电脑</li>
<li>ipod,tivo,机顶盒,手机,电脑</li>
<li>google可能也是由一个文件系统构成的</li>
</ul>
<p>文件: 文件系统中的一个单元的相关数据在操作系统中的抽象</p>
<p>文件系统的功能:</p>
<ul>
<li>分配文件磁盘空间<ul>
<li>管理文件块(哪一块属于哪一个文件)</li>
<li>管理空闲空间(哪一块是空闲的)</li>
<li>分配算法(策略)</li>
</ul>
</li>
<li>管理文件集合<ul>
<li>定位文件及其内容</li>
<li>命名: 通过名字找到文件的接口</li>
<li>最常见: 分层文件系统</li>
<li>文件系统类型(组织文件的不同方式)</li>
</ul>
</li>
<li>提供的便利及特征<ul>
<li>保护: 分层来保护数据安全</li>
<li>可靠性,持久性: 保持文件的持久即使发生崩溃,媒体错误,攻击等</li>
</ul>
</li>
</ul>
<p>文件和块:</p>
<p>文件属性: 名称,类型,位置,大小,保护,创建者,创建时间,最久修改时间…</p>
<p>文件头: 在存储元数据中保存了每个文件的信息,保存文件的属性,跟踪哪一块存储块属于逻辑上文件结构的哪个偏移</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件使用模式:</p>
<p>使用程序必须在使用前先”打开”文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(name, flag);</span><br><span class="line">...</span><br><span class="line">... = read(f, ...);</span><br><span class="line">...</span><br><span class="line">close(f);</span><br></pre></td></tr></table></figure>

<p>内核跟踪每个进程打开的文件:</p>
<ul>
<li>操作系统为每个进程维护一个打开文件表</li>
<li>一个打开文件描述符是这个表中的索引</li>
</ul>
<p>需要元数据来管理打开文件:</p>
<p>文件指针: 指向最近的一次读写位置,每个打开了这个文件的进程都这个指针</p>
<p>文件打开计数: 记录文件打开的次数 - 当最后一个进程关闭了文件时,允许将其从打开文件表中移除</p>
<p>文件磁盘位置: 缓存数据访问信息</p>
<p>访问权限: 每个程序访问模式信息</p>
<p>用户视图: 持久的数据结构</p>
<p>系统访问接口:</p>
<p>字节的集合(UNIX)</p>
<p>系统不会关心你想存储在磁盘上的任何的数据结构</p>
<p>操作系统内部视角:</p>
<p>块的集合(块是逻辑转换单元,而扇区是物理转换单元)</p>
<p>块大小&lt;&gt; 扇区大小: 在UNIX中, 块的大小是 4KB</p>
<p>当用户说: 给我2-12字节空间时会发生什么?</p>
<p>获取字节所在的快</p>
<p>返回快内对应部分</p>
<p>如果要写2-12字节?</p>
<p>获取块</p>
<p>修改块内对应部分</p>
<p>写回块</p>
<p>在文件系统中的所有操作都是在整个块空间上进行的: <code>getc()</code> <code>putc()</code> 即使每次只访问1字节的数据,也会缓存目标数据4096字节(一个磁盘块)</p>
<p>用户怎么访问文件: 在系统层面需要知道用户的访问模式</p>
<p>顺序访问: 按字节依次读取(几乎所有的访问都是这种方式)</p>
<p>随机访问: 从中间读写(不常用,但是仍然重要,如: 虚拟内存支持文件,内存页存储在文件中;更加快速,不希望获取文件中间的内容的时候也必须先获取块内所有字节)</p>
<p>内容访问: 通过特征</p>
<p>文件内部结构:</p>
<p>无结构: 单词,比特的队列</p>
<p>简单记录结构: 列,固定长度,可变长度</p>
<p>复杂结构: 格式化的文档(word, PDF), 可执行文件, …</p>
<p>多用户系统中的文件共享是很必要的</p>
<p>访问控制:</p>
<p>谁能够获得哪些文件的哪些访问权限</p>
<p>访问模式: 读,写,执行,删除,列举等</p>
<p>文件访问控制列表(ACL):</p>
<p>&lt;文件实体, 权限&gt;</p>
<p>UNIX模式:</p>
<p>&lt;用户|组|所有人,读|写|可执行&gt;</p>
<p>用户ID识别用户,表明每个用户所允许的权限及保护模式</p>
<p>组ID允许用户组成组,并指定了组访问权限</p>
<p>指定多用户,客户如何同时访问共享文件:</p>
<p>和过程同步算法相似</p>
<p>因磁盘IO和网络延迟而设计简单</p>
<p>UNIX文件系统(UFS)语义:</p>
<p>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</p>
<p>共享文件指针允许多用户同时读取和写入文件</p>
<p>会话语义:</p>
<p>写入内容只有当文件关闭时可见</p>
<p>锁:</p>
<p>一些操作系统和文件系统提供该功能</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>文件以目录的方式组织起来</p>
<p>目录是一类特殊的文件: 每个目录都包含了一张表&lt;name, pointer to file header&gt;</p>
<p>目录和文件的树形结构: 早期的文件系统是扁平的(只有一层目录)</p>
<p>层次名称空间: &#x2F;spell&#x2F;mail&#x2F;prt&#x2F;first &#x2F;programs&#x2F;p&#x2F;list</p>
<p>典型操作:</p>
<p>搜索文件</p>
<p>创建文件</p>
<p>删除文件</p>
<p>枚举目录</p>
<p>重命名文件</p>
<p>在文件系统中遍历一个路径</p>
<p>操作系统应该只允许内核模式修改目录: 确保映射的完整性,应用程序能够读目录(ls)</p>
<p>文件名的线性列表,包含了指向数据块的指针: 编程简单,执行耗时</p>
<p>Hash表 - hash数据结构的线性表: 减少目录搜索时间,碰撞,固定大小</p>
<p>名字解析: 逻辑名字转换成物理资源(如文件)的过程:</p>
<p>在文件系统中: 到实际文件的文件名(路径)</p>
<p>遍历文件目录直到找到目标文件</p>
<p>举例: 解析”&#x2F;bin&#x2F;ls”:</p>
<p>读取root的文件头(在磁盘固定位置)</p>
<p>读取root的数据块: 搜索bin项</p>
<p>读取bin的文件头</p>
<p>读取bin的数据块: 搜索ls项</p>
<p>读取ls的文件头</p>
<p>当前工作目录:</p>
<p>每个进程都会指向一个文件目录用于解析文件名</p>
<p>允许用户指定相对路径来代替绝对路径</p>
<p>一个文件系统需要先挂载才能被访问</p>
<p>一个未挂载的文件系统被挂载在挂载点上</p>
<h3 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h3><p>两个或多个文件名关联同一个文件:</p>
<p>硬链接: 多个文件项指向一个文件</p>
<p>软链接: 以快捷方式指向其他文件</p>
<p>通过存储真实文件的逻辑名称来实现</p>
<p>如果删除一个有别名的文件会如何呢? : 这个别名将成为一个悬空指针</p>
<p>Backpointers 方案:</p>
<p>每个文件有一个包含多个backpointers的列表,所以删除所有的Backpointers</p>
<p>backpointers使用菊花链管理</p>
<p>添加一个间接层: 目录项数据结构</p>
<p>链接: 已存在文件的另外一个名字(指针)</p>
<p>链接处理: 跟随指针来定位文件</p>
<p>我们如何保证没有循环呢?</p>
<p>只允许到文件的链接, 不允许在子目录的链接</p>
<p>每增加一个新的链接都用循环检测算法确定是否合理</p>
<p>限制路径可遍历文件目录的数量</p>
<h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><p>磁盘文件系统: 文件存储在数据存储设备上,如磁盘; 例如: FAT,NTFS,ext2,3,ISO9660等</p>
<p>数据库文件系统: 文件根据其特征是可被寻址的; 例如: WinFS</p>
<p>日志文件系统: 记录文件系统的修改,事件; 例如: journaling file system</p>
<p>网络,分布式文件系统: 例如: NFS,SMB,AFS,GFS</p>
<p>特殊,虚拟文件系统</p>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>分层结构:</p>
<p>顶层: 文件,文件系统API</p>
<p>上层: 虚拟(逻辑)文件系统 (将所有设备IO,网络IO全抽象成为文件,使得接口一致)</p>
<p>底层: 特定文件系统模块</p>
<p>目的: 对所有不同文件系统的抽象</p>
<p>功能:</p>
<p>提供相同的文件和文件系统接口</p>
<p>管理所有文件和文件系统关联的数据结构</p>
<p>高效查询例程,遍历文件系统</p>
<p>与特定文件系统模块的交互</p>
<p>数据结构:</p>
<p>卷[第四声]控制块(UNIX: “superblock”)</p>
<p>每个文件系统一个</p>
<p>文件系统详细信息</p>
<p>块,块大小,空余块,计数,指针等</p>
<p>文件控制块(UNIX: “vnode” or “inode”)</p>
<p>每个文件一个</p>
<p>文件详细信息</p>
<p>许可,拥有者,大小,数据库位置等</p>
<p>目录节点(Linux: “dentry”)</p>
<p>每个目录项一个(目录和文件)</p>
<p>将目录项数据结构及树形布局编码成树形数据结构</p>
<p>指向文件控制块,父节点,项目列表等</p>
<p>其中: 卷控制块(每个文件系统一个),文件控制块(每个文件一个),目录节点(每个目录项一个)</p>
<p>持续存储在二级存储中: 在分配在存储设备中的数据块中</p>
<p>当需要时加载进内存:</p>
<p>卷控制块: 当文件系统挂载时进入内存</p>
<p>文件控制块: 当文件被访问时进入内存</p>
<p>目录节点: 在遍历一个文件路径时进入内存</p>
<h2 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h2><p>数据块按需读入内存:</p>
<p>提供 <code>read()</code> 操作</p>
<p>预读: 预先读取后面的数据块</p>
<p>数据块使用后被缓存:</p>
<p>假设数据将会再次被使用</p>
<p>写操作可能被缓存和延迟写入</p>
<p>两种数据块缓存方式:</p>
<p>普通缓冲区缓存</p>
<p>页缓存: 同一缓存数据块和内存页</p>
<p>分页要求: 当需要一个页时才将其载入内存</p>
<p>支持存储: 一个页(在虚拟地址空间中)可以被映射到一个本地文件中(在二级存储中)</p>
<h2 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h2><p>打开文件描述:</p>
<p>每个被打开的文件一个</p>
<p>文件状态信息</p>
<p>目录项,当前文件指针,文件操作设置等</p>
<p>打开文件表:</p>
<p>一个进程一个</p>
<p>一个系统级的</p>
<p>每个卷控制块也会保存一个列表</p>
<p>所以如果有文件被打开将不能被卸载</p>
<p>一些操作系统和文件系统提供该功能</p>
<p>调节对文件的访问</p>
<p>强制和劝告:</p>
<p>强制 - 根据锁保持情况和需求拒绝访问</p>
<p>劝告 - 进程可以查找锁的状态来决定怎么做</p>
<h2 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h2><p>大多数文件都很小:</p>
<p>需要对小文件提供强力的支持</p>
<p>块空间不能太小</p>
<p>一些文件非常大:</p>
<p>必须支持大文件(64-bit 文件偏移)</p>
<p>大文件访问需要相当高效</p>
<p>如何为一个文件分配数据块</p>
<p>分配方式:</p>
<p>连续分配</p>
<p>链式分配</p>
<p>索引分配</p>
<p>指标:</p>
<p>高效: 如存储利用(外部碎片)</p>
<p>表现: 如访问速度</p>
<p>连续分配:</p>
<p>文件头指定起始块和长度</p>
<p>位置,分配策略: 最先匹配,最佳匹配,…</p>
<p>优势: 文件读取表现好;高效的顺序和随机访问</p>
<p>劣势: 碎片;文件增长问题</p>
<p>链式分配:</p>
<p>文件以数据块链表方式存储</p>
<p>文件头包含了到第一块和最后一块的指针</p>
<p>优势: 创建,增大,缩小很容易;没有碎片</p>
<p>劣势: 不可能进行真正的随机访问;可靠性</p>
<p>索引分配:</p>
<p>为每个文件创建一个名为索引数据块的非数据数据块(到文件数据块的指针列表)</p>
<p>文件头包含了索引数据块</p>
<p>优势: 创建,增大,缩小很容易;没有碎片;支持直接访问</p>
<p>劣势: 当文件很小时,存储索引的开销大;处理大文件难</p>
<h2 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h2><p>跟踪在存储中的所有未分配的数据块</p>
<p>空闲空间列表存储在哪里?</p>
<p>空闲空间列表的最佳数据结构怎么样?</p>
<p>用位图代表空闲数据块列表: 11111101101110111 如果 i &#x3D; 0表明数据块i是空闲的,反之是分配的</p>
<p>使用简单但是可能会是一个big vector:</p>
<p>160GB disk → 40M blocks → 5MB worth of bits</p>
<p>然而,如果空闲空间在磁盘中均匀分布,那么再找到”0”之前需要扫描 磁盘上数据块总数 &#x2F; 空闲块的数目</p>
<p>需要保护:</p>
<p>指向空闲列表的指针</p>
<p>位图:</p>
<p>必须保存在磁盘上;在内存和磁盘拷贝可能有所不同;不允许block[i]在内存中的状态为bit[i]&#x3D;1而在磁盘中bit[i]&#x3D;0</p>
<p>解决:</p>
<p>在磁盘上设置bit[i] &#x3D; 1; 分配block[i]; 在内存中设置bit[i] &#x3D; 1</p>
<h2 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理 - RAID"></a>多磁盘管理 - RAID</h2><p>通常磁盘通过分区来最大限度减小寻道时间:</p>
<p>一个分区是一个柱面的集合</p>
<p>每个分区都是逻辑上独立的磁盘</p>
<p>分区: 硬件磁盘的一种适合操作系统指定格式的划分</p>
<p>卷: 一个拥有一个文件系统实例的可访问的存储空间(通常常驻在磁盘的单个分区上)</p>
<p>使用多个并行磁盘来增加: 吞吐量(通过并行),可靠性和可用性(通过冗余)</p>
<p>RAID - 冗余磁盘阵列: 各种磁盘管理技术;RAID levels: 不同RAID分类,如RAID-0,RAID-1,RAID-5</p>
<p>实现: 在操作系统内核: 存储,卷管理; RAID硬件控制器(IO)</p>
<p>RAID-0</p>
<p>数据块分成多个子块, 存储在独立的磁盘中: 和内存交叉相似</p>
<p>通过更大的有效块大小来提供更大的磁盘带宽</p>
<p>RAID-1</p>
<p>可靠性成倍增长</p>
<p>读取性能线性增加(向两个磁盘写入,从任何一个读取)</p>
<p>RAID-4</p>
<p>数据块级磁带配有专用奇偶校验磁盘: 允许从任意一个故障磁盘中恢复</p>
<p>条带化和奇偶校验按byte-by-byte或者bit-by-bit: RAID-0,4,5: block-wise ;RAID-3: bit-wise</p>
<p>RAID-5</p>
<p>每个条带快有一个奇偶校验块,允许有一个磁盘错误</p>
<p>RAID-6</p>
<p>两个冗余块,有一种特殊的编码方式,允许两个磁盘错误</p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>读取或写入时,磁头必须被定位在期望的磁道,并从所期望的扇区开始</p>
<p>寻道时间: 定位到期望的磁道所花费的时间</p>
<p>旋转延迟: 从扇区的开始处到到达目的处花费的时间</p>
<p>平均旋转延迟时间 &#x3D; 磁盘旋转一周时间的一半</p>
<p>寻道时间是性能上区别的原因</p>
<p>对单个磁盘,会有一个IO请求数目</p>
<p>如果请求是随机的,那么会表现很差</p>
<p>FIFO:</p>
<p>按顺序处理请求</p>
<p>公平对待所有进程</p>
<p>在有很多进程的情况下,接近随机调度的性能</p>
<p>最短服务优先:</p>
<p>选择从磁臂当前位置需要移动最少的IO请求</p>
<p>总是选择最短寻道时间</p>
<p>skan:</p>
<p>磁臂在一个方向上移动,满足所有为完成的请求,直到磁臂到达该方向上最后的磁道</p>
<p>调换方向</p>
<p>c-skan:</p>
<p>限制了仅在一个方向上扫描</p>
<p>当最后一个磁道也被访问过了后,磁臂返回到磁盘的另外一端再次进行扫描</p>
<p>c-loop(c-skan改进):</p>
<p>磁臂先到达该方向上最后一个请求处,然后立即反转</p>
]]></content>
  </entry>
</search>
