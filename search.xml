<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown快速入门</title>
    <url>/2022/03/31/Markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1、代码块："><a href="#1、代码块：" class="headerlink" title="1、代码块："></a>1、代码块：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码块语法：</span></span><br><span class="line">​```java</span><br><span class="line">    </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

 <span id="more"></span> 

<p>1.java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.shell脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//linux下spring项目的启动命令</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">java -jar blog start</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2、标题："><a href="#2、标题：" class="headerlink" title="2、标题："></a>2、标题：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标题</span></span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加粗</span></span><br><span class="line">**等不到天黑**</span><br><span class="line"><span class="comment">//代码高亮</span></span><br><span class="line">==我不是罗迪==</span><br><span class="line"><span class="comment">//删除线</span></span><br><span class="line">~~被删除的文字~~</span><br><span class="line"><span class="comment">//斜体</span></span><br><span class="line">*斜体内容*    </span><br></pre></td></tr></table></figure>


<p><strong>等不到天黑</strong></p>
<p>&#x3D;&#x3D;我不是罗迪&#x3D;&#x3D;</p>
<p><del>被删除的文字</del></p>
<p><em>斜体内容</em></p>
<h2 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引用语法</span><br><span class="line">&gt;作者：叶仁平</span><br><span class="line">&gt;&gt;作者：叶仁平</span><br><span class="line">&gt;&gt;&gt;作者：叶仁平</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作者：叶仁平</p>
<blockquote>
<p>作者：叶仁平</p>
<blockquote>
<p>作者：叶仁平</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5、分割线"><a href="#5、分割线" class="headerlink" title="5、分割线"></a>5、分割线</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分割线1</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//分割线2</span></span><br><span class="line">***    </span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="6、图片插入"><a href="#6、图片插入" class="headerlink" title="6、图片插入"></a>6、图片插入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在线图片/本地图片</span><br><span class="line">![我的照片]()</span><br></pre></td></tr></table></figure>

<img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.DQcOipe7nLHVtSW3KQs6rQHaEo?pid=ImgDet&amp;rs=1" alt="我的照片" style="zoom:100%;" />

<h2 id="7、超链接"><a href="#7、超链接" class="headerlink" title="7、超链接"></a>7、超链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//超链接语法</span><br><span class="line">[我的github](https://github.com/Roddy11)</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/Roddy11">我的github</a></p>
<h2 id="8、列表语法"><a href="#8、列表语法" class="headerlink" title="8、列表语法"></a>8、列表语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//无序列表</span><br><span class="line">-目录1</span><br><span class="line">-目录2</span><br><span class="line">-目录3</span><br></pre></td></tr></table></figure>

<ul>
<li>目录1<ul>
<li>目录2<ul>
<li>目录3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h2><table>
<thead>
<tr>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>70</td>
<td>80</td>
<td>99</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="一、认识时间复杂度和简单排序算法"><a href="#一、认识时间复杂度和简单排序算法" class="headerlink" title="一、认识时间复杂度和简单排序算法"></a>一、认识时间复杂度和简单排序算法</h2><h3 id="1-认识时间复杂度"><a href="#1-认识时间复杂度" class="headerlink" title="1.认识时间复杂度"></a><strong>1.认识时间复杂度</strong></h3><p>一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。 </p>
<p>时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体 </p>
<p>来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作， </p>
<p>进而总结出常数操作数量的表达式。</p>
 <span id="more"></span> 

<p>在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那 </p>
<p>么时间复杂度为O(f(N))。 </p>
<p>评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行 </p>
<p>时间，也就是“常数项时间”。</p>
<h3 id="2-选择排序、冒泡排序细节的讲解与复杂度分析"><a href="#2-选择排序、冒泡排序细节的讲解与复杂度分析" class="headerlink" title="2.选择排序、冒泡排序细节的讲解与复杂度分析"></a><strong>2</strong>.<strong>选择排序、冒泡排序细节的讲解与复杂度分析</strong></h3><p>​    时间复杂度O(N^2)，额外空间复杂度O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组为空或者数组长度小于2！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-插入排序细节的讲解与复杂度分析"><a href="#3-插入排序细节的讲解与复杂度分析" class="headerlink" title="3.插入排序细节的讲解与复杂度分析"></a><strong>3.插入排序细节的讲解与复杂度分析</strong></h3><p>时间复杂度O(N^2)，额外空间复杂度O(1) </p>
<p>算法流程按照最差情况来估计时间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-二分法的详解与扩展"><a href="#4-二分法的详解与扩展" class="headerlink" title="4.二分法的详解与扩展"></a><strong>4.二分法的详解与扩展</strong></h3><p>​        1）在一个有序数组中，找某个数是否存在 </p>
<p>​        2）在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置 </p>
<p>​        3）局部最小值问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在一个有序数组中，找某个数是否存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; num) &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[L] == num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个有序数组中，找&gt;=某个数最左侧的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在arr上，找满足&gt;=value的最左位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nearestIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-异或运算的性质与扩展"><a href="#5-异或运算的性质与扩展" class="headerlink" title="5.异或运算的性质与扩展"></a><strong>5.异或运算的性质与扩展</strong></h3><p>   1）0^N &#x3D;&#x3D; N   N^N &#x3D;&#x3D; 0 </p>
<p>   2）异或运算满足交换律和结合率 </p>
<p>   3）不用额外变量交换两个数 </p>
<p>   4）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数 </p>
<p>   5）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor = eor ^ arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(eor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> curNum : arr) &#123;</span><br><span class="line">        eor1 ^= curNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor1 &amp; (~eor1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">            eor2 ^= cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(eor1 + <span class="string">&quot;  &quot;</span> + (eor1 ^ eor2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-对数器的概念和使用"><a href="#6-对数器的概念和使用" class="headerlink" title="6.对数器的概念和使用"></a><strong>6.对数器的概念和使用</strong></h3><p>​    1)，有一个你想要测的方法a </p>
<p>​    2)，实现复杂度不好但是容易实现的方法b </p>
<p>​    3)，实现一个随机样本产生器 </p>
<p>​    4)，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样 </p>
<p>​    5)，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b </p>
<p>​    6)，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</p>
<h3 id="7-剖析递归行为和递归行为时间复杂度的估算"><a href="#7-剖析递归行为和递归行为时间复杂度的估算" class="headerlink" title="7.剖析递归行为和递归行为时间复杂度的估算"></a>7.剖析递归行为和递归行为时间复杂度的估算</h3><pre><code> 用递归方法找一个数组中的最大值，系统上到底是怎么做的？ 
</code></pre>
<p>​    master公式的使用 </p>
<p>​    T(N) &#x3D; a*T(N&#x2F;b) + O(N^d) </p>
<p>​    1) log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a)) </p>
<p>​    2) log(b,a) &#x3D; d -&gt; 复杂度为O(N^d * logN) </p>
<p>​    3) log(b,a) &lt; d -&gt; 复杂度为O(N^d)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code06_GetMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123; <span class="comment">//arr[L...R]范围上只有一个数，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> arr[L];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + (R - L) &gt;&gt; <span class="number">1</span>;<span class="comment">//中点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> process(arr, L, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、认识O-NlogN-的排序"><a href="#二、认识O-NlogN-的排序" class="headerlink" title="二、认识O(NlogN)的排序"></a>二、认识O(NlogN)的排序</h2><h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1.归并排序"></a>1.归并排序</h3><p>​    1）整体就是一个简单递归，左边排好序、右边排好序、让其整体有序 </p>
<p>​    2）让其整体有序的过程里用了排外序方法 </p>
<p>​    3）利用master公式来求解时间复杂度 </p>
<p>​    4）归并排序的实质 </p>
<p>​    时间复杂度O(N*logN)，额外空间复杂度O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> _1.class02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_1_MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">33</span>, <span class="number">95</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(arr, l, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            help[i] = arr[p1];</span><br><span class="line">            i++;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">            help[i] = arr[p2];</span><br><span class="line">            i++;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">            arr[l + i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-归并排序的扩展"><a href="#2-归并排序的扩展" class="headerlink" title="2.归并排序的扩展"></a>2.归并排序的扩展</h3><p>​    小和问题和逆序对问题 </p>
<p>​    小和问题 </p>
<p>​    在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组 </p>
<p>​    的小和。求一个数组 的小和。 </p>
<p>​    例子:[1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左 </p>
<p>​    边比4小的数，1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、 </p>
<p>​    2; 所以小和为1+1+3+1+1+3+4+2&#x3D;16 </p>
<p>​    逆序对问题 在一个数组中，左边的数如果比右边的数大，则折两个数 </p>
<p>​    构成一个逆序对，请打印所有逆序对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小和问题</span></span><br><span class="line"><span class="keyword">package</span> _1.class02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_2_SmallSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallSum</span> <span class="operator">=</span> mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(smallSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mergeSort(arr, l, mid)</span><br><span class="line">                + mergeSort(arr, mid + <span class="number">1</span>, r)</span><br><span class="line">                + merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> m + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">            res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">            arr[l + i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-堆"><a href="#3-堆" class="headerlink" title="3.堆"></a>3.堆</h3><p>1，堆结构就是用数组实现的完全二叉树结构 </p>
<p>2，完全二叉树中如果每棵子树的最大值都在顶部就是大根堆 </p>
<p>3，完全二叉树中如果每棵子树的最小值都在顶部就是小根堆 </p>
<p>4，堆结构的heapInsert与heapify操作 </p>
<p>5，堆结构的增大和减少 </p>
<p>6，优先级队列结构，就是堆结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">           swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">           index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> (left + <span class="number">1</span>) &lt; size &amp;&amp; arr[left] &lt; arr[left + <span class="number">1</span>] ? (left + <span class="number">1</span>) : left;</span><br><span class="line">           largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           swap(arr, index, largest);</span><br><span class="line">           index = largest;</span><br><span class="line">           left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h3><p>1，先让整个数组都变成大根堆结构，建立堆的过程: </p>
<p>1)从上到下的方法，时间复杂度为O(N*logN) </p>
<p>2)从下到上的方法，时间复杂度为O(N) </p>
<p>2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调 </p>
<p>整堆，一直周而复始，时间复杂度为O(N*logN) </p>
<p>3，堆的大小减小成0之后，排序完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> &amp;&amp; arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">            swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-堆排序扩展题目"><a href="#5-堆排序扩展题目" class="headerlink" title="5.堆排序扩展题目"></a>5.堆排序扩展题目</h3><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元 </p>
<p>素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的 </p>
<p>排序算法针对这个数据进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code04_SortArrayDistanceLessK</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortedArrDistanceLessK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">		PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; index &lt; Math.min(arr.length, k); index++) &#123;</span><br><span class="line">			heap.add(arr[index]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;</span><br><span class="line">			heap.add(arr[index]);</span><br><span class="line">			arr[i] = heap.poll();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">			arr[i++] = heap.poll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-荷兰国旗问题"><a href="#6-荷兰国旗问题" class="headerlink" title="6.荷兰国旗问题"></a>6.荷兰国旗问题</h3><p>问题一 </p>
<p>给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的 </p>
<p>数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N) </p>
<p>问题二(荷兰国旗问题) </p>
<p>给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放 </p>
<p>在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度 O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> l - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> r + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (l &lt; more) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[l] &lt; p) &#123;</span><br><span class="line">               swap(arr, ++less, l++);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; p) &#123;</span><br><span class="line">               swap(arr, --more, l++);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-随机快速排序（改进的快速排序）"><a href="#7-随机快速排序（改进的快速排序）" class="headerlink" title="7.随机快速排序（改进的快速排序）"></a>7.随机快速排序（改进的快速排序）</h3><p>1）在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分 </p>
<p>成三个部分： </p>
<p>左侧&lt;划分值、中间&#x3D;&#x3D;划分值、右侧&gt;划分值 </p>
<p>2）对左侧范围和右侧范围，递归执行 </p>
<p>3）时间复杂度为O(N*logN)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="三、详解桶排序以及排序内容大总结"><a href="#三、详解桶排序以及排序内容大总结" class="headerlink" title="三、详解桶排序以及排序内容大总结"></a>三、详解桶排序以及排序内容大总结</h2><h3 id="1-比较器的使用"><a href="#1-比较器的使用" class="headerlink" title="1.比较器的使用"></a>1.比较器的使用</h3><p>1）比较器的实质就是重载比较运算符 </p>
<p>2）比较器可以很好的应用在特殊标准的排序上 </p>
<p>3）比较器可以很好的应用在根据特殊标准排序的结构上</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理笔记</title>
    <url>/2022/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-计算机组成原理概论"><a href="#1-计算机组成原理概论" class="headerlink" title="1. 计算机组成原理概论"></a>1. 计算机组成原理概论</h2><p><strong>计算机</strong>：数字电子计算机</p>
<p><strong>组成</strong>：计算机硬件系统的逻辑实现</p>
<p><strong>原理</strong>：不以具体机型为依托的，基本实现原理。</p>
<p>计算机组成原理：掌握如何实现的具体细节。</p>
 <span id="more"></span> 

<h3 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h3><p>计算机系统由两大部分组成：硬件和软件。软件又包括系统软件和应用软件。</p>
<p>系统软件可以管理整个计算机系统：</p>
<ul>
<li><strong>语言处理程序（将高级语言转换为机器可以懂的指令）</strong></li>
<li><strong>操作系统</strong></li>
<li><strong>服务性程序（比如数学库、MPI服务程序进行并行之间的通信）</strong></li>
<li><strong>数据库管理系统</strong></li>
<li><strong>网络软件</strong></li>
</ul>
<p>应用软件是按照任务需要编制成的程序。</p>
<p>可以简单将软硬件看作一个层次结构，<strong>硬件为软件提供接口，系统软件又为应用软件形成接口，来完成不同的程序。</strong></p>
<p>对于计算机的物理结构层次，我们这门课主要研究逻辑层和微电路层的具体实现方式。</p>
<p>计算机系统的指令层次如下图所示</p>
<p><img src="https://pic1.zhimg.com/80/v2-f8f082641a793f54b240a3bedc01be50_720w.jpg"></p>
<p> 操作系统可以管理软硬件的资源。 </p>
<p><img src="https://pic1.zhimg.com/80/v2-3f91e6af54a662b9d5b72731171ef3b4_720w.jpg"></p>
<p>计算机系统结构<strong>定义了系统软硬件的交界面，定义了哪些功能由软件实现，哪些功能由硬件实现</strong>，定义为&#x3D;&#x3D;<strong>程序员所见到的计算机系统的属性概念性的结构与功能特性</strong>&#x3D;&#x3D;。（指令系统，数据类型，寻址技术，I&#x2F;O机理），即程序员需要理解的东西。</p>
<p>计算机组成：实现计算机体系结构所体现的属性，即<strong>具体指令的实现。</strong></p>
<h3 id="1-2-计算机的基本组成"><a href="#1-2-计算机的基本组成" class="headerlink" title="1.2 计算机的基本组成"></a>1.2 计算机的基本组成</h3><h3 id="1-2-1-冯诺依曼结构"><a href="#1-2-1-冯诺依曼结构" class="headerlink" title="1.2.1 冯诺依曼结构"></a>1.2.1 冯诺依曼结构</h3><p><img src="https://pic2.zhimg.com/80/v2-400ee3ebfddf3d69912ac93f011374ed_720w.jpg"></p>
<p>上图实线表示数据流动，虚线表示控制反馈。</p>
<ul>
<li>计算机结构由五大部件组成：<strong>存储器、运算器、控制器、输入设备、输出设备</strong>。</li>
<li><strong>以运算器为中心</strong>，**&#x3D;&#x3D;程序存储在存储器中&#x3D;&#x3D;**。</li>
<li><strong>指令和数据以同等地位</strong>保存在存储器中，可以按照地址寻找。</li>
<li>指令和数据由二进制表示，指令由操作码和地址码组成，<strong>操作码指明指令要干什么，地址码指明操作数的地址。</strong></li>
</ul>
<p>冯诺依曼结构以运算器为中心，容易形成瓶颈。我们可以使用存储器作为中心来进行优化，但是还不够。</p>
<h3 id="1-2-2-现代计算机硬件框图"><a href="#1-2-2-现代计算机硬件框图" class="headerlink" title="1.2.2 现代计算机硬件框图"></a>1.2.2 现代计算机硬件框图</h3><p><img src="https://pic3.zhimg.com/80/v2-69a1d35329ee45fc170771d35a166b86_720w.jpg" alt="img"></p>
<p>指令和数据都是保存在存储器中的。</p>
<h3 id="1-2-3-存储器的基本组成"><a href="#1-2-3-存储器的基本组成" class="headerlink" title="1.2.3 存储器的基本组成"></a>1.2.3 存储器的基本组成</h3><p><img src="https://pic4.zhimg.com/80/v2-944e43e25966b494973463043e549bab_720w.jpg" alt="img"></p>
<p><strong>MAR是存储器地址寄存器，保存了存储单元的地址和编号，长度反映存储单元的个数。</strong></p>
<p><strong>MDR是存储器数据寄存器，保存了要存入存储体的数据或刚从存储体拿出来的数据，长度反映存储字长。</strong></p>
<p>利用MAR和MDR来将数据放入存储器。</p>
<h3 id="1-2-4-运算器的结构"><a href="#1-2-4-运算器的结构" class="headerlink" title="1.2.4 运算器的结构"></a>1.2.4 运算器的结构</h3><p><img src="https://pic3.zhimg.com/80/v2-1dae6cfbd865f753be7315f812069af2_720w.jpg" alt="img"></p>
<p>ALU（算术逻辑单元），通常是一个组合电路，输入撤销，输出也撤销，<strong>因此需要加上寄存器保存参与运算的计算</strong>。</p>
<p>数据寄存器X保存输入参数，ACC为累加寄存器，保存结果，<strong>乘法可能使得数据位数保存不下，使用MQ寄存器保存低位。</strong></p>
<p>上表中存放了不同运算中，运算器的工作过程，以乘法为例，操作过程如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-027a4d6e589fb343988ccfa78f34fc96_720w.jpg" alt="img"></p>
<ul>
<li>首先将被乘数取出来放到ACC中</li>
<li>从指令中的乘数地址M中取出乘数，送入MQ中</li>
<li>将被乘数送到X中</li>
<li>将ACC清零</li>
<li>完成乘法操作，结果由ACC和MQ保存</li>
</ul>
<p>这些操作的过程顺序是由<strong>控制器来控制完成的。</strong></p>
<h3 id="1-2-5-控制器的基本结构"><a href="#1-2-5-控制器的基本结构" class="headerlink" title="1.2.5 控制器的基本结构"></a>1.2.5 控制器的基本结构</h3><p>控制器的功能是<strong>解释指令（完成指令）、保证指令的按序执行</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-8565f5dd792980b286d549bb7e6024a9_720w.jpg" alt="img"></p>
<ul>
<li><strong>PC（程序计数器）寄存器保存了当前指令的地址，进行取指令，PC有计数功能。</strong></li>
<li><strong>IR（指令寄存器）存放当前要执行的指令，将操作码送入CU进行分析。</strong></li>
<li><strong>CU（控制单元）发出控制信号，控制相对应的部件来执行指令。</strong></li>
</ul>
<p>下面以取数指令为例分析指令执行过程（取数送到ACC中）</p>
<p><img src="https://pic1.zhimg.com/80/v2-2daf226d97d2b36ccd8fcdf01a07dab4_720w.jpg" alt="img"></p>
<ol>
<li>PC保存指令的地址，送到MAR进行寻址</li>
<li>MAR根据地址到存储体中找到保存的指令</li>
<li>MDR从存储体中取出指令</li>
<li>送到IR中，IR存放要执行的指令</li>
<li>IR将操作码送入CU中进行分析</li>
<li>同时将地址码送到MAR中找这个数的数据</li>
<li>MAR根据地址到存储体中找到要取的数</li>
<li>MDR保存从存储体中取出的数</li>
<li>CU控制下，将要取的数送到ACC中。</li>
</ol>
<p><strong>CU分析控制这些步骤的过程。</strong></p>
<h3 id="1-3-计算机硬件的主要技术指标"><a href="#1-3-计算机硬件的主要技术指标" class="headerlink" title="1.3 计算机硬件的主要技术指标"></a>1.3 计算机硬件的主要技术指标</h3><ul>
<li>机器字长：CPU一次能处理数据的位数，与CPU中寄存器位数有关。</li>
<li>运算速度：主频、核数以及每个核支持的线程数、CPI（执行一条指令所需的时钟周期数）、MIPS（每秒执行百万条指令）、FLOPS（每秒浮点运算次数）。</li>
<li>存储容量：主存容量（可使用存储单元个数×存储字长来表示存储体容量，MAR * MDR）（也可使用字节数来表示）、辅存容量（字节数表示）。</li>
</ul>
<h2 id="2-计算机的发展以及应用"><a href="#2-计算机的发展以及应用" class="headerlink" title="2. 计算机的发展以及应用"></a>2. 计算机的发展以及应用</h2><h3 id="2-1-计算机的发展史"><a href="#2-1-计算机的发展史" class="headerlink" title="2.1 计算机的发展史"></a>2.1 计算机的发展史</h3><p>第一台计算机，1946年ENIAC，十进制运算。</p>
<p>电子技术的发展与计算机体系结构技术的发展对计算机的发展产生了决定性作用。</p>
<p>根据硬件技术来对计算机进行划分代</p>
<p><strong>电子管→晶体管→中小规模集成电路→大规模集成电路→超大规模集成电路</strong></p>
<p>软件技术的发展：机器语言（面向机器）、汇编语言（面向机器）、高级语言（面向问题）。</p>
<h3 id="2-2-计算机的应用"><a href="#2-2-计算机的应用" class="headerlink" title="2.2 计算机的应用"></a>2.2 计算机的应用</h3><ul>
<li>科学计算和数据处理</li>
<li>工业控制和实时控制</li>
<li>网络技术</li>
<li>虚拟现实</li>
<li>办公自动化和管理信息系统</li>
<li>CAD&#x2F;CAM&#x2F;CIMS</li>
<li>多媒体技术</li>
<li>人工智能</li>
</ul>
<h2 id="3-系统总线"><a href="#3-系统总线" class="headerlink" title="3. 系统总线"></a>3. 系统总线</h2><h3 id="3-1-总线（bus）的基本概念"><a href="#3-1-总线（bus）的基本概念" class="headerlink" title="3.1 总线（bus）的基本概念"></a>3.1 总线（bus）的基本概念</h3><p>总线是连接各个部件的信息传输线，<strong>是各个部件共享的传输介质，</strong>是信号的公共传输线。</p>
<p>如果使用单总线结构（系统总线），那么<strong>同时只能有一对部件进行信号传输</strong>，效率较低，使用双总线结构效率会更高。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9a04dd0d8329e04fd06ec42467131cba_720w.jpg" alt="img"></p>
<p>上面的结构，无法在I&#x2F;O和主存之间进行直接的信息传输，必须要通过CPU。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b5b1ba238025a0f9938165accb1a4f9e_720w.jpg" alt="img"></p>
<h3 id="3-2-总线的分类"><a href="#3-2-总线的分类" class="headerlink" title="3.2 总线的分类"></a>3.2 总线的分类</h3><ul>
<li><p>片内总线：芯片内部的总线。</p>
</li>
<li><p>系统总线：计算机各部件之间的信息传输线。可分为：</p>
</li>
<li><ul>
<li><strong>数据总线</strong>，双向的，一般小于等于机器字长和存储字长。</li>
<li><strong>地址总线</strong>，单向的，与存储地址、I&#x2F;O地址有关。</li>
<li><strong>控制总线</strong>，双向（CPU发出存储器读写指令，总线允许，中断确认等；CPU接收中断请求、总线请求）</li>
</ul>
</li>
<li><p>通信总线：计算机之间或计算机和其它设备之间的通信，并行通信总线和串行通信总线。</p>
</li>
</ul>
<h3 id="3-3-总线的特性和性能指标"><a href="#3-3-总线的特性和性能指标" class="headerlink" title="3.3 总线的特性和性能指标"></a>3.3 总线的特性和性能指标</h3><p>总线印刷到电路板上（主板），其他设备插板插到主板上。</p>
<p><img src="https://pic2.zhimg.com/80/v2-686025071c4309677ef414d14bcd0cf1_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-31dc1a5a161020875b92e8fe70961701_720w.jpg" alt="img"></p>
<p>总线的性能指标：</p>
<ul>
<li>总线宽度：数据线根数，同时可以传输多少位。</li>
<li>标准传输率：每秒传输的最大字节数MBps</li>
<li>时钟同步&#x2F;不同步</li>
<li>总线复用：地址线与数据线是否可以复用</li>
<li>信号线数：地址线、数据线和控制线的总和</li>
<li>总线控制方式</li>
<li>其他指标：负载能力等</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-5d968958b712d0a2724af6824bdd93ee_720w.jpg" alt="img"></p>
<h3 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h3><p><img src="https://pic1.zhimg.com/80/v2-48c250bf81a7d88ca9033cb90f4b8d60_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-b7450aa5377fae2a59d7b034dc1b4a66_720w.jpg" alt="img"></p>
<p><strong>增加了DMA（直接存储器访问）总线，外部设备直接访问存储器内存。</strong>高速设备直接通过DMA访问主存。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e99a5cffacc23efec4bb49fdf16ac7ed_720w.jpg" alt="img"></p>
<p>CPU与cache通过局部总线进行相连，扩展总线将外部设备连接。</p>
<p><img src="https://pic4.zhimg.com/80/v2-5b91de164ae2dff903b0b7b0c0851b7f_720w.jpg" alt="img"></p>
<p>高速设备和低速设备分离，分别连接到高速总线和扩展总线上。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1f7ae7d57def2dc29ed21ef32eccf229_720w.jpg" alt="img"></p>
<p>PCI高速总线来连接高速设备，PCI总线可以通过桥来进行扩展。</p>
<h3 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h3><h3 id="3-5-1-总线判优控制"><a href="#3-5-1-总线判优控制" class="headerlink" title="3.5.1 总线判优控制"></a>3.5.1 总线判优控制</h3><p>通过是否能对总线发出占用请求，我们将设备分为主设备（主模块）和从设备（从模块）。<strong>主设备可以对总线有控制权，从设备响应从主设备发来的总线命令。</strong></p>
<p>总线判优控制可以分为两种：集中式和分布式。下面介绍几种集中式的总线判优控制结构。</p>
<p><img src="https://pic1.zhimg.com/80/v2-861b7aeec653084b2dda2ab9e4ae8130_720w.jpg" alt="img"></p>
<p>主设备通过BR申请总线的控制权，<strong>有设备在使用总线，则设置BS。总线控制部件通过BG来链式查询这些接口是否提出了BR，遇到了BR则交出控制权。</strong></p>
<p><strong>因此，优先顺序则为BG的查询顺序</strong>。这种结构对电路故障特别敏感，尤其是BG，如果BG后面出了问题，会导致后面的设备一直不会响应。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c6994c004889ac4b70e8af961524b90b_720w.jpg" alt="img"></p>
<p>数据线用于数据的传输，地址线用于从设备的查找。<strong>通过设备地址线来查找某个设备是否发出总线请求。计数器的值通过设备地址线进行传输，来查找某个设备是否发出请求。</strong>可以自定义计数器的计数方式，来改变从哪个设备先查询等。</p>
<p><img src="https://pic1.zhimg.com/80/v2-6fc0b9baef4000172b465032bcd6e6e4_720w.jpg" alt="img"></p>
<p>为每个I&#x2F;O接口增加了BR和BG，<strong>通过排队器来进行优先级排队</strong>。这种方式使用的线数较多。</p>
<h3 id="3-5-2-总线通信控制"><a href="#3-5-2-总线通信控制" class="headerlink" title="3.5.2 总线通信控制"></a>3.5.2 总线通信控制</h3><p>为了解决通信双方（主从设备）协调配合的问题。</p>
<p>总线的传输周期（完成一次主从设备完整可靠的传输所需要的时间）：</p>
<ul>
<li>申请分配阶段：主设备申请，总线决定</li>
<li>寻址阶段：主设备向向从设备给出地址和命令</li>
<li>传数阶段：主设备和从设备进行交换数据</li>
<li>结束阶段：主从设备撤销有关信息</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-09b037f3510443143bc0562ae67b0637_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-b9fbb40ece372f60d0c503a8203edd0e_720w.jpg" alt="img"></p>
<ul>
<li>T1，主设备给出地址信号</li>
<li>T2，给出从设备的读命令信号</li>
<li>T3，从设备给出数据，输出到总线，完成数据交换</li>
<li>T4，撤销地址信号，结束周期</li>
</ul>
<p>强制同步，如果设备之间速度不同，快的设备需要等慢的设备。</p>
<p><img src="https://pic2.zhimg.com/80/v2-bf4f0e7fde69e32e3e6c096b5d150a05_720w.jpg" alt="img"></p>
<p><strong>不互锁：不管从设备是否接收到请求信号，过段时间主设备都会撤销请求。不管主设备是否接收到应答信号，从设备多段时间都会撤销应答。</strong></p>
<p>半互锁和全互锁针对上面进行改进。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c350d75aee932c08977c635af7c70739_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-bf899d524112b9cd84b9f79fa2e2545e_720w.jpg" alt="img"></p>
<p>增加等待响应信号，当wait为低电平，则等待一个T。</p>
<p><img src="https://pic3.zhimg.com/80/v2-498179fa698c849afd894fd05900aea6_720w.jpg" alt="img"></p>
<p>使用分离式通信来将总线空闲的时间也充分利用起来。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a5e440385d7b6d3ad44f917e1c23d309_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-f509b451261ca9960f4d801aeddc7543_720w.jpg" alt="img"></p>
<h2 id="4-存储器"><a href="#4-存储器" class="headerlink" title="4. 存储器"></a>4. 存储器</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>按照存取方式对存储器进行分类：</p>
<ul>
<li>存取时间与物理地址无关（随机访问）：随机存储器、只读存储器。</li>
<li>存取时间与物理地址有关（串行访问）：顺序存取存储器（磁带）、直接存取存储器（磁盘）。</li>
</ul>
<p>按照在计算机中的作用分类：</p>
<p><img src="https://pic1.zhimg.com/80/v2-3e474b4e2264a9d5329dbb547d6f66e8_720w.jpg" alt="img"></p>
<p>存储器的层次结构：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1c67cdce3a2f34f0bde957a63c88f7eb_720w.jpg" alt="img"></p>
<ul>
<li>寄存器包括体系结构寄存器和非体系结构寄存器。</li>
<li>一部分缓存放在了CPU之中。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ecb8493e385dd90519547b2260d84a0a_720w.jpg" alt="img"></p>
<ul>
<li>缓存——主存层次，使用硬件方法连接到一个整体（对程序员透明，即不需要了解），速度较快，解决CPU和主存之间速度差距较大的问题，缓存即为cache，CPU可以直接从缓存调用数据，cache和主存也进行数据交换。使用主存储器的实地址和物理地址。</li>
<li>主存——辅存层次，使用软硬件结合方式连接，容量较大，解决容量不足问题。这个层次称为虚拟存储器，使用虚地址和逻辑地址。</li>
</ul>
<h3 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h3><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>主存的基本组成：</p>
<p><img src="https://pic4.zhimg.com/80/v2-a4cb6c6fa5d63b7d76cc8c9c98532a73_720w.jpg" alt="img"></p>
<p>主存与CPU之间的联系：</p>
<p><img src="https://pic1.zhimg.com/80/v2-c14afbf373caeb20cf157df27bbda84c_720w.jpg" alt="img"></p>
<p>主存中存储单元地址的分配：</p>
<ul>
<li>每个字节（8位）一个地址，如果一个存储单元存储32位，即四个字节为一个字，可<strong>以将高位字节&#x2F;低位字节，放在小的地址作为字地址。</strong></li>
</ul>
<p>主存的技术指标：</p>
<p><img src="https://pic2.zhimg.com/80/v2-42cda5798755d4a507b46a0d2dd0f789_720w.jpg" alt="img"></p>
<h3 id="4-2-2-主存储器半导体芯片简介"><a href="#4-2-2-主存储器半导体芯片简介" class="headerlink" title="4.2.2 主存储器半导体芯片简介"></a>4.2.2 主存储器半导体芯片简介</h3><p>基本结构：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b7ff96d3e063a3a156a9994a487b0b00_720w.jpg" alt="img"></p>
<ul>
<li>地址线（单向）给出地址，经过译码驱动电路来选择指定的存储单元，完成数据的读写操作（数据线双向）。</li>
<li>片选线是芯片选择信号，给出这次选择的地址是不是这个芯片的地址。</li>
<li>读写控制线，控制操作允许读还是写。</li>
<li>根据地址线和数据线条数，可以计算出芯片容量。<strong>如果地址线10条，数据线4条，那么芯片容量则为1K×4位。即1K个地址，每个地址数据4位。</strong></li>
</ul>
<p>译码驱动方式：</p>
<p>第一种方法是线选法</p>
<p><img src="https://pic3.zhimg.com/80/v2-72e60fb35e95ccd82f6196065319305a_720w.jpg" alt="img"></p>
<ul>
<li>使用地址译码器，给定输入，输出只有一根线（字线）是有效的，图中一根线中是8个芯片组合成一个字，那么只有一根线的这一组芯片有效。</li>
<li><strong>这种方法，每个字的存储单元都需要一根线，当容量较大的时候，很麻烦。</strong></li>
</ul>
<p>第二种方法是重合法</p>
<p><img src="https://pic4.zhimg.com/80/v2-b3e78113246d8c759c93ac9f54857c93_720w.jpg" alt="img"></p>
<ul>
<li>将所有存储单元布置成二维的阵列，使用两个地址译码器XY，一组(X,Y)对应一个存储单元。</li>
<li>这样会大大降低所需要的线数量。</li>
</ul>
<h3 id="4-2-3-随机存取存储器（RAM）"><a href="#4-2-3-随机存取存储器（RAM）" class="headerlink" title="4.2.3 随机存取存储器（RAM）"></a>4.2.3 随机存取存储器（RAM）</h3><h3 id="4-2-3-1-静态RAM（SRAM）"><a href="#4-2-3-1-静态RAM（SRAM）" class="headerlink" title="4.2.3.1 静态RAM（SRAM）"></a>4.2.3.1 静态RAM（SRAM）</h3><p>SRAM的基本电路：</p>
<p><img src="https://pic1.zhimg.com/80/v2-f91729a10c9c02ac0e0b40eee2873448_720w.jpg" alt="img"></p>
<ul>
<li><strong>使用触发器T1-T4来存储0&#x2F;1，T5、T6控制存储单元读写，实际中会有许多虚线框进行堆叠，T7、T8列开关，一列共用。同样，可以横向进行堆叠，那么行地址选择的这一行，所有存储单元的T5和T6都会导通，但是只有对应列也有效的那个存储单元才进行读写。</strong></li>
<li><strong>通过行选和列选，选中进行读写操作的存储单元。</strong></li>
</ul>
<p>SRAM芯片举例（Intel 2114）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e69116568a98aebf26024116e8306794_720w.jpg" alt="img"></p>
<ul>
<li>WE读写控制信号，CS片选信号，A0-A9为地址线，4个I&#x2F;O数据线。</li>
<li>10根地址线，使用重合法，6线为行地址，4线为列地址，每个列信号控制四列，这样一次就可以选择4位，将这4位看做是一个存储单元。就完成了1K×4位的选择。</li>
</ul>
<h3 id="4-2-3-2-动态RAM（DRAM）"><a href="#4-2-3-2-动态RAM（DRAM）" class="headerlink" title="4.2.3.2 动态RAM（DRAM）"></a>4.2.3.2 动态RAM（DRAM）</h3><p>DRAM的基本电路：</p>
<p><img src="https://pic3.zhimg.com/80/v2-1c1006911b42899ac25b7532eb848f0a_720w.jpg" alt="img"></p>
<ul>
<li>利用电容，如果电容保存了电荷，则认为保存是1，没有电，则认为是0。</li>
<li>保存在Cg上，T1、T2、T3是控制管。</li>
<li><strong>读出信息与原信息相反，需要加非门。</strong></li>
<li><strong>写入信息与输入信息相同。</strong></li>
</ul>
<p>还有一种结构是单管动态RAM：</p>
<p><img src="https://pic3.zhimg.com/80/v2-7d5a3d3ecb3f411a4117c7bfee4558a2_720w.jpg" alt="img"></p>
<ul>
<li>读出数据时，数据线有电，则为1。</li>
<li>写入时，Cs充电为1，放电为0。</li>
</ul>
<p>三管DRAM芯片举例（Intel 1103）：</p>
<p><img src="https://pic2.zhimg.com/80/v2-fb0f1504423e9c9a49b2f1d62e295ae1_720w.jpg" alt="img"></p>
<ul>
<li>因为电容会漏电，刷新放大器会定时对存储的信息进行刷新。</li>
</ul>
<p>单管DRAM芯片举例（Intel 4116 16k×1位）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-33b78430483e07932e1a7ef4947bedd8_720w.jpg" alt="img"></p>
<ul>
<li>只有7根地址线，通过两次，来接受行地址和列地址，存放到对应的缓存器中。</li>
<li>通过行时钟、列时钟、写时钟来控制读写。</li>
</ul>
<p>动态RAM的刷新：</p>
<ul>
<li>每一次刷新只与行地址有关，与列地址没有关系，每次刷新一行。</li>
<li>集中刷新（在某段时间集中刷新所有的电容），这段时间DRAM是不可用的，称为死区。</li>
<li>分散刷新（每次读写操作之后，将某一行刷新），相当于将原来的读写操作的时间变长，把刷新操作放在读写操作中，这样就不存在死区。分散刷新比较频繁，有点过度刷新了。</li>
<li>异步刷新（将上面两种结合），则每隔一段时间对某一行进行刷新，即多个读写操作加一个刷新操作。</li>
</ul>
<h3 id="4-2-3-3-两种RAM的比较"><a href="#4-2-3-3-两种RAM的比较" class="headerlink" title="4.2.3.3 两种RAM的比较"></a>4.2.3.3 两种RAM的比较</h3><p><img src="https://pic4.zhimg.com/80/v2-3cea24c6da2cb4a2d97fbceaf3f26507_720w.jpg" alt="img"></p>
<ul>
<li>DRAM的集成度较高，每个存储单元复杂度较低。</li>
<li>SRAM的速度较快，一般用作缓存。</li>
</ul>
<h3 id="4-2-4-只读存储器（ROM）"><a href="#4-2-4-只读存储器（ROM）" class="headerlink" title="4.2.4 只读存储器（ROM）"></a>4.2.4 只读存储器（ROM）</h3><p>ROM中一般保存系统信息或系统程序。早期是只读的，不可以写，经过多年的发展和改进，现在的ROM可以自己多次读写。</p>
<ul>
<li>掩模ROM（MROM）：只读，不能修改。行列选择线交叉处有MOS管则为1，没有则为0。</li>
<li>PROM（一次性编程）：熔丝断了，则为0，否则为1。可以一次性的破坏性编程。</li>
<li>EPROM（可以多次编程）：N型沟道浮动栅MOS电路。S与D导通为1，不导通为0。</li>
<li>EEPROM（多次性编程）：电可擦写、局部擦写、全部擦写。</li>
<li>Flash Memory（闪存型存储器）：比EEPROM快，具有RAM的一些功能。</li>
</ul>
<h3 id="4-2-5-CPU与存储器的连接"><a href="#4-2-5-CPU与存储器的连接" class="headerlink" title="4.2.5 CPU与存储器的连接"></a>4.2.5 CPU与存储器的连接</h3><p>存储器容量扩展可以通过位扩展（增加存储字长）、字扩展（增加存储字的数量）、同时扩展。</p>
<p>CPU与存储器的连接：</p>
<ul>
<li>地址线的连接：<strong>低位作为地址，高位作为片选信号</strong>。</li>
<li>数据线的连接</li>
<li>读写命令控制线的连接</li>
<li>片选线的连接：<strong>MREQ信号（表示该信号是连接存储器还是I&#x2F;O接口）一定要连接到片选信号中，</strong>使得只有这个信号有效，才是CPU和内存连接工作。</li>
<li>合理选择存储芯片（ROM&#x2F;RAM，芯片的性能参数）</li>
<li>其他：时序、负载</li>
</ul>
<h3 id="4-2-6-存储器的校验"><a href="#4-2-6-存储器的校验" class="headerlink" title="4.2.6 存储器的校验"></a>4.2.6 存储器的校验</h3><p>校验，检测合法代码，对非法代码进行纠错。</p>
<p><strong>编码的纠错、检错能力与编码的最小距离有关。最小距离为任意两组合法代码之间二进制位数的最小差异。</strong> $$ L-1 &#x3D; D + C\ (D≥C) $$ <strong>L为最小距离，D为检测错误的位数，C为纠正错误的位数。</strong></p>
<p>汉明码是具有一位纠错能力的编码，汉明码都采用了奇偶校验和分组校验（分组的奇偶校验，分组之间是有重叠的，校验位放在2 ^ k处，k&#x3D;0,1,2,3…）。</p>
<p>汉明码的分组，将代码中每一位进行分组（1,2,3,4,5,6,7序号），<strong>将每一位的序号进行分组，序号的二进制最右边一位为1的，第一组，右边第二位为1的，第二组……</strong></p>
<p>&#x3D;&#x3D;<strong>最后的校验结果，哪一位是1，那么这位对应的那组中的那个序号的代码位出错。如果出现了多个1，那么就是这几个组中公共的那位出错了。</strong>&#x3D;&#x3D;</p>
<h3 id="4-2-7-提高主存的访问以及存储速度"><a href="#4-2-7-提高主存的访问以及存储速度" class="headerlink" title="4.2.7 提高主存的访问以及存储速度"></a>4.2.7 提高主存的访问以及存储速度</h3><p>CPU速度提升很快，但是存储器的速度提升较慢。</p>
<p><strong>我们可以采用高速器件，采用层次结构（Cache-主存）,&#x3D;&#x3D;调整主存结构。&#x3D;&#x3D;</strong></p>
<ul>
<li>单体多字系统：使得存储器的存储字长大于CPU的字长（比如是CPU字长的4倍），这样一次读取就可以读取多个指令。<strong>但是这样会导致存储器结构复杂， 而且，如果需要执行的指令不是连续存放的，会更麻烦。</strong></li>
<li>多体并行方式：</li>
<li>高位交叉：对各个存储体进行编号，存储体内部自行编号，每个存储体独立，有自己的控制编号。这样CPU给出的地址是<strong>体号+体内地址</strong>，各个存储体可以并行处理。（类似存储器容量的扩展）如果程序指令存方式顺序的，实际上还是在一个存储体中，并无法提升存储体速度。</li>
<li>低位交叉：<strong>体内地址+体号</strong>，使用横向的编码，比如存储体为M0-M3，那么第一个地址为M0的第一个位置，第二个地址为M1的第一个位置……这样<strong>M0中所有地址后两位都为00，M1都为01，M2都为10，M3都为11。后两位给出了存储体的选择地址。</strong>这样如果程序指令顺序存放的地址，实际上是不同存储体并行处理，这样就提升了效率，流水操作。</li>
</ul>
<h3 id="4-3-高速缓冲存储器（Cache）"><a href="#4-3-高速缓冲存储器（Cache）" class="headerlink" title="4.3 高速缓冲存储器（Cache）"></a>4.3 高速缓冲存储器（Cache）</h3><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><p>CPU与主存（DRAM）之间存在速度差异，为了避免CPU“空等”的现象，使用cache。</p>
<p><img src="https://pic4.zhimg.com/80/v2-353ef48785f13a861a6c7098e01cf40b_720w.jpg" alt="img"></p>
<p><strong>程序访问的局部性原理</strong>：</p>
<ul>
<li>时间的局部性：当前正在使用的指令或数据，会在不久的将来还会使用到，那么应该把这种数据或指令放在缓存中。</li>
<li>空间的局部性：当前正在使用的指令或数据，不久的将来，相邻的指令或数据会使用到，那么应该把当前和相邻的指令和数据放到缓存中。</li>
</ul>
<p>cache的工作原理：</p>
<p><strong>把主存和cache分成大小相等的块</strong>，每个块大小相等，主存的块数量远远大于cache的块数量。**&#x3D;&#x3D;主存与cache之间的信息传送是按块传送，块内地址不变，cache的每个块的标记，标记了这个块是主存的哪个块。&#x3D;&#x3D;**</p>
<p>主存块调入了缓存（即cache标记了），称为命中，CPU可直接在缓存中取得数据；如果没有调入，称为未命中。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b389e6288a972d06339a6a02668b9b12_720w.jpg" alt="img"></p>
<p>我们希望，每次执行程序，都尽可能的在cache中提取数据，这样速度会很快。<strong>CPU欲访问的信息在Cache中的比率称为命中率，命中率与Cache的容量和块长有关。</strong>一般每块取4-8个字，一般为一个存取周期内从主存调出的信息长度。</p>
<p>cache与主存的访问效率：</p>
<p><strong>这里面平均访问时间为每次访问的平均时间</strong>（可能从cache，可能从主存）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-483109d42dab83c244559504f862bf9b_720w.jpg" alt="img"></p>
<h3 id="4-3-2-cache的基本结构与读写操作"><a href="#4-3-2-cache的基本结构与读写操作" class="headerlink" title="4.3.2 cache的基本结构与读写操作"></a>4.3.2 cache的基本结构与读写操作</h3><p>cache的基本结构：</p>
<p><img src="https://pic1.zhimg.com/80/v2-01dc495db6a09ddf0022618f1bb88640_720w.jpg" alt="img"></p>
<p>读写操作：</p>
<p><img src="https://pic3.zhimg.com/80/v2-61c29bfc2dcc23820a116b253e1dfc4a_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-2e4806efb2c9888730795934df565fa6_720w.jpg" alt="img"></p>
<ul>
<li>前者时刻保持了cache和主存的一致，后者只写cache中，当cache中退出时才写回主存。</li>
</ul>
<p>cache的改进：</p>
<ul>
<li>增加cache的级数：片内cache，片外cache。</li>
<li>分立缓存：指令cache，数据cache。</li>
</ul>
<h3 id="4-3-3-cache-主存的地址映射"><a href="#4-3-3-cache-主存的地址映射" class="headerlink" title="4.3.3 cache-主存的地址映射"></a>4.3.3 cache-主存的地址映射</h3><p>即主存的任意一块加载到cache中的哪块。</p>
<p>直接映射：</p>
<p><strong>即主存中任意一个块，只能映射到指定的一个cache块中，</strong>cache块可以是一对多的。相当于将主存分区，每个区内的这些块，对应于cache的所有块；<strong>这样在cache的标记中，有t位的标记，表示当前该cache块存放的是主存哪个区的对应位置信息。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-b4ae19aa355063f31023956d9df31399_720w.jpg" alt="img"></p>
<hr>
<p>这种方法cache块的利用率比较低，且可能会冲突。</p>
<p>全相联映射：</p>
<p><strong>主存中任意一个块，可以被放入cache中的任意一个块中。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-cdf526e1135e3779f38c0f1d70867524_720w.jpg" alt="img"></p>
<p>这样的话，<strong>虽然块的利用率高了，但是因为块可以映射到任意一个位置，如果查询某个主存块是否已经放入cache，需要比较所有的cache标记，速度较慢。</strong></p>
<p>**&#x3D;&#x3D;组相联映射&#x3D;&#x3D;**：</p>
<p>与直接映射相似，**&#x3D;&#x3D;将cache分组，每个组可以有多个块；将主存分区，每个区的大小为cache的组数&#x3D;&#x3D;<strong>。这样每个区的第0块，可以放入cache第0组的任何一个位置，</strong>因为每个组有多个块，解决了直接映射的冲突问题；想查询某个主存的块是否放入了cache，只需要在对应的组进行查询即可，解决了全相联映射的问题。**</p>
<p><img src="https://pic2.zhimg.com/80/v2-8bf0c9b2d66ba574d6c7d8b0f39004d5_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-f97734f6f2adaff46b770237f2722735_720w.jpg" alt="img"></p>
<h3 id="4-3-4-替换算法"><a href="#4-3-4-替换算法" class="headerlink" title="4.3.4 替换算法"></a>4.3.4 替换算法</h3><p>如果内存块满了，如何替换，将谁弹出。</p>
<p><strong>先进先出（FIFO）算法</strong></p>
<p><strong>近期最少使用（LRU）算法</strong></p>
<h3 id="4-4-辅助存储器"><a href="#4-4-辅助存储器" class="headerlink" title="4.4 辅助存储器"></a>4.4 辅助存储器</h3><p>辅助存储器的主要作用是保存程序、文档和影音资料，<strong>不能直接与CPU交换信息，需要调入主存才能进行读写。</strong></p>
<p>包括磁盘存储器和光盘存储器等。</p>
<h2 id="5-输入输出系统"><a href="#5-输入输出系统" class="headerlink" title="5. 输入输出系统"></a>5. 输入输出系统</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p><strong>发展概况：</strong></p>
<ul>
<li>早期CPU与I&#x2F;O设备串行工作，分散连接。使用程序查询方式连接。</li>
<li>后来使用总线连接（一条总线可以连接多个设备），出现了I&#x2F;O接口和DMA控制器，并行工作。</li>
<li>具有通道结构的阶段。</li>
<li>具有I&#x2F;O处理机的阶段（I&#x2F;O的独立性更强，使用I&#x2F;O处理器）。</li>
</ul>
<p><strong>I&#x2F;O系统的组成：</strong></p>
<ul>
<li><p>I&#x2F;O软件：</p>
</li>
<li><ul>
<li>CPU中的I&#x2F;O指令，来控制外部设备与主机协调工作，**格式为&#x3D;&#x3D;操作码+命令码+设备码&#x3D;&#x3D;**。</li>
<li>通道指令，通道自身的指令。</li>
</ul>
</li>
<li><p>I&#x2F;O硬件：</p>
</li>
<li><ul>
<li>设备以及I&#x2F;O接口，或者设备以及设备控制器，通道。</li>
</ul>
</li>
</ul>
<p><strong>I&#x2F;O设备与主机的联系方式：</strong></p>
<ul>
<li>对I&#x2F;O设备进行编址：<strong>统一编址（将I&#x2F;O地址放在内存的地址空间中，可以直接使用指令对外部设备进行存取数），不统一编址（需要使用专门的I&#x2F;O指令来调用设备）。</strong></li>
<li>设备选址：使用设备选择电路识别某个设备是否被选中。</li>
<li>数据传送方式：串行（一位一位传输）&#x2F;并行（多位同时传输）。</li>
</ul>
<p><strong>联络方式：</strong></p>
<ul>
<li>立即响应，接收到数据&#x2F;指令，直接响应。</li>
<li>异步工作，使用应答信号，可以并行也可以串行（I&#x2F;O设备与接口之间）</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-36018d99ff90a6a72e0d9566a3c2a933_720w.jpg" alt="img"></p>
<ul>
<li>同步工作，使用同步时标。</li>
</ul>
<p><strong>I&#x2F;O设备与主机的连接方式：</strong>分散连接（辐射式连接，每台设备都配有一套控制线路和信号线），总线连接。</p>
<p><strong>I&#x2F;O设备与主机信息传送的控制方式：</strong></p>
<ul>
<li>程序查询方式（CPU与I&#x2F;O串行工作，<strong>CPU需要等待，效率很低</strong>，CPU连接I&#x2F;O设备和内存）</li>
<li>程序中断方式（部分并行，<strong>CPU被一定程度解放，在IO设备自身准备的时候，CPU可以先进行自己的工作，当IO与主机进行信息交换的时候，CPU暂停自身程序，来参与信息交换</strong>）。</li>
<li>DMA方式（使外部设备与内存建立连接，解放cpu，**主存与IO之间有一条直接数据通道，通过DMA控制器可以直接进行数据交换，&#x3D;&#x3D;采用周期窃取，借用一个存取周期，使得DMA控制总线，完成数据在IO和主存之间的传送&#x3D;&#x3D;**，在这个周期中，CPU不能控制总线，但可以继续执行不需要访存的指令）。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-c8814fbc3f16c95db1e05626741ba498_720w.jpg" alt="img"></p>
<h3 id="5-2-外部设备"><a href="#5-2-外部设备" class="headerlink" title="5.2 外部设备"></a>5.2 外部设备</h3><ul>
<li>输入设备：键盘、鼠标、触摸屏</li>
<li>输出设备：显示器、打印机</li>
<li>其他：A&#x2F;D,D&#x2F;A转换器，终端，汉字处理</li>
<li>多媒体技术：VR等</li>
</ul>
<h3 id="5-3-I-x2F-O接口"><a href="#5-3-I-x2F-O接口" class="headerlink" title="5.3 I&#x2F;O接口"></a>5.3 I&#x2F;O接口</h3><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>为什么要设置接口：</p>
<ul>
<li>实现设备的选择</li>
<li>实现数据缓冲，达到速度匹配</li>
<li>实现数据串&#x2F;并格式转换</li>
<li>实现电平转换（主机和IO设备工作电平可能不一致）</li>
<li>传送控制命令</li>
<li>反映设备的状态（忙、就绪、中断请求）</li>
</ul>
<h3 id="5-3-2-接口的功能和组成"><a href="#5-3-2-接口的功能和组成" class="headerlink" title="5.3.2 接口的功能和组成"></a>5.3.2 接口的功能和组成</h3><p>主机通过IO总线与IO设备相连接。</p>
<p><img src="https://pic1.zhimg.com/80/v2-234b9a9141dabb3978007f891e1a90c8_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-049a5f99304a3a6a6fa3e540ebd7859e_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-50f0d2effcdf192b2efa20964052a8a9_720w.jpg" alt="img"></p>
<p>五大部分：<strong>数据缓冲寄存器、设备状态标记、控制逻辑电路、设备选择电路、命令寄存器和命令译码器。</strong></p>
<h3 id="5-3-3-接口类型"><a href="#5-3-3-接口类型" class="headerlink" title="5.3.3 接口类型"></a>5.3.3 接口类型</h3><ul>
<li>按照数据传送方式：串行&#x2F;并行</li>
<li>按照功能选择的灵活性：可编程接口&#x2F;不可编程接口</li>
<li>按通用性：通用接口&#x2F;专用接口</li>
<li>按数据传送的控制方式：中断接口&#x2F;DMA接口</li>
</ul>
<h3 id="5-4-程序查询方式"><a href="#5-4-程序查询方式" class="headerlink" title="5.4 程序查询方式"></a>5.4 程序查询方式</h3><p><img src="https://pic2.zhimg.com/80/v2-a3845c55270c15d3d1c93bda1307cfa1_720w.jpg" alt="img"></p>
<p><strong>程序查询方式的接口电路：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-02069a45157ce0961a13a2c881601ec9_720w.jpg" alt="img"></p>
<ul>
<li>当D等于1的时候，IO完成了送入数据到DBR，<strong>此时CPU通过数据线读入数据，在D等于1之前，CPU一直在原地踏步等待。</strong></li>
</ul>
<h3 id="5-5-程序中断方式"><a href="#5-5-程序中断方式" class="headerlink" title="5.5 程序中断方式"></a>5.5 程序中断方式</h3><h3 id="5-5-1-中断的概念"><a href="#5-5-1-中断的概念" class="headerlink" title="5.5.1 中断的概念"></a>5.5.1 中断的概念</h3><p>CPU在执行程序的时候，<strong>遇到特殊事件或异常事件，暂停原来的程序，去处理这个事件（执行中断服务程序），之后再继续执行原来的程序。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-ed5ead354e598f429c5d2fbb5fc5c16e_720w.jpg" alt="img"></p>
<h3 id="5-5-2-I-x2F-O中断的产生"><a href="#5-5-2-I-x2F-O中断的产生" class="headerlink" title="5.5.2 I&#x2F;O中断的产生"></a>5.5.2 I&#x2F;O中断的产生</h3><p><img src="https://pic3.zhimg.com/80/v2-21b5873456d87e7ba9dc462989f79262_720w.jpg" alt="img"></p>
<h3 id="5-5-3-程序中断方式的接口电路"><a href="#5-5-3-程序中断方式的接口电路" class="headerlink" title="5.5.3 程序中断方式的接口电路"></a>5.5.3 程序中断方式的接口电路</h3><ul>
<li>配置中断请求触发器和中断屏蔽触发器（如果目前执行的程序比请求的设备优先级高，则屏蔽该中断请求）</li>
<li>排队器（有多个中断的话，需要使用排队器，根据优先级进行排队）</li>
<li>中断向量地址形成部件（形成中断服务程序的入口地址）</li>
</ul>
<p><strong>配置中断请求触发器和中断屏蔽触发器：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-c24a7e7bd53d7dfa4240dab976d1659c_720w.jpg" alt="img"></p>
<p><strong>排队器：</strong></p>
<p>排队器可以使用硬件电路来实现（在CPU内或接口电路中），也可以在软件中实现。</p>
<p>链式排队器，<strong>输出只有一位是高电平，其他都是低电平，高电平表示此时最高优先级的中断。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-ab622ca1a033ab52bc812bee17af7638_720w.jpg" alt="img"></p>
<p><strong>中断向量地址形成部件：</strong></p>
<p>找到中断服务程序的入口地址，同样可以使用软件或硬件方法（硬件向量法）。</p>
<p><strong>硬件向量法由硬件产生向量地址，再由向量地址找到入口地址。</strong></p>
<p>中断向量地址形成部件的<strong>输入为排队器的输出</strong>（只有一位是高电平，其他都是低电平），&#x3D;&#x3D;<strong>输出为该种中断的向量地址，再通过向量地址，找到该种中断的中断服务程序的入口地址。</strong>&#x3D;&#x3D;</p>
<p><img src="https://pic3.zhimg.com/80/v2-882c410475b3f0119b6ca28550ef0942_720w.jpg" alt="img"></p>
<h3 id="5-5-4-I-x2F-O中断处理过程"><a href="#5-5-4-I-x2F-O中断处理过程" class="headerlink" title="5.5.4 I&#x2F;O中断处理过程"></a>5.5.4 I&#x2F;O中断处理过程</h3><p><img src="https://pic2.zhimg.com/80/v2-6e0573d5842b488b3b4832ca6fb445d9_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-7d7ab148498ac3048a68e578f0fadf3d_720w.jpg" alt="img"></p>
<h3 id="5-5-5-中断服务程序流程"><a href="#5-5-5-中断服务程序流程" class="headerlink" title="5.5.5 中断服务程序流程"></a>5.5.5 中断服务程序流程</h3><p><img src="https://pic2.zhimg.com/80/v2-2d97e87947354b4eaa9dd08b23b70701_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f3f3d63c25f2077e0fc31053ce2c19f4_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c64231e9418cf7eb85a2ba6e2d7ec135_720w.jpg" alt="img"></p>
<h3 id="5-6-DMA（直接存储器访问）方式"><a href="#5-6-DMA（直接存储器访问）方式" class="headerlink" title="5.6 DMA（直接存储器访问）方式"></a>5.6 DMA（直接存储器访问）方式</h3><h3 id="5-6-1-DMA方式的特点"><a href="#5-6-1-DMA方式的特点" class="headerlink" title="5.6.1 DMA方式的特点"></a>5.6.1 DMA方式的特点</h3><p><img src="https://pic4.zhimg.com/80/v2-9227e4cde1f4b33b4f38d010019fad73_720w.jpg" alt="img"></p>
<p>程序中断方式必须使用CPU来作为缓冲（即使是主存和IO之间进行信息交换）。</p>
<p>DMA方式，不需要CPU作为缓冲。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f6741cf48a31210b6e257e0b9a9b84b1_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-2f1017e17df182ab9429359649b47a79_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-832462276ad36e49d68737e7dc30df55_720w.jpg" alt="img"></p>
<ul>
<li>这种方法的实用性不强。</li>
</ul>
<h3 id="5-6-2-DMA接口的功能和组成"><a href="#5-6-2-DMA接口的功能和组成" class="headerlink" title="5.6.2 DMA接口的功能和组成"></a>5.6.2 DMA接口的功能和组成</h3><p><img src="https://pic1.zhimg.com/80/v2-e848ed9bf4bb8e6ae13579260d54a240_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-32ddddbf1c7cb853cb6cb3fcb9ff032b_720w.jpg" alt="img"></p>
<ul>
<li>AR：地址寄存器，WC：计数器，对传输数据量计数。</li>
<li>BR：数据缓冲器，DAR：设备地址寄存器，供设备选择电路使用；对于硬盘等设备，可以保存扇区号等。</li>
<li>DMA控制逻辑：完成与设备之间的请求回答，与总线的请求回答。</li>
<li>中断机构：传输结束之后的后续处理。</li>
</ul>
<h3 id="5-6-3-DMA的工作过程"><a href="#5-6-3-DMA的工作过程" class="headerlink" title="5.6.3 DMA的工作过程"></a>5.6.3 DMA的工作过程</h3><p><strong>DMA的传送过程</strong>：<strong>预处理、数据传送、后处理。</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-742b30c0695d121fe5cb564d17b8736f_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-1a1e25ed9572b59ef4b628189823800e_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-54fc05c234015ac602e81a08fff0ae20_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-cc3a9d2c01fe5198070dcc7196ec725c_720w.jpg" alt="img"></p>
<p><strong>DMA接口与系统的连接方式：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-161ece29eeada9301c4280a7313e2795_720w.jpg" alt="img"></p>
<ul>
<li>多个DMA接口连在一起，共享一条请求线。各DMA同样有优先级顺序。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-b9b57b9ea08c8ba41c3934c190e477d6_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-38326dc785a0b2e2c4b395966cf8138c_720w.jpg" alt="img"></p>
<h3 id="5-6-4-DMA接口的类型"><a href="#5-6-4-DMA接口的类型" class="headerlink" title="5.6.4 DMA接口的类型"></a>5.6.4 DMA接口的类型</h3><p><img src="https://pic4.zhimg.com/80/v2-8e8b0eb2842291a42685d4ee48324b3f_720w.jpg" alt="img"></p>
<ul>
<li>一个接口连了多个设备，但是每次只能与一个设备使用。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-45250bc057df82c94407bceb1c3f409e_720w.jpg" alt="img"></p>
<ul>
<li>每个通道有多个子通道，子通道可以并行使用。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-250ecbfe831995cc07959343b504c23d_720w.jpg" alt="img"></p>
<h2 id="6-计算机的运算方法"><a href="#6-计算机的运算方法" class="headerlink" title="6. 计算机的运算方法"></a>6. 计算机的运算方法</h2><h3 id="6-1-无符号数和有符号数"><a href="#6-1-无符号数和有符号数" class="headerlink" title="6.1 无符号数和有符号数"></a>6.1 无符号数和有符号数</h3><h3 id="6-1-1-无符号数"><a href="#6-1-1-无符号数" class="headerlink" title="6.1.1 无符号数"></a>6.1.1 无符号数</h3><p>没有正负号的数据，<strong>寄存器的位数即为无符号数的表示范围。</strong></p>
<h3 id="6-1-2-有符号数"><a href="#6-1-2-有符号数" class="headerlink" title="6.1.2 有符号数"></a>6.1.2 有符号数</h3><p>分为符号部分和数值部分。</p>
<p>机器数<strong>保存符号、小数点位置以及数值</strong>。计算机中<strong>没有</strong>专门的硬件保存小数点，都是以约定的形式给出。</p>
<p><strong>原码表示法：</strong></p>
<p>整数：&#x3D;&#x3D;<strong>符号位+，+数值。符号位0为正，1为负。</strong>&#x3D;&#x3D;逗号将符号位和数值分隔开，数值其实是数的绝对值。</p>
<p>小数：&#x3D;&#x3D;<strong>符号位+.+小数部分，符号位0为正，1为负。</strong>&#x3D;&#x3D;小数点将符号位和小数部分分隔开。</p>
<p><strong>上面的逗号和小数点，都不需要在计算机中存储，这里是方便人来阅读。</strong></p>
<p>使用原码进行加法的时候，结果的符号可正可负，希望找到一个与负数等价的正数来替代这个负数，这样就可以使得减法变成加法，即补码表示法。</p>
<p><strong>补码表示法：</strong></p>
<p>整数：<strong>正数的补码与原码一致，负数的补码为它的原码，除符号位以外，各位取反，最后加1。</strong></p>
<p>小数：<strong>正数的补码与原码一致，负数的补码为它的原码，除符号位以外，各位取反，最后加1。</strong></p>
<p><strong>反码表示法：</strong></p>
<p>正数的反码就是原码，负数的反码，将原码除符号位外，所有位取反。</p>
<p><img src="https://pic3.zhimg.com/80/v2-d897d8301ade757735da507c16e5cc5e_720w.jpg" alt="img"></p>
<p><strong>移码表示法（只有整数形式定义）：</strong></p>
<p>补码很难直接判断其真值大小。</p>
<p><img src="https://pic3.zhimg.com/80/v2-6a3cdf6050e60506e92dd16a157e2b6e_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-2d9837b1a6bedaf32be3f0fb589de95a_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-394d544564c5217eee08b41b26e4f029_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ed12f9fda7ee5912620a894f5a2193e1_720w.jpg" alt="img"></p>
<h3 id="6-2-数的定点表示和浮点表示"><a href="#6-2-数的定点表示和浮点表示" class="headerlink" title="6.2 数的定点表示和浮点表示"></a>6.2 数的定点表示和浮点表示</h3><h3 id="6-2-1-定点表示"><a href="#6-2-1-定点表示" class="headerlink" title="6.2.1 定点表示"></a>6.2.1 定点表示</h3><p>小数点按照约定方式标出，没有硬件完成小数点，根据设计人员的约定来进行表示。</p>
<p>小数点可放在数符和数值之间（小数定点机），或数值之后（整数定点机）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-6e8acba8b8fc1dded67e97f753ec5977_720w.jpg" alt="img"></p>
<h3 id="6-2-2-浮点表示"><a href="#6-2-2-浮点表示" class="headerlink" title="6.2.2 浮点表示"></a>6.2.2 浮点表示</h3><p>定点表示的数，表示范围小，为了表示两个大小相差很大的数据，需要很长的机器字长。数据存储单元的利用率很低。</p>
<p>浮点数的一般形式 $$ N &#x3D; S×r^j $$ S为尾数，j为阶码，r为尾数的基值，计算机中r通常取2,4,8,16。<strong>在计算机中，S为小数，可正可负；j为整数，可正可负。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-2009b694f8408aa43ffad17e1cc32506_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-ec6810b1fcde4b5b448e56e5c7fd1394_720w.jpg" alt="img"></p>
<p>对浮点数进行规格化，是为了尽可能保证数据的精度，让有效的位数尽可能多。</p>
<p><img src="https://pic3.zhimg.com/80/v2-14d223a976be94b4544f5c9194fcce7e_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-6bc74400fdf3408fc608f1abe72d9ead_720w.jpg" alt="img"></p>
<h3 id="6-3-定点运算"><a href="#6-3-定点运算" class="headerlink" title="6.3 定点运算"></a>6.3 定点运算</h3><h3 id="6-3-1-移位运算"><a href="#6-3-1-移位运算" class="headerlink" title="6.3.1 移位运算"></a>6.3.1 移位运算</h3><p>数据相对于小数点进行左移&#x2F;右移（小数点不动）。左移，绝对值扩大，右移，绝对值缩小。移位与加减法配合，能够实现乘除法运算。</p>
<p><img src="https://pic3.zhimg.com/80/v2-99ed7169acfb00d5d23a71ef346ee12a_720w.jpg" alt="img"></p>
<ul>
<li>注意，&#x3D;&#x3D;符号位保持不变&#x3D;&#x3D;。</li>
</ul>
<p><strong>算数移位的硬件实现：</strong></p>
<p>即，左移，最高位扔掉，其他位左移，末尾补0&#x2F;1。</p>
<p>右移，最低位扔掉，其他位右移，高位补0&#x2F;1。</p>
<p><img src="https://pic1.zhimg.com/80/v2-653e755f9801caab4583a36a8cbda674_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-cd77d50aaada2fb7146cbd52dd0a86b5_720w.jpg" alt="img"></p>
<h3 id="6-3-2-加减法运算"><a href="#6-3-2-加减法运算" class="headerlink" title="6.3.2 加减法运算"></a>6.3.2 加减法运算</h3><p>主要是使用补码进行加减法运算，因为可以将减法变为加法。</p>
<p><img src="https://pic3.zhimg.com/80/v2-e65743521c23abe2e32f8ee8393a25a2_720w.jpg" alt="img"></p>
<p>还需要判断处理溢出。</p>
<p><img src="https://pic1.zhimg.com/80/v2-33b395859242666145fd1b1c5b1776b0_720w.jpg" alt="img"></p>
<p><strong>两个同符号的数，数值运算产生了进位，进位到了符号位，改变了符号位，则就出现了溢出。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-9d5763771e2521ef64139e69067539a0_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-0467e3da10cb7cd7d759085ed9d5416c_720w.jpg" alt="img"></p>
<p>核心是n+1位加法器，两个寄存器保存参与计算的数据。  </p>
<h3 id="6-3-3-乘法运算"><a href="#6-3-3-乘法运算" class="headerlink" title="6.3.3 乘法运算"></a>6.3.3 乘法运算</h3><p>模拟笔算乘法的过程，符号位进行单独处理（异或电路），可以将乘数放到移位寄存器中。</p>
<p><img src="https://pic4.zhimg.com/80/v2-22a4364f5174c4d7d78c48d996089be3_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-2d665149b1a2f1f24edb23c4ef0daa57_720w.jpg" alt="img"></p>
<ul>
<li>n是参加运算的数的数值部分长度。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-2d74e4b2493b2bf1a6460478cc49fb29_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9a6df8722fd24f77d5679af7c1079364_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-4bf21278b48c18784327f09da3c47165_720w.jpg" alt="img"></p>
<h3 id="6-3-4-除法运算"><a href="#6-3-4-除法运算" class="headerlink" title="6.3.4 除法运算"></a>6.3.4 除法运算</h3><p>二进制的除法比十进制简单得多，商只会上0&#x2F;1。</p>
<p><img src="https://pic4.zhimg.com/80/v2-8621ac43a4e2b546e48fed304433010b_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-7a5e8396ed8594c5f5002c25f015f2bd_720w.jpg" alt="img"></p>
<ul>
<li>小数除法，小数都是小于1的，因此默认被除数小于除数，这样结果还是小于1的。</li>
</ul>
<p>恢复余数法：余数为正，上商1；余数为负，上商0，恢复余数。</p>
<p>不恢复余数法（加减交替法）</p>
<p><img src="https://pic3.zhimg.com/80/v2-111286030a80c2c5d3cf0569934d52be_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-6e6b4b38431bbb932c680ea7ae1a3f66_720w.jpg" alt="img"></p>
<h3 id="6-4-浮点四则运算"><a href="#6-4-浮点四则运算" class="headerlink" title="6.4 浮点四则运算"></a>6.4 浮点四则运算</h3><p>浮点数的加减运算：</p>
<p><img src="https://pic2.zhimg.com/80/v2-35da1e201bf44b2d582f91694d84e905_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-d421ec2c547508394693892c9839ea02_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-bc1bffdde6824ccc16625e8b5866fb15_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-616d0f28ff6f144b64461d550df77240_720w.jpg" alt="img"></p>
<h3 id="6-5-算术逻辑单元（ALU）"><a href="#6-5-算术逻辑单元（ALU）" class="headerlink" title="6.5 算术逻辑单元（ALU）"></a>6.5 算术逻辑单元（ALU）</h3><h3 id="6-5-1-ALU电路"><a href="#6-5-1-ALU电路" class="headerlink" title="6.5.1 ALU电路"></a>6.5.1 ALU电路</h3><p><img src="https://pic4.zhimg.com/80/v2-0bad4e319a1da81cc6a670bfdb479903_720w.jpg" alt="img"></p>
<p>Ai和Bi两个输入，进行计算的两个数值，F为输出结果，K控制进行什么计算。</p>
<h3 id="6-5-2-快速进位链"><a href="#6-5-2-快速进位链" class="headerlink" title="6.5.2 快速进位链"></a>6.5.2 快速进位链</h3><p><img src="https://pic4.zhimg.com/80/v2-ce99c34604d325ca6e0ac2ab24f81a1b_720w.jpg" alt="img"></p>
<ul>
<li>C为进位，需要等低位的计算完之后，才能进行这一位的计算，因此需要更快的进位。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-b88b52250375a02d1753fba8a94700b5_720w.jpg" alt="img"></p>
<ul>
<li>进位链是影响加法速度的瓶颈</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-8346609c9d5f78ac5f05b0bf8b041f87_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-cec52432cf0f836a068aa8613ca01b54_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4e16fbfa2525a9e894876b0a8bb5ec07_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-8f5d21ebfa2b0f3c83045122ccfa4828_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-7ac74dc29c0ecbb5871fe7a90cd741b7_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-30b1db9095be53de9df3a66f1f11271c_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-b4dbabc10878c88e8be6b5e84aa4c3f5_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-c67441181c3e0442c0966d8315862aa7_720w.jpg" alt="img"></p>
<h2 id="7-指令系统"><a href="#7-指令系统" class="headerlink" title="7. 指令系统"></a>7. 指令系统</h2><p>指令系统是计算机软硬件的交汇面。</p>
<h3 id="7-1-机器指令"><a href="#7-1-机器指令" class="headerlink" title="7.1 机器指令"></a>7.1 机器指令</h3><h3 id="7-1-1-指令的一般格式"><a href="#7-1-1-指令的一般格式" class="headerlink" title="7.1.1 指令的一般格式"></a>7.1.1 指令的一般格式</h3><p><img src="https://pic1.zhimg.com/80/v2-98a6b474fc548fba56b432a5389d10a0_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-1a356f0b44baf334e727b419899d927d_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-1350227e0717ed0bef5146fa366b56db_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-8fd5bc6e4948cec19da7b918cc9eedef_720w.jpg" alt="img"></p>
<h3 id="7-1-2-指令字长"><a href="#7-1-2-指令字长" class="headerlink" title="7.1.2 指令字长"></a>7.1.2 指令字长</h3><p>指令的字长取决于：操作码的长度，操作数地址的长度，操作数地址的个数。</p>
<p>指令字长可以是固定的（指令字长&#x3D;存储字长），也可以是可变的，按照字节的倍数进行变化。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3dd663a9f1cd87d5a5bf0855dc1310a2_720w.jpg" alt="img"></p>
<h3 id="7-2-操作数类型和操作种类"><a href="#7-2-操作数类型和操作种类" class="headerlink" title="7.2 操作数类型和操作种类"></a>7.2 操作数类型和操作种类</h3><h3 id="7-2-1-操作数类型"><a href="#7-2-1-操作数类型" class="headerlink" title="7.2.1 操作数类型"></a>7.2.1 操作数类型</h3><ul>
<li>地址：无符号整数（绝对地址），有符号数（相对地址）</li>
<li>数字：定点数、浮点数、十进制数</li>
<li>字符：ASCII</li>
<li>逻辑数：逻辑运算</li>
</ul>
<h3 id="7-2-2-数据在存储器中的存放方式"><a href="#7-2-2-数据在存储器中的存放方式" class="headerlink" title="7.2.2 数据在存储器中的存放方式"></a>7.2.2 数据在存储器中的存放方式</h3><p><img src="https://pic3.zhimg.com/80/v2-c8b0cf805c761ac8cfd3a49e5bd82d92_720w.jpg" alt="img"></p>
<p>字节编址：</p>
<p><img src="https://pic3.zhimg.com/80/v2-258c0ae86a0cf5dced8ff61f21ebcace_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-911639d4ea60b7941bf4ff489bae0479_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-79758c0730be6c72e2448c820211e89e_720w.jpg" alt="img"></p>
<h3 id="7-2-3-操作类型"><a href="#7-2-3-操作类型" class="headerlink" title="7.2.3 操作类型"></a>7.2.3 操作类型</h3><p><img src="https://pic3.zhimg.com/80/v2-e80d2179db474bd214ab55d85b6081aa_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-60331452311ef076ab8f69b884c199d3_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-62ca2b1d52b8951bf9d334c65737be64_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-3b36fb82b72d8e520b6d826dc1f46ad9_720w.jpg" alt="img"></p>
<h3 id="7-3-寻址方式"><a href="#7-3-寻址方式" class="headerlink" title="7.3 寻址方式"></a>7.3 寻址方式</h3><p>确定本条指令的操作数地址，或下一条指令的指令地址。</p>
<p>可分为指令的寻址和数据寻址</p>
<h3 id="7-3-1-指令寻址"><a href="#7-3-1-指令寻址" class="headerlink" title="7.3.1 指令寻址"></a>7.3.1 指令寻址</h3><p>顺序寻址&#x2F;跳跃寻址。</p>
<p>pc程序计数器。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c0c57fba32931971dfa3acc8c60fbbb5_720w.jpg" alt="img"></p>
<h3 id="7-3-2-数据寻址"><a href="#7-3-2-数据寻址" class="headerlink" title="7.3.2 数据寻址"></a>7.3.2 数据寻址</h3><p><img src="https://pic3.zhimg.com/80/v2-54356fae3d68588119f0215e70b3306e_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-57878ba3ec2d0e02530ee8b41a8c2bd7_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-dea762b7cbe150b8d1a291c10e788a69_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-fe04753ed352f51476c52422044327f4_720w.jpg" alt="img"></p>
<ul>
<li>操作数的有效地址保存在另一个位置，再去这个位置找到有效地址EA，访存两次。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-9cf702816cd97ee18002f54bbc658ff2_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-fc3d5c688eeac38569482de915cac3aa_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-cdcaae570fc9396a3e379c3cb1866ba8_720w.jpg" alt="img"></p>
<ul>
<li>BR是基址，A相当于偏移量，形式地址。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-82486c9a347dcb7f4c7d4fc5c5a90169_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4445ed987460133a438626a3b6ecd4be_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-6ea74f28c9b588e400dc13e75f97f349_720w.jpg" alt="img"></p>
<ul>
<li>相对于当前PC值。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-495c7c8224b8abb4eab61310bcde6d44_720w.jpg" alt="img"></p>
<h3 id="7-4-指令格式举例"><a href="#7-4-指令格式举例" class="headerlink" title="7.4 指令格式举例"></a>7.4 指令格式举例</h3><p><img src="https://pic3.zhimg.com/80/v2-7f557e8b2a25dafbeec9ccef53a9de02_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-352cd052c7d2762782e62da5affa44c4_720w.jpg" alt="img"></p>
<h3 id="7-5-RISC（精简指令集计算机）技术"><a href="#7-5-RISC（精简指令集计算机）技术" class="headerlink" title="7.5 RISC（精简指令集计算机）技术"></a>7.5 RISC（精简指令集计算机）技术</h3><p><img src="https://pic1.zhimg.com/80/v2-4a2e7799e675ef547d04a89bf7504ac8_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-5b0294e195a58d9df758b0db7bd35451_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-cbb90ab791b3c9c93805cd2317238377_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c1a931e604616c339419883553d2e0f9_720w.jpg" alt="img"></p>
<h2 id="8-CPU的结构与功能"><a href="#8-CPU的结构与功能" class="headerlink" title="8. CPU的结构与功能"></a>8. CPU的结构与功能</h2><h3 id="8-1-CPU的结构"><a href="#8-1-CPU的结构" class="headerlink" title="8.1 CPU的结构"></a>8.1 CPU的结构</h3><h3 id="8-1-1-CPU的功能"><a href="#8-1-1-CPU的功能" class="headerlink" title="8.1.1 CPU的功能"></a>8.1.1 CPU的功能</h3><p><img src="https://pic4.zhimg.com/80/v2-c8d59c52ce03b8660c9e5294f610645b_720w.jpg" alt="img"></p>
<h3 id="8-1-2-CPU结构框图"><a href="#8-1-2-CPU结构框图" class="headerlink" title="8.1.2 CPU结构框图"></a>8.1.2 CPU结构框图</h3><p><img src="https://pic2.zhimg.com/80/v2-73181cfcc27e2207c1f8f222d8b67375_720w.jpg" alt="img"></p>
<ul>
<li>IR指令寄存器，PC程序计数器</li>
</ul>
<h3 id="8-1-3-CPU的寄存器"><a href="#8-1-3-CPU的寄存器" class="headerlink" title="8.1.3 CPU的寄存器"></a>8.1.3 CPU的寄存器</h3><p><img src="https://pic3.zhimg.com/80/v2-95cb86b429d0859197376e68df522c8e_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f74c63b293116496b2bfc879cc9ae9b8_720w.jpg" alt="img"></p>
<h3 id="8-1-4-其他"><a href="#8-1-4-其他" class="headerlink" title="8.1.4 其他"></a>8.1.4 其他</h3><p>其他部分还包括CU（控制单元）、中断系统以及ALU。</p>
<p><strong>CU产生全部指令执行的时候的微操作命令序列，可使用组合逻辑设计或微程序设计。</strong></p>
<h3 id="8-2-指令周期"><a href="#8-2-指令周期" class="headerlink" title="8.2 指令周期"></a>8.2 指令周期</h3><h3 id="8-2-1-基本概念"><a href="#8-2-1-基本概念" class="headerlink" title="8.2.1 基本概念"></a>8.2.1 基本概念</h3><p><img src="https://pic1.zhimg.com/80/v2-b7d7e0c28a00121c7e79aaa71b931568_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-69f06b5dae753a813d73c9d73afb1667_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4e068b10aded51c176b0f53166c95ac3_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d632bdba372b27770d4f6954f95ddac1_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9dd83563b97ad61a54969dace6e91ca0_720w.jpg" alt="img"></p>
<h3 id="8-2-2-指令周期的数据流"><a href="#8-2-2-指令周期的数据流" class="headerlink" title="8.2.2 指令周期的数据流"></a>8.2.2 指令周期的数据流</h3><p><img src="https://pic1.zhimg.com/80/v2-16bc0563fc33b007f63f2d9e63426f68_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-ffe1f1639490e88d147dca09c4c2de47_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-33dbaa90facba4a2495551882c24f90f_720w.jpg" alt="img"></p>
<h3 id="8-3-指令流水"><a href="#8-3-指令流水" class="headerlink" title="8.3 指令流水"></a>8.3 指令流水</h3><p><img src="https://pic2.zhimg.com/80/v2-9c16393a72d6dec738963ea01109597d_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-949473d8f05b3a4d70456e9d50928e99_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-2f10fa304075e6bc122a6e389b4b0684_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-cd39fea3beccf163fd0d6def48a60201_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ad13acd1809dd1fad491f9714442f599_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-becee89f33a1e5ea3df31f3b9092e7ba_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5ffd433f519357b941ad2d4210c62d33_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-893f271bc6c0a6feae3ea44895ce9f17_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-4c4c40a9d617570797b2f88cd8e8b525_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-bf6629730222b07b5e76f581d72526ec_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-8af1daee44b1b31895f74c3a6153d196_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-1748e609006890cae417637268e3dc98_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-a1973374365a3c82bca9e67894cdfda3_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-594cc4e23c8d23c851371b284ad6bc09_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5d76326753b746899842a3ad471b5dec_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-086cb08b406587df59d147ad04ceca37_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-eb8c96a902a9ba0b4dc2909dc98b3dca_720w.jpg" alt="img"></p>
<h3 id="8-4-中断系统"><a href="#8-4-中断系统" class="headerlink" title="8.4 中断系统"></a>8.4 中断系统</h3><h3 id="8-4-1-概述"><a href="#8-4-1-概述" class="headerlink" title="8.4.1 概述"></a>8.4.1 概述</h3><p><img src="https://pic1.zhimg.com/80/v2-80d57c2b31ef27adc9ab7c679be9b0d8_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-250f0412c444ce2f9a891190dc20c3ec_720w.jpg" alt="img"></p>
<h3 id="8-4-2-中断请求标记和中断判优逻辑"><a href="#8-4-2-中断请求标记和中断判优逻辑" class="headerlink" title="8.4.2 中断请求标记和中断判优逻辑"></a>8.4.2 中断请求标记和中断判优逻辑</h3><p><img src="https://pic2.zhimg.com/80/v2-182ff5dc96c0788a2631a09787962ae9_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-9979d4fc77823677663af765135194de_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-d997cb8203c7b804b8515e26dba50ef2_720w.jpg" alt="img"></p>
<h3 id="8-4-3-中断服务程序入口地址查询"><a href="#8-4-3-中断服务程序入口地址查询" class="headerlink" title="8.4.3 中断服务程序入口地址查询"></a>8.4.3 中断服务程序入口地址查询</h3><p><img src="https://pic1.zhimg.com/80/v2-7e2503776d875f089d09543062b8608c_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-68e36f17805e16ac5e2e127e6344fa05_720w.jpg" alt="img"></p>
<h3 id="8-4-4-中断响应"><a href="#8-4-4-中断响应" class="headerlink" title="8.4.4 中断响应"></a>8.4.4 中断响应</h3><p><img src="https://pic2.zhimg.com/80/v2-cfab9df5aba6657f37b912518a762a11_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-63c5a6c2a3765c312d85c4a48cb57b53_720w.jpg" alt="img"></p>
<ul>
<li><p>中断隐指令不是实际的指令，而是硬件直接实现的。</p>
</li>
<li><h3 id="8-4-5-保护现场和恢复现场"><a href="#8-4-5-保护现场和恢复现场" class="headerlink" title="8.4.5 保护现场和恢复现场"></a>8.4.5 保护现场和恢复现场</h3><p><img src="https://pic3.zhimg.com/80/v2-c0e5720e9e3654d4fa42bd2fbdb9c43e_720w.jpg" alt="img"></p>
<h3 id="8-4-6-多重中断"><a href="#8-4-6-多重中断" class="headerlink" title="8.4.6 多重中断"></a>8.4.6 多重中断</h3><p><img src="https://pic3.zhimg.com/80/v2-882d0f7425bfc56051ccd580d83a3cde_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-68f647f033e41b0cf03994ba1841b91b_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e0e4e703ba8ef0593e12564e45f67334_720w.jpg" alt="img"></p>
<ul>
<li>通过屏蔽触发器，设置中断屏蔽字，来调整中断的优先级（中断处理的优先级。不是响应的优先级）。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b3cc033a886f5ec6bbf5cd4a7f964404_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-4bc3e67c760a0096729e35c1178c30ad_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-2030b13c2f5eae15eb67b615b41e4fc1_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-10fe213183c5b3f71d10eb25d793dbd7_720w.jpg" alt="img"></p>
<h2 id="9-控制单元的功能"><a href="#9-控制单元的功能" class="headerlink" title="9. 控制单元的功能"></a>9. 控制单元的功能</h2><h3 id="9-1-微操作命令的分析"><a href="#9-1-微操作命令的分析" class="headerlink" title="9.1 微操作命令的分析"></a>9.1 微操作命令的分析</h3><p>完成一条指令分为四个周期：<strong>取指周期、间址周期、执行周期、中断周期。</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-cbb164e1850bc8f37d5498ec2fe0afcf_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-75272039372621007a4554e02dbfb467_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4c6567a97b236e05174123a140221ee6_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b772034c369be1600ba3080f27fadaa3_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-c4faa85fec57c43725466face1829180_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-31cb07c191bcdc5cd668166c4787ad61_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e3f0d0f1ec7a9c3563c31f2a22df2363_720w.jpg" alt="img"></p>
<h3 id="9-2-控制单元的功能"><a href="#9-2-控制单元的功能" class="headerlink" title="9.2 控制单元的功能"></a>9.2 控制单元的功能</h3><p>发出各种控制命令和微指令。</p>
<p><img src="https://pic2.zhimg.com/80/v2-92f9d2ca8721bc62a10c859dcb0da399_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-90bb51feab78c7390e4e01cf30f1866f_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-36c2c4aacffc7e7c43f97164b447ebae_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-7c7fbfdf28804adfee9b7f01efe9c64b_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f1a6d5d012376115300119419afd15d0_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-dfb799edfaf102f4e8973f368c00fc99_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-f13c6d91223963c75cf74d9ba2093ce2_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-945eea3400501415e948088622558fce_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-de7ff8a76adac22577d542cac866c1ae_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-05b22c2344be072bf7ccf6e0bfe658e1_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-6ba1fd7fd49c2dd0d560ecf29cbe84ab_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-46c0e6e495df3496358098356e89437a_720w.jpg" alt="img"></p>
<h2 id="10-控制单元的设计"><a href="#10-控制单元的设计" class="headerlink" title="10. 控制单元的设计"></a>10. 控制单元的设计</h2><h3 id="10-1-组合逻辑设计"><a href="#10-1-组合逻辑设计" class="headerlink" title="10.1 组合逻辑设计"></a>10.1 组合逻辑设计</h3><p><img src="https://pic3.zhimg.com/80/v2-afcdb84d70aba264c94c8bfff7b4d8da_720w.jpg" alt="img"></p>
<ul>
<li><strong>操作码译码只有一条有效，为高电平，对应操作为什么，CU给出对应的一个或几个操作控制信号。</strong>如果是几个都有效，说明这个节拍下，这几个可以并行处理。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-c73a54ec82d4bf5866530b173091ad71_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-0050f5c44453167baf1ee347b30f6208_720w.jpg" alt="img"></p>
<ul>
<li>蓝色的C为控制信号，都是由CU在时钟和IR操作码的控制下，在相应节拍给出的。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-bc2e80321efaf02d3d707a038fd60000_720w.jpg" alt="img"></p>
<ul>
<li>可以并行的微操作，尽可能安排在同一个节拍内。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-f11dd68c4e3c8245d4b0962e7d7a3c8a_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b816d2c4fed11a5f8094e111ef0eb7e3_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-3ce870f40742455d23b1be36d0cf62f2_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-307d20fe27c73c90c3650c5838cd2bcf_720w.jpg" alt="img"></p>
<ul>
<li>1.累加器清零</li>
<li>2.ACC按位取反</li>
<li>3.算术右移操作</li>
<li>4.循环左移操作</li>
<li>5.停机指令</li>
<li>6.加法操作，T0，取操作数，将指令地址码送入MAR，同时读信号；T1，内存中的数据送入MDR；T2，累加器中内容和MDR中数据相加，放在累加器中。</li>
<li>7.将累加器中保存的数据，送到地址为X内存中。</li>
<li>8.load，把内存地址为x的内存中数据，取到累加器中。</li>
<li>9.跳转到给定的地址X</li>
<li>10.分支指令，条件转移，如果上条计算指令结果小于0，则跳到X处</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-cbc0a0637644cd09325e9218cbf719e3_720w.jpg" alt="img"></p>
<p>组合逻辑设计步骤：</p>
<ul>
<li>列出操作的时间表</li>
<li>写出微操作命令的最简表达式</li>
<li>画出逻辑图</li>
</ul>
<h3 id="10-2-微程序设计"><a href="#10-2-微程序设计" class="headerlink" title="10.2 微程序设计"></a>10.2 微程序设计</h3><p>采用微程序设计的方法来实现控制器。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ff433902ea666675f621610151ccb174_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-82a7909d71ee6e6e656768e183efec1f_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-63c59321455516bf050b876d2280f06f_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-cdc52466c06d7ec139de56e63edccc4d_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-288ca719664f9942395818a51f69fc2a_720w.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-d20d3629effd03eacb4fb371d008a947_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-6abed604804893e2835d9d0813fbec01_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5b6419bf237035ed8350f2bee32305d8_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-ae6becb1050d9bf3f42e50ccb23e6424_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f5a0e27e24c66cf765ecc9fb4bf3dad8_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8ec25c5c29ff19fdc37255a43fd558e1_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0266561975bc190b465bf9f75139517a_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-4d988f79331211ea72422a3d7221f824_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-65dabbe80ada4860c1fc99af68e4cd5d_720w.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e7c9426dd54938c3392ee7c9f409f81e_720w.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d5fe8ab2aed1d9db05889bac4f66835d_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-93a53006aae7efca0a3fc3ac78f1b914_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-70c1a78b8f90710483eb238e06d95840_720w.jpg" alt="img"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Operating System</title>
    <url>/2022/04/12/Operating-System/</url>
    <content><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote>
<p>第一章的主要内容是 : 操作系统的一些知识</p>
</blockquote>
<h3 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h3><p>用户角度：操作系统是一个控制软件</p>
<ul>
<li>管理应用程序</li>
<li>为应用程序提供服务</li>
<li>杀死应用程序</li>
<li><span id="more"></span></li>
</ul>
<p>程序角度：操作系统是资源管理器</p>
<ul>
<li>管理外设、分配资源</li>
<li>抽象<ul>
<li>将CPU抽象成进程</li>
<li>将磁盘抽象成文件</li>
<li>将内存抽象成地址空间</li>
</ul>
</li>
</ul>
<h3 id="操作系统层次"><a href="#操作系统层次" class="headerlink" title="操作系统层次"></a>操作系统层次</h3><p>位于硬件之上，应用程序之下。</p>
<h3 id="操作系统的界面和内核"><a href="#操作系统的界面和内核" class="headerlink" title="操作系统的界面和内核"></a>操作系统的界面和内核</h3><p>Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。</p>
<h3 id="操作系统内部组件"><a href="#操作系统内部组件" class="headerlink" title="操作系统内部组件"></a>操作系统内部组件</h3><ul>
<li>CPU调度器</li>
<li>物理内存管理</li>
<li>虚拟内存管理</li>
<li>文件系统管理</li>
<li>中断处理与设备驱动</li>
</ul>
<h3 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h3><ul>
<li>并发<ul>
<li>一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU)</li>
<li>需要OS管理和调度</li>
</ul>
</li>
<li>共享<ul>
<li>“同时”共享</li>
<li>互斥共享</li>
</ul>
</li>
<li>虚拟<ul>
<li>让每一个用户觉得的有一个计算机专门为他服务</li>
</ul>
</li>
<li>异步<ul>
<li>程序是走走停停，而不是一直运行</li>
</ul>
</li>
</ul>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><blockquote>
<p>第二章的主要内容是 : 操作系统的异常&#x2F;中断&#x2F;系统调用</p>
</blockquote>
<h2 id="探究计算机启动过程"><a href="#探究计算机启动过程" class="headerlink" title="探究计算机启动过程"></a>探究计算机启动过程</h2><p><strong>作用解析</strong></p>
<p>Disk : 存放OS和Bootloader</p>
<p>BOIS : 基于I&#x2F;O处理系统</p>
<p>Bootloader : 加载OS，将OS放入内存</p>
<p><strong>结构</strong></p>
<p>Disk</p>
<p>|___ OS</p>
<p>|___ Bootloader</p>
<p><strong>开机流程</strong></p>
<ol>
<li>BIOS<ul>
<li>开机后，寻找显卡和执行BIOS (此时, <code>CS : IP = 0xF000 : 0xFFF0</code>, CS&#x2F;IP 两个寄存器)</li>
<li>将Bootloader从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512M字节的内存)</li>
<li>跳转到 <code>CS : IP = 0x0000 : 0x7C00</code></li>
</ul>
</li>
<li>Bootloader<ul>
<li>将操作系统的代码和数据从硬盘加载到内存中</li>
<li>跳转到操作系统的起始地址</li>
</ul>
</li>
</ol>
<h2 id="中断、异常、系统调用"><a href="#中断、异常、系统调用" class="headerlink" title="中断、异常、系统调用"></a>中断、异常、系统调用</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断来源于外设，来自不同的硬件设备的计时器和网络的中断。</p>
<p><strong>中断流程</strong></p>
<p>硬件：设置中断标记（CPU初始化）</p>
<ol>
<li>将内部、外部事件设置中断标记</li>
<li>中断事件的ID</li>
</ol>
<p>软件</p>
<ol>
<li>保存当前处理状态（寄存器之类的一些数据）</li>
<li>根据中断事件的ID跳转到中断服务程序，中断服务程序处理</li>
<li>清楚中断标记</li>
</ol>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。</p>
<p><strong>异常处理流程</strong></p>
<ol>
<li>保存现场</li>
<li>异常处理<ol>
<li>杀死了产生异常的程序</li>
<li>重新执行异常指令</li>
</ol>
</li>
<li>恢复现场</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用来源于应用程序，应用程序主动向操作系统发出服务请求。程序访问主要是通过高层次的API，而不是直接调用系统调用函数。</p>
<p><strong>APIs</strong></p>
<ul>
<li>Win32 API 用于Windows</li>
<li>POSIX API 用于 POSIX-based systems（包括UNIX，LINUX，Mac OS X）</li>
<li>Java API 用于JAVA虚拟机</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>通常情况下，每个系统调用有对应的序号<ul>
<li>系统调用接口根据这些序号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中预期的系统调用<ul>
<li>并返回系统调用的状态和其他任何返回值</li>
</ul>
</li>
<li>用户不需要知道系统调用是如何实现的<ul>
<li>只需要获取API和了解操作系统将什么作为返回结果</li>
<li>操作系统接口的细节大部分都隐藏在API中</li>
</ul>
</li>
</ul>
<p><strong>用户态</strong>：操作系统运行中，CPU处于的特权级别，不能直接执行特权指令</p>
<p><strong>内核态</strong>：操作系统运行中，CPU处于的特权级别，可以执行任何一条指令</p>
<p><strong>系统调用</strong>：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销</p>
<p><strong>跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性）</strong></p>
<ul>
<li>在执行时间上的开销超过程序调用</li>
<li>开销：<ul>
<li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈</li>
<li>验证参数</li>
<li>内核态映射到用户态的地址空间（更新页面映射权限）</li>
<li>内核态独立地址空间（TLB）</li>
</ul>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th>类型</th>
<th>源头</th>
<th>处理时间</th>
<th>响应</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>外设</td>
<td>异步</td>
<td>持续，对应用程序透明</td>
</tr>
<tr>
<td>异常</td>
<td>应用程序意向不到的行为</td>
<td>同步</td>
<td>杀死或重新执行指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序请求系统提供服务</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody></table>
<blockquote>
<p>异步：应用程序不知道什么时候会发生中断</p>
</blockquote>
<blockquote>
<p>同步：执行到某一条指令一定会发生该事件</p>
</blockquote>
<h3 id="为什么应用程序不能直接访问硬件？"><a href="#为什么应用程序不能直接访问硬件？" class="headerlink" title="为什么应用程序不能直接访问硬件？"></a>为什么应用程序不能直接访问硬件？</h3><ul>
<li>在计算机运行时，内核是被信任的第三方</li>
<li>只有内核可以执行特权指令</li>
<li>为了方便应用程序</li>
</ul>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><blockquote>
<p>第三章的主要内容是 : 操作系统的物理内存管理</p>
</blockquote>
<h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><ol>
<li>CPU</li>
<li>内存</li>
<li>I&#x2F;O</li>
</ol>
<h2 id="内存分层体系"><a href="#内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h2><h3 id="内存分层体系-1"><a href="#内存分层体系-1" class="headerlink" title="内存分层体系"></a>内存分层体系</h3><p>运行内存(主存) &#x2F; 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.</p>
<p>CPU可以访问的内存包括两大类 : 寄存器 &#x2F; cache(L1缓存 &#x2F; L2缓存)</p>
<p><strong>层次</strong></p>
<p>微处理器(CPU访问)</p>
<p>|___CPU寄存器 &#x2F; L1缓存</p>
<p>|___L2缓存</p>
<p>主存(程序访问)</p>
<p>磁盘(程序访问)</p>
<blockquote>
<p>从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。</p>
</blockquote>
<h3 id="内存管理目标"><a href="#内存管理目标" class="headerlink" title="内存管理目标"></a>内存管理目标</h3><ul>
<li>抽象：逻辑地址空间</li>
<li>保护：独立地址空间</li>
<li>共享：访问相同内存</li>
<li>虚拟：更多的地址空间</li>
</ul>
<h3 id="内存管理方法"><a href="#内存管理方法" class="headerlink" title="内存管理方法"></a>内存管理方法</h3><ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
<blockquote>
<p>实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求</p>
</blockquote>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>地址空间的定义</p>
<ul>
<li>物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] )</li>
<li>逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )</li>
</ul>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p>内存碎片问题指的是空闲的内存无法被利用</p>
<ul>
<li>外部碎片 : 分配单元间的未使用内存</li>
<li>内部碎片 : 分配单元内的未使用内存</li>
</ul>
<h3 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h3><p>分区的动态分配方式有以下三种 :</p>
<ol>
<li>第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序</li>
<li>最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序</li>
<li>最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序</li>
</ol>
<p>分配方式的区别</p>
<table>
<thead>
<tr>
<th>分配方式</th>
<th>第一匹配分配</th>
<th>最优适配分配</th>
<th>最差适配分配</th>
</tr>
</thead>
<tbody><tr>
<td>分配方式实现需求</td>
<td>1. 按地址排序的空闲块列表 2. 分配需要寻找一个合适的分区 3. 重分配需要检查是否可以合并相邻空闲分区</td>
<td>1. 按尺寸排序的空闲块列表 2. 分配需要寻找一个合适的分区 3. 重分配需要检查是否可以合并相邻空闲分区</td>
<td>1. 按尺寸排序的空闲块列表 2. 分配最大的分区 3. 重分配需要检查是否可以合并相邻空闲分区</td>
</tr>
<tr>
<td>优势</td>
<td>简单 &#x2F; 易于产生更大空闲块</td>
<td>比较简单 &#x2F; 大部分分配是小尺寸时高效</td>
<td>分配很快 &#x2F; 大部分分配是中尺寸时高效</td>
</tr>
<tr>
<td>劣势</td>
<td>产生外部碎片 &#x2F; 不确定性</td>
<td>产生外部碎片 &#x2F; 重分配慢 &#x2F; 产生很多没用的微小碎片</td>
<td>产生外部碎片 &#x2F; 重分配慢 &#x2F; 易于破碎大的空闲块以致大分区无法被分配</td>
</tr>
</tbody></table>
<blockquote>
<p>三种分配方式并无优劣之分，因为我们无法判断内存请求的大小</p>
</blockquote>
<h2 id="碎片整理方法"><a href="#碎片整理方法" class="headerlink" title="碎片整理方法"></a>碎片整理方法</h2><p>可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p>
<ol>
<li><p>压缩式碎片整理</p>
<ul>
<li>重置程序以合并碎片</li>
<li>要求所有程序是动态可重置的</li>
<li>问题 :<ul>
<li>何时重置 ? (在程序处于等待状态时才可以重置)</li>
<li>需要考虑内存拷贝的开销</li>
</ul>
</li>
</ul>
</li>
<li><p>交换式碎片整理</p>
<ul>
<li><p>运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存</p>
</li>
<li><p>问题 :</p>
<ul>
<li>哪些程序应该被回收 ?</li>
</ul>
</li>
<li><p>情况 :</p>
<p>运行中 : P3</p>
<p>等待中 : P1 P2 P4</p>
<p>内存分布 -&gt; 主存 : OS &#x2F; P1 &#x2F; P3 &#x2F; P2 &#x2F; P4 磁盘 : 空</p>
<p>当P3程序需要更大的内存时 -&gt;</p>
<p>内存分布 -&gt; 主存 : OS &#x2F; P1 &#x2F; P3 &#x2F; P2 磁盘 : P4</p>
</li>
</ul>
</li>
</ol>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><blockquote>
<p>第四章的主要内容是：操作系统的非连续内存分配</p>
</blockquote>
<p>第三章介绍的是连续内存管理, 即 : 操作系统加载到内存以及程序加载到内存中时, 分配一块连续的空闲(内存)块. 但是容易出现碎片问题, 这一章介绍的非连续内存分配可以有效的减少碎片的出现.</p>
<h2 id="非连续内存分配的必要性"><a href="#非连续内存分配的必要性" class="headerlink" title="非连续内存分配的必要性"></a>非连续内存分配的必要性</h2><h3 id="连续内存分配的缺点"><a href="#连续内存分配的缺点" class="headerlink" title="连续内存分配的缺点"></a>连续内存分配的缺点</h3><ol>
<li>分配给一个程序的物理内存是连续的</li>
<li>内存利用率低</li>
<li>有外碎片 &#x2F; 内碎片的问题</li>
</ol>
<h3 id="非连续内存分配的优点"><a href="#非连续内存分配的优点" class="headerlink" title="非连续内存分配的优点"></a>非连续内存分配的优点</h3><ol>
<li>一个程序的物理地址空间是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码与数据(共享库等…)</li>
<li>支持动态加载和动态链接</li>
</ol>
<h3 id="非连续内存分配的缺点"><a href="#非连续内存分配的缺点" class="headerlink" title="非连续内存分配的缺点"></a>非连续内存分配的缺点</h3><ol>
<li>建立虚拟地址和物理地址的转换难度大<ul>
<li>软件方案</li>
<li>硬件方案(采用硬件方案) : 分段 &#x2F; 分页</li>
</ul>
</li>
</ol>
<h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h3><p><strong>段 :</strong> 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 &#x2F; 栈 &#x2F; .bss &#x2F; .data 等</p>
<p>**分段 : ** 更好的分离和共享</p>
<p>程序的分段地址空间如下图所示 :</p>
<p><a href="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067"><img src="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067" alt="img"></a></p>
<p><strong>分段寻址方案</strong></p>
<p>逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联.</p>
<p>一个段 : 一个内存”块”</p>
<p>程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址)</p>
<p>操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制)</p>
<p>物理地址 : 段表中的起始地址 + 二元组中的偏移地址</p>
<h3 id="分页-Paging"><a href="#分页-Paging" class="headerlink" title="分页(Paging)"></a>分页(Paging)</h3><h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>划分物理内存至固定大小的帧(Frame)</p>
<ul>
<li>大小是2的幂, 512 &#x2F; 4096 &#x2F; 8192</li>
</ul>
<p>划分逻辑地址空间至相同大小的页(Page)</p>
<ul>
<li>大小是2的幂, 512 &#x2F; 4096 &#x2F; 8192</li>
</ul>
<p>建立方案 → 转换逻辑地址为物理地址(pages to frames)</p>
<ul>
<li>页表</li>
<li>MMU &#x2F; TLB</li>
</ul>
<p><strong>帧(Frame)</strong></p>
<p>物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移)</p>
<p>帧号 : F位, 共有2^F个帧</p>
<p>帧内偏移 : S位, 每帧有2^S个字节</p>
<p>物理地址 &#x3D; 2^S * f + o</p>
<p>(例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧 物理地址 &#x3D; (3,6) 物理地址 &#x3D; 2^9 * 3 + 6 &#x3D; 1542)</p>
<blockquote>
<p>分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定</p>
</blockquote>
<p><strong>页(Page)</strong></p>
<p>一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 &#x3D; 帧内偏移的大小 页号大小 &lt;&gt; 帧号大小</p>
<p>一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移)</p>
<p>页号 : P位, 共有2^P个页</p>
<p>页内偏移 : S位, 每页有2^S个字节</p>
<p>虚拟地址 &#x3D; 2^S * p + o</p>
<h4 id="页寻址方案"><a href="#页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案</h4><p>操作系统维护一张页表, 页表保存了逻辑地址——物理地址之间的映射关系</p>
<p>存储 : (页号, 帧号)</p>
<ul>
<li>逻辑地址空间应当大于物理内存空间</li>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存(有助于减少碎片的产生)</li>
<li>不是所有的页都有对应的帧</li>
</ul>
<h3 id="页表-Page-Table"><a href="#页表-Page-Table" class="headerlink" title="页表(Page Table)"></a>页表(Page Table)</h3><h4 id="页表概述"><a href="#页表概述" class="headerlink" title="页表概述"></a>页表概述</h4><p>每一个运行的程序都有一个页表</p>
<ul>
<li>属于程序运行状态, 会动态变化</li>
<li>PTBR : 页表基址寄存器</li>
</ul>
<p><strong>转换流程</strong></p>
<p>CPU根据程序的page的页号的若干位, 计算出索引值index, 在页表中搜索这个index, 得到的是帧号, 帧号和原本的offset组成物理地址.</p>
<p>页表中还有一些特殊标志位</p>
<ul>
<li>dirty bit,</li>
<li>resident bit, (0 : 对应的物理页帧在内存中不存在 ; 1 : 存在)</li>
<li>clock &#x2F; reference bit</li>
</ul>
<p><strong>转换实例</strong></p>
<p>16位地址的系统</p>
<ul>
<li>32KB的物理内存</li>
<li>每页的 1024 byte</li>
</ul>
<p>逻辑地址空间 : (4, 0) … (3, 1023)</p>
<p>页表 :</p>
<p>Flags | Frame nums</p>
<p>1 0 1 0 0 0 0 0 → 内存访问异常(可能要杀死程序)</p>
<p>0 1 1 0 0 1 0 0 → 页帧是4 偏移是 1023 → 物理地址 (4, 1023)</p>
<h4 id="分页机制的性能问题"><a href="#分页机制的性能问题" class="headerlink" title="分页机制的性能问题"></a>分页机制的性能问题</h4><p>访问一个内存单元需要2次内存访问</p>
<ul>
<li>一次用于获取页表项</li>
<li>一次用于访问数据</li>
</ul>
<p>页表可能非常大</p>
<ul>
<li>64位机器如果每页1024字节, 那么一个页表的大小会是多少？(2^64 &#x2F; 2^10 &#x3D; 2^54 存放不下)</li>
<li>每一个运行的程序都需要有一个页表</li>
</ul>
<p>如何处理？</p>
<ul>
<li>缓存(Caching)</li>
<li>间接(Indirection)访问</li>
</ul>
<h4 id="转换后备缓冲区-TLB"><a href="#转换后备缓冲区-TLB" class="headerlink" title="转换后备缓冲区(TLB)"></a>转换后备缓冲区(TLB)</h4><p>缓解时间问题</p>
<p>Translation Look-aside Buffer(TLB) 是一个缓冲区. CPU中有快表TLB(可以将经常访问的页表存放在这边)</p>
<p>缓存近期访问的页帧转换表项</p>
<ul>
<li>TLB使用关联内存实现, 具备快速访问性能</li>
<li>如果TLB命中, 物理页号可以很快被获取</li>
<li>如果TLB未命中, 对应的表项被更新到TLB中(x86的CPU由硬件实现, 其他的可能是由操作系统实现)</li>
</ul>
<h4 id="二级-x2F-多级页表"><a href="#二级-x2F-多级页表" class="headerlink" title="二级&#x2F;多级页表"></a>二级&#x2F;多级页表</h4><p>时间换空间</p>
<p>二级页表</p>
<ul>
<li>将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.</li>
<li>一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号</li>
<li>节约了一定的空间, 在一级页表中如果resident bit &#x3D; 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留</li>
</ul>
<p>多级页表</p>
<ul>
<li>通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”</li>
</ul>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>解决大地址空间问题</p>
<p>目的 : 根据帧号获得页号</p>
<p>反向页表只需要存在一张即可</p>
<ul>
<li>有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表</li>
<li>不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间</li>
</ul>
<h5 id="基于页寄存器-Page-Registers-的方案"><a href="#基于页寄存器-Page-Registers-的方案" class="headerlink" title="基于页寄存器(Page Registers)的方案"></a>基于页寄存器(Page Registers)的方案</h5><p>存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小.</p>
<p>每一个帧和一个寄存器关联, 寄存器内容包括 :</p>
<ul>
<li>resident bit : 此帧是否被占用</li>
<li>occupier : 对应的页号 p</li>
<li>protection bits : 保护位</li>
</ul>
<p>实例 :</p>
<ul>
<li>物理内存大小是 : 4096 * 4096 &#x3D; 4K * 4KB &#x3D; 16 MB</li>
<li>页面大小是 : 4096 bytes &#x3D; 4 KB</li>
<li>页帧数 : 4096 &#x3D; 4 K</li>
<li>页寄存器使用的空间(假设8 bytes &#x2F; register) : 8 * 4096 &#x3D; 32 Kbytes</li>
<li>页寄存器带来的额外开销 : 32K &#x2F; 16M &#x3D; 0.2%</li>
<li>虚拟内存大小 : 任意</li>
</ul>
<p>优势 :</p>
<ul>
<li>转换表的大小相对于物理内存来说很小</li>
<li>转换表的大小跟逻辑地址空间的大小无关</li>
</ul>
<p>劣势 :</p>
<ul>
<li>需要的信息对调了, 即根据帧号可以找到页号</li>
<li>如何转换回来? (如何根据页号找到帧号)</li>
<li>在需要在反向页表中搜索想要的页号</li>
</ul>
<h5 id="基于关联内存-associative-memory-的方案"><a href="#基于关联内存-associative-memory-的方案" class="headerlink" title="基于关联内存(associative memory)的方案"></a>基于关联内存(associative memory)的方案</h5><p>硬件设计复杂, 容量不大, 需要放置在CPU中</p>
<ul>
<li>如果帧数较少, 页寄存器可以被放置在关联内存中</li>
<li>在关联内存中查找逻辑页号<ul>
<li>成功 : 帧号被提取</li>
<li>失败 : 页错误异常 (page fault)</li>
</ul>
</li>
<li>限制因素:<ul>
<li>大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)</li>
</ul>
</li>
</ul>
<h5 id="基于哈希-hash-的方案"><a href="#基于哈希-hash-的方案" class="headerlink" title="基于哈希(hash)的方案"></a>基于哈希(hash)的方案</h5><p>哈希函数 : h(PID, p) 从 PID 标号获得页号</p>
<p>在反向页表中通过哈希算法来搜索一个页对应的帧号</p>
<ul>
<li>对页号做哈希计算, 为了在帧表中获取对应的帧号</li>
<li>页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数</li>
<li>为了查找页 i , 执行下列操作 :<ul>
<li>计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器</li>
<li>检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败</li>
</ul>
</li>
</ul>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><blockquote>
<p>第五章的主要内容是：操作系统的虚拟内存管理技术</p>
</blockquote>
<h2 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h2><p>使用硬盘&#x2F;磁盘使更多的程序在有限的内存中运行</p>
<p>理想的存储器 : 更大更快更便宜和非易失性的存储区</p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中</p>
<p>目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用.</p>
<p>原理 :</p>
<p>把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行.</p>
<ul>
<li>必要部分(常用功能)的代码和数据常驻内存;</li>
<li>可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存;</li>
<li>不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区.</li>
</ul>
<blockquote>
<p>也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区.</p>
</blockquote>
<p>实例 :</p>
<p>A(20k) <em><strong>*B(50k) ____ D(30k) | ____ C(30k) ____ E(20k) |*</strong></em> F(40k)</p>
<p>因此不需要将整个程序190k的数据全部放入内存中, 而是划分为 常驻区(20k) 覆盖区0(50k) 覆盖区1(40k) 压缩至了110k的内存空间使用</p>
<p>缺点 :</p>
<ul>
<li>由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度;</li>
<li>覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省.</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中</p>
<p>目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源</p>
<p>原理 :</p>
<p>可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间.</p>
<p>存在问题 :</p>
<ul>
<li>交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出;</li>
<li>交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取</li>
<li>程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法</li>
</ul>
<h2 id="覆盖技术和交换技术的对比"><a href="#覆盖技术和交换技术的对比" class="headerlink" title="覆盖技术和交换技术的对比"></a>覆盖技术和交换技术的对比</h2><p>特点 :</p>
<ul>
<li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构.</li>
<li>交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构.</li>
<li>换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部.</li>
</ul>
<p>在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :</p>
<ul>
<li>覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担.</li>
<li>交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销.</li>
</ul>
<h2 id="虚拟内存管理技术"><a href="#虚拟内存管理技术" class="headerlink" title="虚拟内存管理技术"></a>虚拟内存管理技术</h2><p>如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术</p>
<ul>
<li><p>目标</p>
<p>像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉.</p>
<p>像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换.</p>
</li>
<li><p>程序局部性原理</p>
<p>程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域.</p>
<ul>
<li>时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ;</li>
<li>空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内.</li>
</ul>
<p>程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果.</p>
<p>实例 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述 :</span><br><span class="line">页面大小为4k, 分配给每个进程的物理页面是1. </span><br><span class="line">在一个进程中, 定义了如下的二维数组 int A[1024][1024]. 该数组按行存放在内存, 每一行放在一个页面中.</span><br><span class="line">考虑一下程序的编写方法对缺页率的影响?</span><br><span class="line"></span><br><span class="line">程序编写方法1 : (发生了1024*1024次缺页中断)</span><br><span class="line">for(j = 0; j &lt; 1024; j++)</span><br><span class="line">		for(i = 0; i &lt; 1024; i++)</span><br><span class="line">				A[i][j] = 0;</span><br><span class="line"></span><br><span class="line">程序编写方法2 : (发生了1024次缺页中断)</span><br><span class="line">for(i = 0; i &lt; 1024; i++)</span><br><span class="line">		for(j = 0; j &lt; 1024; j++)</span><br><span class="line">				A[i][j] = 0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本概念</p>
<p>可以在页式或段式内存管理的基础上实现</p>
<ul>
<li>在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行;</li>
<li>在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序;</li>
<li>另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段.</li>
</ul>
</li>
<li><p>基本特征</p>
<ul>
<li>大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB.</li>
<li>部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的;</li>
<li>不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性.</li>
</ul>
</li>
<li><p>虚拟页式内存管理</p>
<p>页式内存管理</p>
<p>页表 : 完成逻辑页到物理页帧的映射</p>
<p>根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址.</p>
<p>虚拟页式内存管理</p>
<ul>
<li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能.</p>
</li>
<li><p>基本思路</p>
<ul>
<li>当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.</li>
<li>在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行.</li>
</ul>
</li>
<li><p>页表表项</p>
<p>逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号</p>
<p>驻留位 : 表示该页是在内存中还是在外存.</p>
<p>保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等</p>
<p>修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存</p>
<p>访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法.</p>
</li>
<li><p>缺页中断处理过程 :</p>
<ol>
<li>如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步;</li>
<li>采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存;</li>
<li>对q所对应的页表项修改, 把驻留位置为0;</li>
<li>将需要访问的页p装入到物理页面f当中;</li>
<li>修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f;</li>
<li>重新运行被中断是指令.</li>
</ol>
<blockquote>
<p>在何处保存未被映射的页?</p>
<ul>
<li>能够简单地识别在二级存储器中的页</li>
<li>交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面</li>
</ul>
</blockquote>
<p>后备存储(二级存储) :</p>
<ul>
<li>一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置</li>
<li>代码段 : 映射到可执行二进制文件</li>
<li>动态加载的共享库程序段 : 映射到动态调用的库文件</li>
<li>其他段 : 可能被映射到交换文件(swap file)</li>
</ul>
</li>
<li><p>虚拟内存性能</p>
<p>为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)</p>
<p>EAT &#x3D; 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率</p>
<p>实例 :</p>
<p>访存时间 : 10 ns</p>
<p>磁盘访问时间 : 5 ms</p>
<p>参数 p &#x3D; page fault 几率</p>
<p>参数 q &#x3D; dirty page 几率(对页面写操作)</p>
<p>EAT &#x3D; 10*(1-p) + 5000000<em>p</em>(1+q)</p>
</li>
</ul>
</li>
</ul>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><blockquote>
<p>第六章的主要内容是：操作系统的虚拟内存管理技术中的页面置换算法</p>
</blockquote>
<h2 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h2><p>功能 : 当缺页中断发生, 需要调入新的页面而内存已满时, 选择内存当中哪个物理页面被置换.</p>
<p>目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数). 具体来说, 把未来不再使用的或短期内较少使用的页面换出, 通常只能在局部性原理指导下依据过去的统计数据来进行预测.</p>
<p>页面锁定 : 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程. 实现的方式是 : 在页表中添加锁定标记位(lock bit).</p>
<h2 id="实验设置与评价方法"><a href="#实验设置与评价方法" class="headerlink" title="实验设置与评价方法"></a>实验设置与评价方法</h2><p>实例 :</p>
<p>记录一个进程对页访问的一个轨迹</p>
<ul>
<li>举例 : 虚拟地址跟踪(页号, 偏移)…<ul>
<li>(3,0) (1,9) (4,1) (2,1) (5,3) (2,0) …</li>
</ul>
</li>
<li>生成的页面轨迹<ul>
<li>3, 1, 4, 2, 5, 2, 1, …</li>
</ul>
</li>
</ul>
<p>模拟一个页面置换的行为并且记录产生页缺失数的数量</p>
<ul>
<li>更少的缺失, 更好的性能</li>
</ul>
<h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>基本思路 : 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面.</p>
<p>这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.</p>
<p>可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法)</p>
<h3 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h3><p>基本思路 : 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾.</p>
<p>性能较差, 调出的页面有可能是经常要访问的页面. 并且有 belady现象. FIFO算法很少单独使用.</p>
<h3 id="最近最久未使用算法"><a href="#最近最久未使用算法" class="headerlink" title="最近最久未使用算法"></a>最近最久未使用算法</h3><p>LRU(Least Recently Used)</p>
<p>基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰.</p>
<p>它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问.</p>
<p>LRU算法需要记录各个页面使用时间的先后顺序, 开销比较大.</p>
<p>两种可能的实现方法是 :</p>
<ul>
<li>系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面.</li>
<li>设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的.</li>
</ul>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>基本思路 :</p>
<p>需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为0. 然后如果这个页面被访问, 则把该位置设为1;</p>
<p>把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来);</p>
<p>当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格.</p>
<p>流程 :</p>
<p>如果访问页在物理内存中, 访问位置1.</p>
<p>如果不在物理页, 从指针当前指向的物理页开始, 如果访问位0, 替换当前页, 指针指向下一个物理页; 如果访问位为1, 置零以后访问下一个物理页再进行判断. 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换.</p>
<h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页.</p>
<p>used dirty → used dirty</p>
<p>0 0 replace</p>
<p>0 1 0 0</p>
<p>1 0 0 0</p>
<p>1 1 0 1</p>
<p>相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会.</p>
<h3 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h3><p>Least Frequently used, LFU</p>
<p>基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰.</p>
<p>实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 当发生缺页中断时, 淘汰计数值最小的那个页面.</p>
<p>LRU和LFU的对比 : LRU考察的是多久未访问, 时间越短越好. 而LFU考察的是访问的次数和频度, 访问次数越多越好.</p>
<h3 id="Belady现象-科学家名字"><a href="#Belady现象-科学家名字" class="headerlink" title="Belady现象(科学家名字)"></a>Belady现象(科学家名字)</h3><p>在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象;</p>
<p>出现原因 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的.</p>
<h3 id="LRU-x2F-FIFO-和-Clock-的比较"><a href="#LRU-x2F-FIFO-和-Clock-的比较" class="headerlink" title="LRU &#x2F; FIFO 和 Clock 的比较"></a>LRU &#x2F; FIFO 和 Clock 的比较</h3><p>LRU和FIFO都是先进先出的思路, 只不过LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法.</p>
<p>例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 …</p>
<h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立?</p>
<ul>
<li>如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断.</li>
<li>如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型.</li>
</ul>
<h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>工作集 : 一个进程当前正在使用的逻辑页面集合.</p>
<p>可以使用一个二元函数 W(t, delta) 来表示 :</p>
<p>t 是当前的执行时刻;</p>
<p>delta 称为工作集窗口, 即一个定长的页面访问的时间窗口;</p>
<p>W(t, delta) &#x3D; 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)</p>
<p>|W(t, delta)| 是工作集的大小, 即逻辑页的数量.</p>
<p>工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值.</p>
<h3 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h3><p>常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.</p>
<ul>
<li>工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法;</li>
<li>如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);</li>
<li>当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降.</li>
</ul>
<h3 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h3><p>当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃.</p>
<h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>可变分配策略 : 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.</p>
<ul>
<li>可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面.</li>
<li>优缺点 : 性能较好, 但增加了系统开销.</li>
<li>具体实现 : 可以使用缺页率算法来动态调整常驻集的大小.</li>
</ul>
<p>缺页率 : 表示 “缺页次数 &#x2F; 内存访问次数”</p>
<p>影响因素 : 页面置换算法, 分配给进程的物理页面数目, 页面本身的大小, 程序的编写方法.</p>
<h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><ul>
<li>如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”.</li>
<li>产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.</li>
</ul>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><blockquote>
<p>第七章的主要内容是：进程</p>
</blockquote>
<h2 id="进程-process-描述"><a href="#进程-process-描述" class="headerlink" title="进程(process)描述"></a>进程(process)描述</h2><h3 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3><p>进程 : 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>进程包括 :</p>
<ul>
<li>程序的代码</li>
<li>程序处理的数据</li>
<li>程序计数器中的值, 指示下一条将运行的指令</li>
<li>一组通用的寄存器的当前值, 堆, 栈</li>
<li>一组系统资源(如打开的文件)</li>
</ul>
<p>进程和程序的联系 :</p>
<ul>
<li>程序是产生进程的基础</li>
<li>程序的每次运行构成不同的进程</li>
<li>进程是程序功能的体现</li>
<li>通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序.</li>
</ul>
<p>进程和程序的区别 :</p>
<ul>
<li>进程是动态的, 程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 &#x2F; 用户态.</li>
<li>进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存.</li>
<li>进程和程序的组成不同 : 进程的组成包括程序, 数据和进程控制块(进程状态信息)</li>
</ul>
<h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><p><strong>动态性</strong> : 可动态地创建, 结果进程;</p>
<p><strong>并发性</strong> : 进程可以被独立调度并占用处理机运行; (并发:一段, 并行:一时刻)</p>
<p><strong>独立性</strong> : 不同进程的工作不相互影响;(页表是保障措施之一)</p>
<p><strong>制约性</strong> : 因访问共享数据, 资源或进程间同步而产生制约.</p>
<blockquote>
<p>抛出了一个问题 : 如果你要设计一个OS, 怎么样来实现其中的进程管理机制?</p>
</blockquote>
<h3 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h3><p>描述进程的数据结构 : 进程控制块 (Process Control Block)</p>
<p>操作系统为每个进程都维护了一个PCB, 用来保存与该进程有关的各种状态信息.</p>
<p><strong>进程控制块 :</strong> 操作系统管理控制进程运行所用的信息集合.</p>
<p>进程的创建 : 为该进程生成一个PCB</p>
<p><strong>进程的终止 :</strong> 回收它的PCB</p>
<p><strong>进程的组织管理 :</strong> 通过对PCB的组织管理来实现</p>
<p>(PCB具体包含什么信息? 如何组织的? 进程的状态转换?)</p>
<p><strong>PCB有以下三大类信息 :</strong></p>
<ul>
<li>进程标志信息. 如本进程的标志, 本进程的产生者标志(父进程标志). 用户标志</li>
<li>处理机状态信息保存区 : 保存进程的运行现场信息 :<ul>
<li>用户可见寄存器. 用户程序可以使用的数据, 地址等寄存器</li>
<li>控制和状态寄存器. 如程序计数器(PC), 程序状态字(PSW)</li>
<li>栈指针. 过程调用, 系统调用, 中断处理和返回时需要用到它</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>调度和状态信息. 用于操作系统调度进程并占用处理机使用.</li>
<li>进程间通信信息. 为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中.</li>
<li>存储管理信息. 包含有指向本进程映像存储空间的数据结构.</li>
<li>进程所用资源. 说明由进程打开, 使用的系统资源. 如打开的文件等.</li>
<li>有关数据结构的链接信息. 进程可以连接到一个进程队列中, 或连接到相关的其他进程的PCB.</li>
</ul>
</li>
</ul>
<p><strong>进程的组织方式</strong></p>
<p>链表 : 同一状态的进程其PCB成一链表, 多个状态对应多个不同的链表.(各状态的进程形成不同的链表 : 就绪链表, 阻塞链表)</p>
<p>索引表 : 同一状态的进程归入一个index表(由index指向PCB), 多个状态对应多个不同的index表(各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表)</p>
<h2 id="进程状态-state"><a href="#进程状态-state" class="headerlink" title="进程状态(state)"></a>进程状态(state)</h2><h3 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>引起进程创建的3个主要事件 :</p>
<ul>
<li>系统初始化;</li>
<li>用户请求创建一个新进程;</li>
<li>正在运行的进程执行了创建进程的系统调用.</li>
</ul>
<h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p>内核选择一个就绪的进程, 让它占用处理机并执行</p>
<p>(为何选择?如何选择?)</p>
<h4 id="进程等待-阻塞"><a href="#进程等待-阻塞" class="headerlink" title="进程等待(阻塞)"></a>进程等待(阻塞)</h4><p>在以下情况下, 进程等待(阻塞):</p>
<ol>
<li>请求并等待系统服务, 无法马上完成</li>
<li>启动某种操作, 无法马上完成</li>
<li>需要的数据没有到达</li>
</ol>
<p>进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生.</p>
<h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>唤醒进程的原因 :</p>
<ol>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
<li>将该进程的PCB插入到就绪队列</li>
</ol>
<p>进程只能被别的进程或操作系统唤醒</p>
<h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p>在以下四种情况下, 进程结束 :</p>
<ul>
<li>正常退出(自愿)</li>
<li>错误退出(自愿)</li>
<li>致命错误(强制性)</li>
<li>被其他进程杀死(强制性)</li>
</ul>
<h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p><strong>进程的三种基本状态 :</strong> 进程在生命结束前处于三种基本状态之一.</p>
<p>不同系统设置的进程状态数目不同.</p>
<p><strong>三种基本状态</strong></p>
<ol>
<li>运行状态(Running) : 当一个进程正在处理机上运行时</li>
<li>就绪状态(Ready) : 一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行</li>
<li>等待状态(阻塞状态 Blocked) : 一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入&#x2F;输出完成.</li>
</ol>
<p><strong>进程其它的基本状态</strong></p>
<p>创建状态(New) : 一个进程正在被创建, 还没被转到就绪状态之前的状态</p>
<p>结束状态(Exit): 一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致.</p>
<p><strong>可能的状态变化如下 :</strong></p>
<p>NULL → New : 一个新进程被产生出来执行一个程序</p>
<p>New → Ready: 当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态</p>
<p>Ready → Running : 处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行</p>
<p>Running → Exit : 当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理</p>
<p>Running → Ready : 处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机</p>
<p>Running → Blocked: 当进程请求某样东西且必须等待时</p>
<p>Blocked → Ready : 当进程要等待某事件到来时, 它从阻塞状态变到就绪状态</p>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p>进程挂起, 为了合理且充分地利用系统资源.</p>
<p>进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上.(把进程放到磁盘上)</p>
<p><strong>两种挂起状态</strong></p>
<ol>
<li>阻塞挂起状态 : 进程在外存并等待某事件的出现;</li>
<li>就绪挂起状态 : 进程在外存, 但只要进入内存, 即可运行.</li>
</ol>
<p><strong>与挂起相关的状态转换</strong></p>
<p><strong>挂起 :</strong> 把一个进程从内存转到外存, 可能有以下几种情况 :</p>
<ul>
<li>阻塞到阻塞挂起 : 没有进程处于就绪状态或就绪进程要求更多内存资源时, 会进行这种转换, 以提交新进程或运行时就绪进程.</li>
<li>就绪到就绪挂起 : 当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级就绪进程时, 系统会选择挂起低优先级就绪进程.</li>
<li>运行到就绪挂起 : 对抢先式分时系统, 当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时, 系统可能会把运行进程转导就绪挂起状态.</li>
</ul>
<p><strong>在外存时的状态转换 :</strong></p>
<ul>
<li>阻塞挂起到就绪挂起 : 当有阻塞挂起因相关事件出现时, 系统会把阻塞挂起进程转换为就绪挂起进程.</li>
</ul>
<p><strong>解挂, 激活 :</strong> 把一个进程从外存转到内存; 可能有以下几种情况 :</p>
<ul>
<li>就绪挂起到就绪 : 没有就绪进程或挂起就绪进程优先级高于就绪进程时, 会进行这种转换.</li>
<li>阻塞挂起到阻塞 : 当一个进程释放足够内存时, 系统会把一个高优先级阻塞挂起(系统认为会很快出现所等待的事件)进程转换为阻塞进程.</li>
</ul>
<blockquote>
<p>抛出一个问题 : OS怎么通过PCB和定义的进程状态来管理PCB, 帮助完成进程的调度过程?</p>
</blockquote>
<h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><ul>
<li>由操作系统来维护一组队列, 用来表示系统当中所有进程的当前状态;</li>
<li>不同的状态分别用不同的队列来表示(就绪队列, 各种类型的阻塞队列);</li>
<li>每个进程的PCB都根据它的状态加入到相应的队列当中, 当一个进程的状态发生变化时, 它的PCB从一个状态中脱离出来, 加入到另外一个队列.</li>
</ul>
<h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h2><h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程?"></a>为什么使用线程?</h3><p>实例 : 编写一个MP3播放软件.</p>
<p>核心功能 : (1)从MP3音频文件中读取数据; (2)对数据进行解压缩; (3)把解压缩后的音频数据播放出来.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单进程方式</span><br><span class="line">while(1)&#123;</span><br><span class="line">	Read();</span><br><span class="line">	Decompress();</span><br><span class="line">	Play();</span><br><span class="line">&#125;</span><br><span class="line">//问题: 播放出来的声音能否连贯? 各个函数之间不是并发执行, 影响资源的使用效率.</span><br><span class="line">//多进程</span><br><span class="line">//进程1</span><br><span class="line">while(1)&#123;</span><br><span class="line">	Read();</span><br><span class="line">&#125;</span><br><span class="line">//进程2</span><br><span class="line">while(1)&#123;</span><br><span class="line">	Decompress();</span><br><span class="line">&#125;</span><br><span class="line">//进程3</span><br><span class="line">while(1)&#123;</span><br><span class="line">	Play();</span><br><span class="line">&#125;</span><br><span class="line">//问题: 进程之间如何通信,共享数据?另外,维护进程的系统开销较大:</span><br><span class="line">//创建进程时,分配资源,建立PCB;撤销进程时,回收资源,撤销PCB;进程切换时,保存当前进程的状态信息</span><br></pre></td></tr></table></figure>

<p>因此需要提出一种新的实体, 满足以下特征:</p>
<ol>
<li>实体之间可以并发执行;</li>
<li>实体之间共享相同的地址空间.</li>
</ol>
<p>这实体就是线程.</p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程是进程当中的一条执行流程.</p>
<p>从两个方面重新理解进程:</p>
<ol>
<li>从资源组合的角度: 进程把一组相关的资源组合起来,构成了一个资源平台(环境),包括地址空间(代码段,数据段),打开的文件等各种资源;</li>
<li>从运行的角度: 代码在这个资源平台上的一条执行流程(线程).</li>
</ol>
<p>线程 &#x3D; 进程 - 共享资源</p>
<h3 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h3><p>线程的优点:</p>
<ul>
<li>一个进程中可以同时存在多个线程;</li>
<li>各个线程之间可以并发地执行;</li>
<li>各个线程之间可以共享地址空间和文件等资源.</li>
</ul>
<p>线程的缺点:</p>
<ul>
<li><p>一个线程崩溃, 会导致其所属进程的所有线程崩溃.(给它了”权限”就得有更高的”责任”)</p>
</li>
<li><p>线程所需的资源</p>
<p>不同的线程需要独立的寄存器和堆栈, 共享代码,数据和文件等.</p>
</li>
</ul>
<h3 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h3><ul>
<li>进程是资源分配单位, 线程是CPU调度单位;</li>
<li>进程拥有一个完整的资源平台, 而线程只独享必不可少的资源, 如寄存器和栈;</li>
<li>线程同样具有就绪,阻塞和执行三种基本状态,同样具有状态之间的转换关系;</li>
<li>线程能减少并发执行的时间和空间开销:<ul>
<li>线程的创建时间比进程短;(直接利用所属进程的一些状态信息)</li>
<li>线程的终止时间比进程短;(不需要考虑把这些状态信息给释放)</li>
<li>同一进程内的线程切换时间比进程短;(同一进程不同线程的切换不需要切换页表)</li>
<li>由于同一进程的各线程之间共享内存和文件资源, 可直接进行不通过内核的通信.(直接通过内存地址读写资源)</li>
</ul>
</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式:</p>
<ul>
<li>用户线程 : 在用户空间实现; POSIX Pthreads, Mach C-threads, Solaris threads</li>
<li>内核线程 : 在内核中实现; Windows, Solaris, Linux</li>
<li>轻量级进程: 在内核中实现,支持用户线程; Solaris</li>
</ul>
<p><strong>用户线程</strong></p>
<p>操作系统只能看到进程, 看不到线程, 线程的TCB在线程库中实现;</p>
<p>在用户空间实现的线程机制, 它不依赖于操作系统的内核, 由一组用户级的线程库来完成线程的管理, 包括进程的创建,终止,同步和调度等.</p>
<ul>
<li>由于用户线程的维护由相应的进程来完成(通过线程库函数),不需要操作系统内核了解用户进程的存在,可用于不支持线程技术的多进程操作系统;</li>
<li>每个进程都需要它自己私有的线程控制块(TCB)列表,用来跟踪记录它的各个线程的状态信息(PC,栈指针,寄存器),TCB由线程库函数来维护;</li>
<li>用户线程的切换也是由线程库函数来完成,无需用户态&#x2F;核心态切换,所以速度特别快;</li>
<li>允许每个进程拥有自定义的线程调度算法.</li>
</ul>
<p>用户线程的缺点:</p>
<ul>
<li>阻塞性的系统调用如何实现?如果一个线程发起系统调用而阻塞,则整个进程在等待;</li>
<li>当一个线程开始运行时,除非它主动地交出CPU的使用权,否则它所在的进程当中的其他线程将无法运行;</li>
<li>由于时间片分配给进程,所以与其他进程比,在多线程执行时,每个线程得到的时间片较少,执行会较慢.</li>
</ul>
<p><strong>内核线程</strong></p>
<p>操作系统能够看到进程也可能看到线程,线程在内核中实现;</p>
<p>内核线程是在操作系统的内核当中实现的一种线程机制,由操作系统的内核来完成线程的创建,终止和管理.</p>
<ul>
<li>在支持内核线程的操作系统中,由内核来维护进程和线程的上下文信息(PCB和TCB);</li>
<li>线程的创建,终止和切换都是通过系统调用,内核函数的方式来进行,由内核来完成,因此系统开销较大;</li>
<li>在一个进程当中,如果某个内核线程发起系统调用而被阻塞,并不会影响其他内核线程的运行;</li>
<li>时间片分配给线程,多线程的进程获得更多CPU时间;</li>
<li>Windows NT 和 Windows 2000&#x2F;XP 支持内核线程.</li>
</ul>
<p><strong>轻量级进程</strong></p>
<p>它是内核支持的用户线程.一个进程可以有一个或多个轻量化进程,每个量级进程由一个单独的内核线程来支持.(Solaris,Linux)</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>停止当前运行进程(从运行状态变成其他状态),并且调度其他进程(转变为运行状态)</p>
<ul>
<li>必须在切换之前存储许多部分的进程上下文</li>
<li>必须能够在之后恢复他们,所以进程不能显示它曾经被暂停过</li>
<li>必须快速(上下文切换时非常频繁)</li>
</ul>
<p>需要存储什么上下文?</p>
<ul>
<li>寄存器(PC,SP…),CPU状态等信息</li>
<li>一些时候可能会费时,所以我们应该尽可能避免</li>
</ul>
<p>操作系统为活跃进程准备了进程控制块</p>
<p>操作系统将进程控制块放置在一个合适的队列中</p>
<ul>
<li>就绪队列</li>
<li>等待IO队列(每个设备的队列)</li>
<li>僵尸队列</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>fork()的简单实现</p>
<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和CPU寄存器到子进程</li>
<li>开销昂贵</li>
</ul>
<p>在99%的情况下,我们在调用fork()之后调用exec()</p>
<ul>
<li>在fork()操作中内存复制是没有作用的</li>
<li>子进程将可能关闭打开的文件和连接</li>
<li>开销因此是最高的</li>
<li>为什么不能结合它们在一个调用中(OS&#x2F;2, windows)?</li>
</ul>
<p>vfork()</p>
<ul>
<li>一个创建进程的系统调用,不需要创建一个同样的内存映像</li>
<li>一些时候称为轻量级fork()</li>
<li>子进程应该几乎立即调用exec()</li>
<li>现在不再使用如果我们使用 copy on write 技术</li>
</ul>
<h3 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h3><p>系统调用exec()加载程序取代当前运行的进程</p>
<p>exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)</p>
<p>它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)</p>
<p>如果调用成功(相同的进程,不同的程序)</p>
<p>代码,stack,heap重写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pid = fork(); //创建子进程</span><br><span class="line">if(pid == 0) &#123;    //子进程</span><br><span class="line">	exec_status = exec(&quot;calc&quot;, argc, argv0,argv1,...);</span><br><span class="line">	printf(&quot;Why would I execute?&quot;);</span><br><span class="line">&#125; else if(pid &gt; 0) &#123; //父进程</span><br><span class="line">	printf(&quot;Whose your daddy?&quot;);</span><br><span class="line">	...</span><br><span class="line">	child_status = wait(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h3><p>wait()系统调用是被父进程用来等待子进程的结束</p>
<ul>
<li>一个子进程向父进程返回一个值,所以父进程必须接受这个值并处理</li>
<li>wait()系统调用担任这个要求<ul>
<li>它使父进程去睡眠来等待子进程的结束</li>
<li>当一个子进程调用exit()的时候,操作系统解锁父进程,并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起)如果这里没有子进程存活,wait()立刻返回</li>
<li>当然,如果这里有为父进程的僵尸等待,wait()立即返回其中一个值(并且解除僵尸状态)</li>
</ul>
</li>
<li>进程结束执行之后,它调用exit()</li>
<li>这个系统调用:<ul>
<li>将这程序的”结果”作为一个参数</li>
<li>关闭所有打开的文件,连接等等</li>
<li>释放内存</li>
<li>释放大部分支持进程的操作系统结构</li>
<li>检查是否父进程是存活着的:<ul>
<li>如果是的话,它保留结果的值直到父进程需要它;在这种情况里,进程没有真正死亡,但是它进入了僵尸状态</li>
<li>如果没有,它释放所有的数据结构,这个进程死亡</li>
</ul>
</li>
<li>清理所有等待的僵尸进程</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集(资源回收)</li>
</ul>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><blockquote>
<p>第八章的主要内容是：调度算法(感觉清华这门课程前几章比较精彩,后续讲的有点混乱)</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="上下文切换-1"><a href="#上下文切换-1" class="headerlink" title="上下文切换"></a>上下文切换</h3><ul>
<li>切换CPU的当前任务, 从一个进程&#x2F;线程到另一个</li>
<li>保存当前进程&#x2F;线程在PCB&#x2F;TCB中的执行上下文(CPU状态)</li>
<li>读取下一个进程&#x2F;线程的上下文</li>
</ul>
<h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><ul>
<li>从就绪队列中挑选一个进程&#x2F;线程作为CPU将要运行的下一个进程&#x2F;线程</li>
<li>调度程序: 挑选进程&#x2F;线程的内核函数(通过一些调度策略)</li>
<li>什么时候进行调度?</li>
</ul>
<h3 id="内核运行调度程序的条件-满足一条即可"><a href="#内核运行调度程序的条件-满足一条即可" class="headerlink" title="内核运行调度程序的条件(满足一条即可)"></a>内核运行调度程序的条件(满足一条即可)</h3><ul>
<li>一个进程从运行状态切换到等待状态</li>
<li>一个进程被终结</li>
</ul>
<h3 id="不可抢占"><a href="#不可抢占" class="headerlink" title="不可抢占"></a>不可抢占</h3><ul>
<li>调度程序必须等待事件结束</li>
</ul>
<h3 id="可以抢占"><a href="#可以抢占" class="headerlink" title="可以抢占"></a>可以抢占</h3><ul>
<li>调度程序在中断被相应后执行</li>
<li>当前的进程从运行切换到就绪, 或者一个进程从等待切换到就绪</li>
<li>当前运行的进程可以被换出</li>
</ul>
<h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><ul>
<li><p>调度策略</p>
<p>人们通常都需要”更快”的服务</p>
<p>什么是更快?</p>
<ul>
<li>传输文件时的高带宽</li>
<li>玩游戏时的低延迟</li>
<li>这两个因素是独立的</li>
</ul>
<p>和水管类比</p>
<ul>
<li>低延迟: 喝水的时候想要一打开水龙头水就流出来</li>
<li>高带宽: 给游泳池充水时希望从水龙头里同时流出大量的水,并且不介意是否存在延迟</li>
</ul>
<p>我们的目标:</p>
<ul>
<li>减少响应时间: 及时处理用户的输出并且尽快将输出提供给用户</li>
<li>减少平均响应时间的波动: 在交互系统中,可预测性比高差异性低平均更重要</li>
<li>增加吞吐量: 减少开销(操作系统开销,上下文切换);系统资源的高效率用(CPU,IO设备)</li>
<li>减少等待时间: 减少每个进程的等待时间</li>
</ul>
</li>
<li><p>程序执行模型</p>
<p>执行模型 : 程序在CPU突发和IO中交替</p>
<ul>
<li>每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU</li>
<li>在时间分片机制下,线程可能在结束当前CPU突发前被迫放弃CPU</li>
</ul>
</li>
<li><p>评价指标</p>
<p>CPU使用率: CPU处于忙状态所占时间的百分比</p>
<p>吞吐量: 在单位时间内完成的进程数量</p>
<p>周转时间: 一个进程从初始化到结束,包括所有等待时间所花费的时间</p>
<p>等待时间: 进程在就绪队列中的总时间</p>
<p>响应时间: 从一个请求被提交到产生第一次相应所花费的总时间</p>
<p>各指标在操作系统上的表现:</p>
<p>低延迟调度增加了交互式表现(如果移动了鼠标,但是屏幕中的光标却没动,我们可能会重启电脑)</p>
<p>操作系统需要保证低吞吐量不受影响(我想要结束长时间的编程,所以操作系统必须不时进行调度,即使存在许多交互任务)</p>
<p>吞吐量是操作系统的计算带宽</p>
<p>响应时间是操作系统的计算延迟</p>
</li>
<li><p>公平的目标</p>
<p>举例:</p>
<ul>
<li>保证每个进程占用相同的CPU时间</li>
<li>这公平嘛?如果一个用户比其他用户运行更多的进程怎么办</li>
</ul>
<p>举例:</p>
<ul>
<li>保证每个进程都等待相同的时间</li>
</ul>
<p>公平通常会增加平均响应时间</p>
</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul>
<li><p><strong>FCFS(先来先服务)</strong></p>
<p>First come, First Served</p>
<p>如果进程在执行中阻塞,队列中的下一个会得到CPU</p>
<p>优点: 简单</p>
<p>缺点:</p>
<ul>
<li>平均等待时间波动较大</li>
<li>花费时间少的任务可能排在花费时间长的任务后面</li>
<li>可能导致IO和CPU之间的重叠处理(CPU密集型进程会导致IO设备闲置时,IO密集型进程也在等待)</li>
</ul>
</li>
<li><p><strong>SPN(SJF) SRT(短进程优先(短作业优先)短剩余时间优先)[最优平均等待时间]</strong></p>
<p>Shortest Process Next(Shortest Job First) Shortest Remaining Time</p>
<p>选择预测的完成时间来将任务入队</p>
<p>可以是抢占的或者是不可抢占的</p>
<p>可能导致饥饿</p>
<ul>
<li>连续的短任务流会使场任务饥饿</li>
<li>短任务可用时的任何场任务的CPU时间都会增加平均等待时间</li>
</ul>
<p>需要预测未来</p>
<ul>
<li>怎么预估下一个CPU突发的持续时间</li>
<li>简单的解决: 询问用户</li>
<li>如果用户欺骗就杀死进程</li>
<li>如果不知道怎么办?</li>
</ul>
</li>
<li><p><strong>HRRN(最高响应比优先)</strong></p>
<p>Highest Response Ratio Next</p>
</li>
<li><p><strong>Round Robin(轮循)</strong></p>
<p>使用时间切片和抢占来轮流执行任务</p>
<p>在叫做量子(或者时间切片)的离散单元中分配处理器</p>
<p>时间片结束时,切换到下一个准备好的进程</p>
<p>花销: 额外的上下文切换</p>
<p>时间量子太大:</p>
<ul>
<li>等待时间过长</li>
<li>极限情况退化成FCFS</li>
</ul>
<p>时间量子太小:</p>
<ul>
<li>反应迅速</li>
<li>吞吐量由于大量的上下文切换开销受到影响</li>
</ul>
<p>目标:</p>
<ul>
<li>选择一个合适的时间量子</li>
<li>经验规则: 维持上下文切换开销处于1%以内</li>
</ul>
</li>
<li><p><strong>Multilevel Feedback Queues(多级反馈队列)</strong></p>
<p>优先级队列中的轮循</p>
<p>就绪队列被划分成独立的队列: 比如前台(交互),后台(批处理)</p>
<p>每个队列拥有自己的调度策略: 比如前台(RR),后台(FCFS)</p>
<p>调度必须在队列间进行:</p>
<ul>
<li>固定优先级: 先处理前台,然后处理后台;可能导致饥饿</li>
<li>时间切片: 每个队列都得到一个确定的能够调度其进程的CPU总时间;比如80%使用RR的前台,20%使用FCFS的后台</li>
</ul>
<p>一个进程可以在不同的队列中移动</p>
<p>例如,n级优先级-优先级调度在所有级别中,RR在每个级别中</p>
<ul>
<li>时间量子大小随优先级级别增加而增加</li>
<li>如果任务在当前的时间量子中没有完成,则降到下一个优先级</li>
</ul>
<p>优点: CPU密集型任务的优先级下降很快;IO密集型任务停留在高优先级</p>
</li>
<li><p><strong>Fair Share Scheduling(公平共享调度)</strong></p>
<p>FSS控制用户对系统资源的访问</p>
<ul>
<li>一些用户组比其他用户组更重要</li>
<li>保证不重要的组无法垄断资源</li>
<li>未使用的资源按照每个组所分配的资源的比例来分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级</li>
</ul>
</li>
</ul>
<h2 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h2><p>确定性建模: 确定一个工作量,然后计算每个算法的表现</p>
<p>队列模型: 用来处理随机工作负载的数学方法</p>
<p>实现&#x2F;模拟: 建立一个允许算法运行实际数据的系统;最灵活,最具一般性</p>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><ul>
<li><p>实时系统</p>
<p>定义: 正确性依赖于其时间和功能两方面的一个操作系统</p>
<p>性能指标: 时间约束的及时性;速度和平均性能相对不重要</p>
<p>主要特征: 时间约束的可预测性</p>
<p>分类:</p>
<ul>
<li>强实时系统: 需要在保证时间内完成重要的任务,必须完成</li>
<li>弱实时系统: 要求重要的进程的优先级更高,尽量完成,并非必须</li>
</ul>
<p>任务(工作单元): 一次计算,一次文件读取,一次信息传递等</p>
<p>属性: 去的进展所需要的资源;定时参数.</p>
</li>
<li><p>单调速率(RM)</p>
<ul>
<li>最佳静态优先级调度</li>
<li>通过周期安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期最短的任务</li>
</ul>
</li>
<li><p>截止日期最早优先(EDF)</p>
<ul>
<li>最佳的动态优先级调度</li>
<li>Deadline越早优先级越高</li>
<li>执行Deadline最早的任务</li>
</ul>
</li>
</ul>
<h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>多处理器的CPU调度更复杂:</p>
<ul>
<li>多个相同的单处理器组成一个多处理器</li>
<li>优点: 复杂共享</li>
</ul>
<p>对称多处理器(SMP)</p>
<ul>
<li>每个处理器运行自己的调度程序</li>
<li>需要在调度程序中同步</li>
</ul>
<h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p>可以发生在任务基于优先级的可抢占的调度机制中</p>
<p>当系统内的环境强制使高优先级任务等待低优先级任务时发生</p>
<h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><blockquote>
<p>第九章的主要内容是：同步</p>
</blockquote>
<h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>第一章到第八章内容, 到目前为止</p>
<ul>
<li>多道程序设计: 现代操作系统的重要特性</li>
<li>并行很有用(为什么?) 提示: 多个并发实体: CPU IO 用户 等</li>
<li>进程,线程: 操作系统抽象出来用于支持多道程序设计</li>
<li>CPU调度: 实现多道程序设计的机制</li>
<li>调度算法: 不同的策略</li>
</ul>
<p>独立的线程:</p>
<ul>
<li>不和其他线程共享资源或状态</li>
<li>确定性: 输入状态决定结果</li>
<li>可重现: 能够重现起始条件, IO</li>
<li>调度顺序不重要</li>
</ul>
<p>合作线程:</p>
<ul>
<li>在多个线程中共享状态</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
<p>不确定性和不可重现意味着bug可能是间歇性发生的</p>
<p>进程,线程;计算机,设备需要合作</p>
<p>合作优点:</p>
<ol>
<li>共享资源<ul>
<li>一台电脑,多个用户</li>
<li>一个银行存款余额,多台ATM机</li>
<li>嵌入式系统</li>
</ul>
</li>
<li>加速<ul>
<li>IO操作和计算可以重叠</li>
<li>多处理器</li>
</ul>
</li>
<li>模块化<ul>
<li>将大程序分解成小程序 gcc会调用cpp,cc1,cc2,as,ld</li>
<li>使系统易于扩展</li>
</ul>
</li>
</ol>
<p>程序可以调用函数fork()来创建一个新的进程</p>
<ul>
<li>操作系统需要分配一个新的并且唯一的进程ID</li>
<li>因此在内核中,这个系统调用会运行 new_pid &#x3D; next_pid++;</li>
<li>翻译成机器指令:<ul>
<li>Load next_pid Reg1</li>
<li>STORE Reg1 new_pid</li>
<li>INC Reg1</li>
<li>STORE Reg1 next_pid</li>
</ul>
</li>
</ul>
<p>假设两个进程并发执行</p>
<ul>
<li>如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102</li>
<li>可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101</li>
</ul>
<p>无论多个线程的指令序列怎样交替执行,程序都必须正常工作</p>
<ul>
<li>多线程程序具有不确定性和不可重现的特点</li>
<li>不经过专门设计,调试难度很高</li>
</ul>
<p>不确定性要求并行程序的正确性</p>
<ul>
<li>先思考清楚问题,把程序的行为设计清楚</li>
<li>切忌给予着手编写代码,碰到问题再调试</li>
</ul>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>前面的现象称为Race Condition(竞态条件)</p>
<p>系统缺陷: 结果依赖于并发执行或者时间的顺序,时间</p>
<ul>
<li>不确定性</li>
<li>不可重现</li>
</ul>
<p>怎么样避免竞态?</p>
<p>Atomic Operator(原子操作)</p>
<p>原子操作是指一次不存在任何终端或者失败的执行</p>
<ul>
<li>该执行成功结束</li>
<li>或者根本没有执行</li>
<li>并且不应发生任何部分执行的状态</li>
</ul>
<p>实际上操作往往不是原子的</p>
<ul>
<li>有些看上去是原子操作,实际上不是</li>
<li>连x++这样的简单语句,实际上是由三条指令构成的</li>
<li>有时候甚至连单条假期指令都不是原子的(Pipeline,super-scalar,out-of-order,pape fault)</li>
</ul>
<p>临界区(Critical section)是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域</p>
<p>互斥(Mutual exclusion)是指当一个 进程处于临界区并访问共享资源时,没有其他进程会处于临界区并且访问任何相同的共享资源</p>
<p>死锁(Dead lock)是指两个或以上进程,在相互等待完成特定任务,而最终没法将自身任务进行下去</p>
<p>饥饿(Starvation)是指一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行</p>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>互斥: 同一时间临界区中最多存在一个线程</p>
<p>Progress: 如果一个线程想要进入临界区,那么它最终会成功</p>
<p>有限等待: 如果一个线程i处于入口区,那么在i的请求被接受之前,其他线程进入临界区的时间是有限制的</p>
<p>无忙等待(可选): 如果一个进程在等待进入临界区,那么在它可以进入之前会被挂起</p>
<h2 id="方法1-禁用硬件中断"><a href="#方法1-禁用硬件中断" class="headerlink" title="方法1:禁用硬件中断"></a>方法1:禁用硬件中断</h2><p>没有中断,没有上下文切换,因此没有并发</p>
<ul>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>大多数现代计算机体系结构都提供指令来完成</li>
</ul>
<p>进入临界区</p>
<ul>
<li>禁用中断</li>
</ul>
<p>离开临界区</p>
<ul>
<li>开启中断</li>
</ul>
<p>一旦中断被禁用,线程就无法被停止</p>
<ul>
<li>整个系统都会为你停下来</li>
<li>可能导致其他线程处于饥饿状态</li>
</ul>
<p>要是临界区可以任意长怎么办?</p>
<ul>
<li>无法限制响应中断所需的时间(可能存在硬件影响)</li>
</ul>
<p>要小心使用,适合于较小的操作</p>
<h2 id="方法2-基于软件的解决方案"><a href="#方法2-基于软件的解决方案" class="headerlink" title="方法2:基于软件的解决方案"></a>方法2:基于软件的解决方案</h2><p>满足进程Pi和Pj之间互斥的经典的基于软件的解决方法(1981年)</p>
<p>使用两个共享数据项</p>
<ul>
<li>int turn; &#x2F;&#x2F;指示该谁进入临界区</li>
<li>bool flag[]; &#x2F;&#x2F;指示进程是否准备好进入临界区</li>
</ul>
<p>进入临界区:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag[i] = true;</span><br><span class="line">turn = j;</span><br><span class="line">while(flag[j] &amp;&amp; turn == j);</span><br></pre></td></tr></table></figure>

<p>退出临界区:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag[i] = false;</span><br></pre></td></tr></table></figure>

<p>实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">	flag[i] = true;</span><br><span class="line">	turn = j;</span><br><span class="line">	while(flag[j] &amp;&amp; turn == j);</span><br><span class="line">	CRITICAL SECTION</span><br><span class="line">	flag[i] = false;</span><br><span class="line">	REMAINDER SECTION</span><br><span class="line">&#125;while(true);</span><br></pre></td></tr></table></figure>

<p>Bakery 算法(N个进程的临界区)</p>
<ul>
<li>进入临界区之前,进程接收一个数字</li>
<li>得到的数字最小的进入临界区</li>
<li>如果进程Pi和Pj收到相同的数字,那么如果i&lt;j,Pi先进入临界区,否则Pj先进入临界区</li>
<li>编号方案总是按照枚举的增加顺序生成数字</li>
</ul>
<p>Dekker算法(1965): 第一个针对双线程例子的正确解决方案</p>
<p>Bakery算法(1979): 针对n线程的临界区问题解决方案</p>
<p>复杂: 需要两个进程的共享数据项</p>
<p>需要忙等待: 浪费CPU时间</p>
<p>没有硬件保证的情况下无真正的软件解决方案: Perterson算法需要原子的LOAD和STORE指令</p>
<h2 id="方法3-更高级的抽象"><a href="#方法3-更高级的抽象" class="headerlink" title="方法3:更高级的抽象"></a>方法3:更高级的抽象</h2><p>硬件提供了一些原语</p>
<ul>
<li>像中断禁用, 原子操作指令等</li>
<li>大多数现代体系结构都这样</li>
</ul>
<p>操作系统提供更高级的编程抽象来简化并行编程</p>
<ul>
<li>例如,锁,信号量</li>
<li>从硬件原语中构建</li>
</ul>
<p>锁是一个抽象的数据结构</p>
<ul>
<li>一个二进制状态(锁定,解锁),两种方法</li>
<li>Lock::Acquire() 锁被释放前一直等待,然后得到锁</li>
<li>Lock::Release() 锁释放,唤醒任何等待的进程</li>
</ul>
<p>使用锁来编写临界区</p>
<ul>
<li><p>前面的例子变得简单起来:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock_next_pid-&gt;Acquire();</span><br><span class="line">new_pid = next_pid++;</span><br><span class="line">lock_next_pid-&gt;Release();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>大多数现代体系结构都提供特殊的原子操作指令</p>
<ul>
<li>通过特殊的内存访问电路</li>
<li>针对单处理器和多处理器</li>
</ul>
<p>Test-and-Set 测试和置位</p>
<ul>
<li>从内存中读取值</li>
<li>测试该值是否为1(然后返回真或假)</li>
<li>内存值设置为1</li>
</ul>
<p>交换</p>
<ul>
<li>交换内存中的两个值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool TestandSet(bool *target)&#123;</span><br><span class="line">		bool rv = *target;</span><br><span class="line">		*target = true;</span><br><span class="line">		return rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Exchange(bool *a, bool *b)&#123;</span><br><span class="line">		bool tmp = *a;</span><br><span class="line">		*a = *b;</span><br><span class="line">		*b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>总结</p>
<p>锁是更高等级的编程抽象</p>
<ul>
<li>互斥可以使用锁来实现</li>
<li>通常需要一定等级的硬件支持</li>
</ul>
<p>常用的三种实现方法</p>
<ul>
<li>禁用中断(仅限于单处理器)</li>
<li>软件方法(复杂)</li>
<li>原子操作指令(单处理器或多处理器均可)</li>
</ul>
<p>可选的实现内容:</p>
<ul>
<li>有忙等待</li>
<li>无忙等待</li>
</ul>
</li>
</ul>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><blockquote>
<p>第十章的主要内容是：信号量和管程</p>
</blockquote>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量的抽象数据类型</p>
<ul>
<li>一个整形(sem),具有两个原子操作</li>
<li>P(): sem减一,如果sem&lt;0,等待,否则继续</li>
<li>V(): sem加一,如果sem≤0,唤醒一个等待的P</li>
</ul>
<p>信号量是整数</p>
<p>信号量是被保护的变量</p>
<ul>
<li>初始化完成后,唯一改变一个信号量的值的办法是通过P()和V()</li>
<li>操作必须是原子</li>
</ul>
<p>P()能够阻塞,V()不会阻塞</p>
<p>我们假定信号量是公平的</p>
<ul>
<li>没有线程被阻塞在P()仍然堵塞如果V()被无限频繁调用(在同一个信号量)</li>
<li>在实践中,FIFO经常被使用</li>
</ul>
<p>两个类型信号量</p>
<ul>
<li>二进制信号量: 可以是0或1</li>
<li>计数信号量: 可以取任何非负数</li>
<li>两者相互表现(给定一个可以实现另一个)</li>
</ul>
<p>信号量可以用在2个方面</p>
<ul>
<li>互斥</li>
<li>条件同步(调度约束——一个线程等待另一个线程的事情发生)</li>
</ul>
<h2 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h2><ol>
<li><p>用二进制信号量实现的互斥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutex = new Semaphore(1);</span><br><span class="line"></span><br><span class="line">mutex-&gt;P();</span><br><span class="line">...</span><br><span class="line">mutex-&gt;V();</span><br></pre></td></tr></table></figure>
</li>
<li><p>用二进制信号量实现的调度约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">condition = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">//Thread A</span><br><span class="line">...</span><br><span class="line">condition-&gt;P(); //等待线程B某一些指令完成之后再继续运行,在此阻塞</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//Thread B</span><br><span class="line">...</span><br><span class="line">condition-&gt;V(); //信号量增加唤醒线程A</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个线程等待另一个线程处理事情</p>
<p>比如生产东西或消费东西(生产者消费者模式),互斥(锁机制)是不够的</p>
<p>有界缓冲区的生产者-消费者问题</p>
<ul>
<li>一个或者多个生产者产生数据将数据放在一个缓冲区里</li>
<li>单个消费者每次从缓冲区取出数据</li>
<li>在任何一个时间只有一个生产者或消费者可以访问该缓冲区</li>
</ul>
<p>正确性要求</p>
<ul>
<li>在任何一个时间只能有一个线程操作缓冲区(互斥)</li>
<li>当缓冲区为空时,消费者必须等待生产者(调度,同步约束)</li>
<li>当缓存区满,生产者必须等待消费者(调度,同步约束)</li>
</ul>
<p>每个约束用一个单独的信号量</p>
<ul>
<li>二进制信号量互斥</li>
<li>一般信号量 fullBuffers</li>
<li>一般信号了 emptyBuffers</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BoundedBuffer&#123;</span><br><span class="line">		mutex = new Semaphore(1);</span><br><span class="line">		fullBuffers = new Semaphore(0);   //说明缓冲区初始为空</span><br><span class="line"> 		emptyBuffers = new Semaphore(n);  //同时可以有n个生产者来生产</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c)&#123;</span><br><span class="line">		emptyBuffers-&gt;P();</span><br><span class="line">		mutex-&gt;P();</span><br><span class="line">		Add c to the buffer;</span><br><span class="line">		mutex-&gt;V();</span><br><span class="line">		fullBuffers-&gt;V();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c)&#123;</span><br><span class="line">		fullBuffers-&gt;P();</span><br><span class="line">		mutex-&gt;P();</span><br><span class="line">		Remove c from buffer;</span><br><span class="line">		mutex-&gt;V();</span><br><span class="line">		emptyBuffers-&gt;V();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h2><p>使用硬件原语</p>
<ul>
<li>禁用中断</li>
<li>原子指令</li>
</ul>
<p>类似锁</p>
<ul>
<li>禁用中断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Semaphore&#123;</span><br><span class="line">		int sem;</span><br><span class="line">		WaitQueue q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Semaphore::P()&#123;</span><br><span class="line">		--sem;</span><br><span class="line">		if(sem &lt; 0)&#123;</span><br><span class="line">				Add this thread t to q;</span><br><span class="line">				block(p);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Semaphore::V()&#123;</span><br><span class="line">		++sem;</span><br><span class="line">		if(sem &lt;= 0)&#123;</span><br><span class="line">				Remove a thread t from q;</span><br><span class="line">				wakeup(t);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量的双用途</p>
<ul>
<li>互斥和条件同步</li>
<li>但等待条件是独立的互斥</li>
</ul>
<p>读,开发代码比较困难</p>
<ul>
<li>程序员必须非常精通信号量</li>
</ul>
<p>容易出错</p>
<ul>
<li>使用的信号量已经被另一个线程占用</li>
<li>忘记释放信号量</li>
</ul>
<p>不能够处理死锁问题</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>目的: 分离互斥和条件同步的关注</p>
<p>什么是管程</p>
<ul>
<li>一个锁: 指定临界区</li>
<li>0或者多个条件变量: 等待,通知信号量用于管程并发访问共享数据</li>
</ul>
<p>一般方法</p>
<ul>
<li>收集在对象,模块中的相关共享数据</li>
<li>定义方法来访问共享数据</li>
</ul>
<p>Lock</p>
<ul>
<li>Lock::Acquire() 等待直到锁可用,然后抢占锁</li>
<li>Lock::Release() 释放锁,唤醒等待者如果有</li>
</ul>
<p>Condition Variable</p>
<ul>
<li>允许等待状态进入临界区<ul>
<li>允许处于等待(睡眠)的线程进入临界区</li>
<li>某个时刻原子释放锁进入睡眠</li>
</ul>
</li>
<li>Wait() operation<ul>
<li>释放锁,睡眠,重新获得锁放回</li>
</ul>
</li>
<li>Signal() operation(or broadcast() operation)<ul>
<li>唤醒等待者(或者所有等待者),如果有</li>
</ul>
</li>
</ul>
<p>实现</p>
<ul>
<li>需要维持每个条件队列</li>
<li>线程等待的条件等待signal()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Condition&#123;</span><br><span class="line">		int numWaiting = 0;</span><br><span class="line">		WaitQueue q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Condition::Wait(lock)&#123;</span><br><span class="line">		numWaiting++;</span><br><span class="line">		Add this thread t to q;</span><br><span class="line">		release(lock);</span><br><span class="line">		schedule(); //need mutex</span><br><span class="line">		require(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::Signal()&#123;</span><br><span class="line">		if(numWaiting &gt; 0)&#123;</span><br><span class="line">				Remove a thread t from q;</span><br><span class="line">				wakeup(t); //need mutex</span><br><span class="line">				numWaiting--;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管程解决生产者-消费者问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BoundedBuffer&#123;</span><br><span class="line">		Lock lock;</span><br><span class="line">		int count = 0;  //buffer 为空</span><br><span class="line">		Condition notFull, notEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c)&#123;</span><br><span class="line">		lock-&gt;Acquire();    //管程的定义:只有一个线程能够进入管程</span><br><span class="line">		while(count == n)</span><br><span class="line">				notFull.Wait(&amp;lock); //释放前面的锁</span><br><span class="line">		Add c to the buffer;</span><br><span class="line">		count++;</span><br><span class="line">		notEmpty.Signal();</span><br><span class="line">		lock-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Remove(c)&#123;</span><br><span class="line">		lock-&gt;Acquire();</span><br><span class="line">		while(count == 0)</span><br><span class="line">				notEmpty.Wait(&amp;lock);</span><br><span class="line">		Remove c from buffer;</span><br><span class="line">		count--;</span><br><span class="line">		notFull.Signal();</span><br><span class="line">		lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发,调试并行程序很难</p>
<ul>
<li>非确定性的交叉指令</li>
</ul>
<p>同步结构</p>
<ul>
<li>锁: 互斥</li>
<li>条件变量: 有条件的同步</li>
<li>其他原语: 信号量</li>
</ul>
<p>怎么样有效地使用这些结构</p>
<ul>
<li>制定并遵循严格的程序设计风格,策略</li>
</ul>
<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ol>
<li><p>读者-写者问题</p>
<p>动机: 共享数据的访问</p>
<p>两种类型的使用者: 读者(不修改数据) 写者(读取和修改数据)</p>
<p>问题的约束:</p>
<ul>
<li>允许同一时间有多个读者,但在任何时候只有一个写者</li>
<li>当没有写者时,读者才能访问数据</li>
<li>当没有读者和写者时,写者才能访问数据</li>
<li>在任何时候只能有一个线程可以操作共享变量</li>
</ul>
<p>多个并发进程的数据集共享</p>
<ul>
<li>读者: 只读数据集;他们不执行任何更新</li>
<li>写者: 可以读取和写入</li>
</ul>
<p>共享数据</p>
<ul>
<li>数据集</li>
<li>信号量CountMutex初始化为1</li>
<li>信号量WriteMutex初始化为1</li>
<li>整数Rcount初始化为0(当前读者个数)</li>
</ul>
<p>读者优先设计</p>
<p>只要有一个读者处于活动状态, 后来的读者都会被接纳.如果读者源源不断的出现,那么写者使用处于阻塞状态.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//信号量实现</span><br><span class="line">//writer</span><br><span class="line">sem_wait(WriteMutex);</span><br><span class="line">write;</span><br><span class="line">sem_post(WriteMutex);</span><br><span class="line"></span><br><span class="line">//reader</span><br><span class="line">sem_wait(CountMutex);</span><br><span class="line">if(Rcount == 0)</span><br><span class="line">		sem_wait(WriteMutex); //确保后续不会有写者进入</span><br><span class="line">++Rcount;</span><br><span class="line">read;</span><br><span class="line">--Rcount;</span><br><span class="line">if(Rcount == 0)</span><br><span class="line">		sem_post(WriteMutex); //全部读者全部离开才能唤醒写者</span><br><span class="line">sem_post(CountMutex);</span><br></pre></td></tr></table></figure>

<p>写者优先设计</p>
<p>一旦写者就绪,那么写者会尽可能的执行写操作.如果写者源源不断的出现的话,那么读者就始终处于阻塞状态.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//writer</span><br><span class="line">Database::Write()&#123;</span><br><span class="line">		Wait until readers/writers;</span><br><span class="line">		write database;</span><br><span class="line">		check out - wake up waiting readers/writers;</span><br><span class="line">&#125;</span><br><span class="line">//reader</span><br><span class="line">Database::Read()&#123;</span><br><span class="line">		Wait until no writers;</span><br><span class="line">		read database;</span><br><span class="line">		check out - wake up waiting writers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//管程实现</span><br><span class="line">AR = 0; // # of active readers</span><br><span class="line">AW = 0; // # of active writers</span><br><span class="line">WR = 0; // # of waiting readers</span><br><span class="line">WW = 0; // # of waiting writers</span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br><span class="line">Lock lock;</span><br><span class="line">//writer</span><br><span class="line">Public Database::Write()&#123;</span><br><span class="line">		//Wait until no readers/writers;</span><br><span class="line">		StartWrite();</span><br><span class="line">		write database;</span><br><span class="line">		//check out - wake up waiting readers/writers;</span><br><span class="line">		DoneWrite();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::StartWrite()&#123;</span><br><span class="line">		lock.Acquire();</span><br><span class="line">		while((AW + AR) &gt; 0)&#123;</span><br><span class="line">				WW++;</span><br><span class="line">				okToWrite.wait(&amp;lock);</span><br><span class="line">				WW--;		</span><br><span class="line">		&#125;</span><br><span class="line">		AW++;</span><br><span class="line">		lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::DoneWrite()&#123;</span><br><span class="line">		lock.Acquire();</span><br><span class="line">		AW--;</span><br><span class="line">		if(WW &gt; 0)&#123;</span><br><span class="line">				okToWrite.signal();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(WR &gt; 0)&#123;</span><br><span class="line">				okToRead.broadcast(); //唤醒所有reader </span><br><span class="line">		&#125;</span><br><span class="line">		lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reader</span><br><span class="line">Public Database::Read()&#123;</span><br><span class="line">		//Wait until no writers;</span><br><span class="line">		StartRead();</span><br><span class="line">		read database;</span><br><span class="line">		//check out - wake up waiting writers;</span><br><span class="line">		DoneRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Private Database::StartRead()&#123;</span><br><span class="line">		lock.Acquire();</span><br><span class="line">		while(AW + WW &gt; 0)&#123;    //关注等待的writer,体现出写者优先</span><br><span class="line">				WR++;</span><br><span class="line">				okToRead.wait(&amp;lock);</span><br><span class="line">				WR--;</span><br><span class="line">		&#125;</span><br><span class="line">		AR++;</span><br><span class="line">		lock.Release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Database::DoneRead()&#123;</span><br><span class="line">		lock.Acquire();</span><br><span class="line">		AR--;</span><br><span class="line">		if(AR == 0 &amp;&amp; WW &gt; 0)&#123;  //只有读者全部没有了,才需要唤醒</span><br><span class="line">				okToWrite.signal();</span><br><span class="line">		&#125;</span><br><span class="line">		lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>哲学家就餐问题(学习自 <a href="http://github.com/cyc2018">github.com&#x2F;cyc2018</a>)</p>
<p>共享数据:</p>
<ul>
<li>Bowl of rice(data set)</li>
<li>Semaphone fork [5] initialized to 1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define N 5</span><br><span class="line">#define LEFT (i + N - 1) % N // 左邻居</span><br><span class="line">#define RIGHT (i + 1) % N    // 右邻居</span><br><span class="line">#define THINKING 0</span><br><span class="line">#define HUNGRY   1</span><br><span class="line">#define EATING   2</span><br><span class="line">typedef int semaphore;</span><br><span class="line">int state[N];                // 跟踪每个哲学家的状态</span><br><span class="line">semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span><br><span class="line">semaphore s[N];              // 每个哲学家一个信号量</span><br><span class="line"></span><br><span class="line">void philosopher(int i) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void take_two(int i) &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void put_two(i) &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void eat(int i) &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span><br><span class="line">void check(i) &#123;         </span><br><span class="line">    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><blockquote>
<p>第十一章的主要内容是：死锁和进程通信</p>
</blockquote>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源</p>
<p>示例:</p>
<ul>
<li>系统有2个磁带驱动器</li>
<li>P1和P2各有一个,都需要另外一个</li>
</ul>
<h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>资源类型R1,R2,..,Rm(CPU, memory space, IO devices)</p>
<p>每个资源类型Ri有Wi个实例.</p>
<p>每个进程使用资源如下:</p>
<ul>
<li>require,get ← free resource</li>
<li>use,hold ← requested,used resource</li>
<li>release ← free resource</li>
</ul>
<p>可重复使用的资源</p>
<ul>
<li>在一个时间只能有一个进程使用且不能被删除</li>
<li>进程获得资源,后来释放由其他进程重用</li>
<li>处理器,IO通道,主和副存储器,设备和数据结构,如文件,数据库和信号量</li>
<li>如果每个进程拥有一个资源并请求其他资源,死锁可能发生</li>
</ul>
<p>使用资源</p>
<ul>
<li>创建和销毁</li>
<li>在IO缓存区的中断,信号,消息,信息</li>
<li>如果接收消息阻塞可能会发生死锁</li>
<li>可能少见的组合事件会引起死锁</li>
</ul>
<p>资源分配图</p>
<p>一组顶点V和边E的集合</p>
<ul>
<li>V有两种类型:<ul>
<li>P&#x3D;{P1,P2,…,Pn},集合包括系统中的所有进程</li>
<li>R&#x3D;{R1,R2,…,Rm},集合包括系统中的所有资源类型</li>
</ul>
</li>
<li>requesting,claiming edge - directed edge Pi → Rj</li>
<li>assignment,holding edge - directed edge Rj → Pi</li>
</ul>
<p>基本情况</p>
<p>如果图中不包含循环:</p>
<ul>
<li>没有死锁</li>
</ul>
<p>如果图中包含循环:</p>
<ul>
<li>如果每个资源类只有一个实例,那么死锁</li>
<li>如果每个资源类有几个实例,可能死锁</li>
</ul>
<h2 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h2><p>死锁出现一定会出现以下四个条件,但是出现以下四个条件不一定死锁:</p>
<ul>
<li>互斥: 在一个时间只能有一个进程使用资源</li>
<li>持有并等待: 进程保持至少一个资源正在等待获取其他进程持有的额外资源</li>
<li>无抢占: 一个资源只能被进程资源释放,进程已经完成了它的任务之后</li>
<li>循环等待: 存在等待进程集合{P0,P1,…,Pn},P0正在等待P1所占用的资源,P1正在等待P2占用的资源…Pn-1在等待Pn的资源,Pn正在等待P0所占用的资源</li>
</ul>
<h2 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h2><p>常见方法</p>
<ul>
<li>确保系统永远不会进入死锁状态</li>
<li>运行系统进入死锁状态,然后恢复.</li>
<li>忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统,包括UNIX</li>
</ul>
<h3 id="Deadlock-Prevention-预防"><a href="#Deadlock-Prevention-预防" class="headerlink" title="Deadlock Prevention 预防"></a>Deadlock Prevention 预防</h3><p>限制申请方式</p>
<ul>
<li>互斥 - 共享资源不是必须的,必须占用非共享资源</li>
<li>占用并等待 - 必须保证当一个进程请求的资源,它不持有任何其他资源<ul>
<li>需要进程请求并分配其所有资源,它开始执行之前或允许进程请求资源仅当进程没有资源</li>
<li>资源利用率低,可能发生饥饿</li>
</ul>
</li>
<li>无抢占 -<ul>
<li>如果进程占有某些资源,并请求其他不能被立即分配的资源,则释放当前正占有的资源</li>
<li>被抢占资源添加到资源列表中</li>
<li>只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行</li>
</ul>
</li>
<li>循环等待 - 对所有资源类型进行排序,并要求每个进程按照资源的顺序进行申请</li>
</ul>
<h3 id="Deadlock-Avoidance-避免"><a href="#Deadlock-Avoidance-避免" class="headerlink" title="Deadlock Avoidance 避免"></a>Deadlock Avoidance 避免</h3><p>需要系统具有一些额外的先验信息提供</p>
<ul>
<li>最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目</li>
<li>资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求</li>
<li>死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态</li>
<li>当一个进程请求可用资源,系统必须判断立即分配是否能使系统处于安全状态</li>
<li>系统处于安全状态指: 针对所有进程,存在安全序列</li>
<li>序列&lt;P1,P2,…,Pn&gt;是安全的: 针对每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,其中j&lt;i.<ul>
<li>如果Pi资源的需求不是立即可用,那么Pi可以等到所有Pj完成</li>
<li>当Pi完成后,Pi+1可以得到所需要的资源,执行,返回所分配的资源,并终止.</li>
<li>用同样的方法,Pi+2,Pi+3和Pn能获得其所需的资源.</li>
</ul>
</li>
<li>如果系统处于安全状态→无死锁</li>
<li>如果系统处于不安全状态→可能死锁</li>
<li>避免死锁: 确保系统永远不会进入不安全状态</li>
</ul>
<h3 id="Deadlock-Detection-检测"><a href="#Deadlock-Detection-检测" class="headerlink" title="Deadlock Detection 检测"></a>Deadlock Detection 检测</h3><p>每个资源类型单一实例</p>
<p>Maintain wait-for graph</p>
<ul>
<li>节点是进程</li>
<li>Pi→Pj: Pi等待Pj</li>
</ul>
<p>定期调用检测算法来搜索图中是否存在循环</p>
<p>算法需要n^2次操作,n是图中顶点的数目</p>
<p>数据结构:</p>
<ul>
<li>Available: 长度为M的向量表示每种类型可用资源的数量</li>
<li>Allocation: 一个nxm矩阵定义了当前分配给各个进程每种类型资源的数量,如果Alocation[i, j] &#x3D; k, 进程Pi拥有资源Rj的k个实例</li>
<li>Request: 一个nxm矩阵表示各进程的当前请求.如果Request[i, j] &#x3D; k,表示进程Pi请求k个资源Pj的实例</li>
</ul>
<p>具体算法(跳过了,看视频)</p>
<p>检查算法使用</p>
<p>何时,使用什么样的频率来检测依赖于:</p>
<ul>
<li>死锁多久可能会发生?</li>
<li>多少进程需要被回滚? one for each disjoint cycle</li>
</ul>
<p>如果检测算法多次被调用,有可能是资源图有多个循环,所以我们无法分辨出多个可能死锁进程中的哪些”造成”死锁</p>
<h3 id="Recovery-from-Deadlock-恢复"><a href="#Recovery-from-Deadlock-恢复" class="headerlink" title="Recovery from Deadlock 恢复"></a>Recovery from Deadlock 恢复</h3><p>终止所有的死锁进程</p>
<p>在一个时间内终止一个进程直到死锁消除</p>
<p>终止进程的顺序应该是:</p>
<ul>
<li>进程的优先级</li>
<li>进程运行了多久以及需要多少时间才能完成</li>
<li>进程占用的资源</li>
<li>进程完成需要的资源</li>
<li>多少进程需要被终止</li>
<li>进程是交互还是批处理</li>
</ul>
<p>选择一个受孩子 - 最小的成本</p>
<p>回滚 - 返回到一些安全状态,重启进程到安全状态</p>
<p>饥饿 - 同一进程可能一直被选作受害者,包括回滚的数量</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程通信的机制及同步</p>
<p>不使用共享变量的进程通信</p>
<p>IPC facility 提供2个操作:</p>
<ul>
<li>send(message) - 消息大小固定或者可变</li>
<li>receive(message)</li>
</ul>
<p>如果P和Q想通信,需要:</p>
<ul>
<li>在它们之间建立通信链路</li>
<li>通过send&#x2F;recevie交换消息</li>
</ul>
<p>通信链路的实现</p>
<ul>
<li>物理(例如,共享内存,硬件总线)</li>
<li>逻辑(例如,逻辑属性)</li>
</ul>
<h3 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h3><p>进程必须正确的命名对方:</p>
<ul>
<li>send(P, message) - 发送消息到进程P</li>
<li>receive(Q, message) - 从进程Q接收信息</li>
</ul>
<p>通信链路的属性</p>
<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链路存在</li>
<li>链路可以是单向的,但通常是双向的</li>
</ul>
<h3 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h3><p>定向从消息队列接收消息</p>
<ul>
<li>每个消息对垒都有一个唯一的ID</li>
<li>只有它们共享了一个消息队列,进程才能够通信</li>
</ul>
<p>通信链路的属性</p>
<ul>
<li>只有进程共享一个共同的消息队列,才建立链路</li>
<li>链接可以与许多进程相关联</li>
<li>每对进程可以共享多个通信链路</li>
<li>链接可以是单向或者双向</li>
</ul>
<p>操作</p>
<ul>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接收消息</li>
<li>销毁消息队列</li>
</ul>
<p>原语的定义如下:</p>
<ul>
<li><p>send(A, message)</p>
</li>
<li><p>receive(A, message)</p>
</li>
<li><p>通信链路缓冲</p>
<p>通信链路缓存大小:</p>
<ol>
<li>0容量 - 0 message : 发送方必须等待接收方</li>
<li>有限容量 - n messages的有限长度 : 发送方必须等待,如果队列满</li>
<li>无限容量 - 无限长度 : 发送方不需要等待</li>
</ol>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号Signal</p>
<ul>
<li>软件中断通知事件处理</li>
<li>Examples: SIGFPE, SIGKILL, SIGUSRI, SIGSTOP, SIGCONT</li>
</ul>
<p>接收到信号时会发生什么?</p>
<ul>
<li>catch: 指定信号处理函数被调用</li>
<li>ignore: 依靠操作系统的默认操作(abort, memory dump, suspend or resume process)</li>
<li>mask: 闭塞信号因此不会传送(可能是暂时的,当处理同样类型的信号)</li>
</ul>
<p>不足:</p>
<ul>
<li>不能传输要交换的任何数据</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>数据交换</p>
<p>子进程从父进程继承文件描述符(0 stdin, 1 stdout, 2 stderr)</p>
<p>进程不知道(或不关心)从键盘,文件,程序读取或写入到终端,文件,程序.</p>
<p>例如: $ ls | more (两个进程, 管道是缓存,对于ls来说是stdout,对于more来说是stdin )</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列按FIFO来管理消息</p>
<ul>
<li>message: 作为一个字节序列存储</li>
<li>message queues: 消息数组</li>
<li>FIFO &amp; FILO configuration</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>进程</p>
<ul>
<li>每个进程都有私有地址空间</li>
<li>在每个地址空间内,明确地设置了共享内存段</li>
</ul>
<p>优点</p>
<ul>
<li>快速,方便地共享数据</li>
</ul>
<p>不足</p>
<ul>
<li>必须同步数据访问</li>
</ul>
<p>最快的方法</p>
<p>一个进程写另一个进程立即可见</p>
<p>没有系统调用干预</p>
<p>没有数据复制</p>
<p>不提供同步</p>
<ul>
<li>Socket</li>
</ul>
<h1 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h1><blockquote>
<p>第十二章的主要内容是：文件管理</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h3><p>文件系统: 一种用于持久性存储的系统抽象</p>
<ul>
<li>在存储上: 组织,控制,导航,访问和检索数据</li>
<li>在大多数计算机系统包含文件系统</li>
<li>个人电脑,服务器,笔记本电脑</li>
<li>ipod,tivo,机顶盒,手机,电脑</li>
<li>google可能也是由一个文件系统构成的</li>
</ul>
<p>文件: 文件系统中的一个单元的相关数据在操作系统中的抽象</p>
<p>文件系统的功能:</p>
<ul>
<li>分配文件磁盘空间<ul>
<li>管理文件块(哪一块属于哪一个文件)</li>
<li>管理空闲空间(哪一块是空闲的)</li>
<li>分配算法(策略)</li>
</ul>
</li>
<li>管理文件集合<ul>
<li>定位文件及其内容</li>
<li>命名: 通过名字找到文件的接口</li>
<li>最常见: 分层文件系统</li>
<li>文件系统类型(组织文件的不同方式)</li>
</ul>
</li>
<li>提供的便利及特征<ul>
<li>保护: 分层来保护数据安全</li>
<li>可靠性,持久性: 保持文件的持久即使发生崩溃,媒体错误,攻击等</li>
</ul>
</li>
</ul>
<p>文件和块:</p>
<p>文件属性: 名称,类型,位置,大小,保护,创建者,创建时间,最久修改时间…</p>
<p>文件头: 在存储元数据中保存了每个文件的信息,保存文件的属性,跟踪哪一块存储块属于逻辑上文件结构的哪个偏移</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件使用模式:</p>
<p>使用程序必须在使用前先”打开”文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(name, flag);</span><br><span class="line">...</span><br><span class="line">... = read(f, ...);</span><br><span class="line">...</span><br><span class="line">close(f);</span><br></pre></td></tr></table></figure>

<p>内核跟踪每个进程打开的文件:</p>
<ul>
<li>操作系统为每个进程维护一个打开文件表</li>
<li>一个打开文件描述符是这个表中的索引</li>
</ul>
<p>需要元数据来管理打开文件:</p>
<p>文件指针: 指向最近的一次读写位置,每个打开了这个文件的进程都这个指针</p>
<p>文件打开计数: 记录文件打开的次数 - 当最后一个进程关闭了文件时,允许将其从打开文件表中移除</p>
<p>文件磁盘位置: 缓存数据访问信息</p>
<p>访问权限: 每个程序访问模式信息</p>
<p>用户视图: 持久的数据结构</p>
<p>系统访问接口:</p>
<p>字节的集合(UNIX)</p>
<p>系统不会关心你想存储在磁盘上的任何的数据结构</p>
<p>操作系统内部视角:</p>
<p>块的集合(块是逻辑转换单元,而扇区是物理转换单元)</p>
<p>块大小&lt;&gt; 扇区大小: 在UNIX中, 块的大小是 4KB</p>
<p>当用户说: 给我2-12字节空间时会发生什么?</p>
<p>获取字节所在的快</p>
<p>返回快内对应部分</p>
<p>如果要写2-12字节?</p>
<p>获取块</p>
<p>修改块内对应部分</p>
<p>写回块</p>
<p>在文件系统中的所有操作都是在整个块空间上进行的: <code>getc()</code> <code>putc()</code> 即使每次只访问1字节的数据,也会缓存目标数据4096字节(一个磁盘块)</p>
<p>用户怎么访问文件: 在系统层面需要知道用户的访问模式</p>
<p>顺序访问: 按字节依次读取(几乎所有的访问都是这种方式)</p>
<p>随机访问: 从中间读写(不常用,但是仍然重要,如: 虚拟内存支持文件,内存页存储在文件中;更加快速,不希望获取文件中间的内容的时候也必须先获取块内所有字节)</p>
<p>内容访问: 通过特征</p>
<p>文件内部结构:</p>
<p>无结构: 单词,比特的队列</p>
<p>简单记录结构: 列,固定长度,可变长度</p>
<p>复杂结构: 格式化的文档(word, PDF), 可执行文件, …</p>
<p>多用户系统中的文件共享是很必要的</p>
<p>访问控制:</p>
<p>谁能够获得哪些文件的哪些访问权限</p>
<p>访问模式: 读,写,执行,删除,列举等</p>
<p>文件访问控制列表(ACL):</p>
<p>&lt;文件实体, 权限&gt;</p>
<p>UNIX模式:</p>
<p>&lt;用户|组|所有人,读|写|可执行&gt;</p>
<p>用户ID识别用户,表明每个用户所允许的权限及保护模式</p>
<p>组ID允许用户组成组,并指定了组访问权限</p>
<p>指定多用户,客户如何同时访问共享文件:</p>
<p>和过程同步算法相似</p>
<p>因磁盘IO和网络延迟而设计简单</p>
<p>UNIX文件系统(UFS)语义:</p>
<p>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</p>
<p>共享文件指针允许多用户同时读取和写入文件</p>
<p>会话语义:</p>
<p>写入内容只有当文件关闭时可见</p>
<p>锁:</p>
<p>一些操作系统和文件系统提供该功能</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>文件以目录的方式组织起来</p>
<p>目录是一类特殊的文件: 每个目录都包含了一张表&lt;name, pointer to file header&gt;</p>
<p>目录和文件的树形结构: 早期的文件系统是扁平的(只有一层目录)</p>
<p>层次名称空间: &#x2F;spell&#x2F;mail&#x2F;prt&#x2F;first &#x2F;programs&#x2F;p&#x2F;list</p>
<p>典型操作:</p>
<p>搜索文件</p>
<p>创建文件</p>
<p>删除文件</p>
<p>枚举目录</p>
<p>重命名文件</p>
<p>在文件系统中遍历一个路径</p>
<p>操作系统应该只允许内核模式修改目录: 确保映射的完整性,应用程序能够读目录(ls)</p>
<p>文件名的线性列表,包含了指向数据块的指针: 编程简单,执行耗时</p>
<p>Hash表 - hash数据结构的线性表: 减少目录搜索时间,碰撞,固定大小</p>
<p>名字解析: 逻辑名字转换成物理资源(如文件)的过程:</p>
<p>在文件系统中: 到实际文件的文件名(路径)</p>
<p>遍历文件目录直到找到目标文件</p>
<p>举例: 解析”&#x2F;bin&#x2F;ls”:</p>
<p>读取root的文件头(在磁盘固定位置)</p>
<p>读取root的数据块: 搜索bin项</p>
<p>读取bin的文件头</p>
<p>读取bin的数据块: 搜索ls项</p>
<p>读取ls的文件头</p>
<p>当前工作目录:</p>
<p>每个进程都会指向一个文件目录用于解析文件名</p>
<p>允许用户指定相对路径来代替绝对路径</p>
<p>一个文件系统需要先挂载才能被访问</p>
<p>一个未挂载的文件系统被挂载在挂载点上</p>
<h3 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h3><p>两个或多个文件名关联同一个文件:</p>
<p>硬链接: 多个文件项指向一个文件</p>
<p>软链接: 以快捷方式指向其他文件</p>
<p>通过存储真实文件的逻辑名称来实现</p>
<p>如果删除一个有别名的文件会如何呢? : 这个别名将成为一个悬空指针</p>
<p>Backpointers 方案:</p>
<p>每个文件有一个包含多个backpointers的列表,所以删除所有的Backpointers</p>
<p>backpointers使用菊花链管理</p>
<p>添加一个间接层: 目录项数据结构</p>
<p>链接: 已存在文件的另外一个名字(指针)</p>
<p>链接处理: 跟随指针来定位文件</p>
<p>我们如何保证没有循环呢?</p>
<p>只允许到文件的链接, 不允许在子目录的链接</p>
<p>每增加一个新的链接都用循环检测算法确定是否合理</p>
<p>限制路径可遍历文件目录的数量</p>
<h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><p>磁盘文件系统: 文件存储在数据存储设备上,如磁盘; 例如: FAT,NTFS,ext2,3,ISO9660等</p>
<p>数据库文件系统: 文件根据其特征是可被寻址的; 例如: WinFS</p>
<p>日志文件系统: 记录文件系统的修改,事件; 例如: journaling file system</p>
<p>网络,分布式文件系统: 例如: NFS,SMB,AFS,GFS</p>
<p>特殊,虚拟文件系统</p>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>分层结构:</p>
<p>顶层: 文件,文件系统API</p>
<p>上层: 虚拟(逻辑)文件系统 (将所有设备IO,网络IO全抽象成为文件,使得接口一致)</p>
<p>底层: 特定文件系统模块</p>
<p>目的: 对所有不同文件系统的抽象</p>
<p>功能:</p>
<p>提供相同的文件和文件系统接口</p>
<p>管理所有文件和文件系统关联的数据结构</p>
<p>高效查询例程,遍历文件系统</p>
<p>与特定文件系统模块的交互</p>
<p>数据结构:</p>
<p>卷[第四声]控制块(UNIX: “superblock”)</p>
<p>每个文件系统一个</p>
<p>文件系统详细信息</p>
<p>块,块大小,空余块,计数,指针等</p>
<p>文件控制块(UNIX: “vnode” or “inode”)</p>
<p>每个文件一个</p>
<p>文件详细信息</p>
<p>许可,拥有者,大小,数据库位置等</p>
<p>目录节点(Linux: “dentry”)</p>
<p>每个目录项一个(目录和文件)</p>
<p>将目录项数据结构及树形布局编码成树形数据结构</p>
<p>指向文件控制块,父节点,项目列表等</p>
<p>其中: 卷控制块(每个文件系统一个),文件控制块(每个文件一个),目录节点(每个目录项一个)</p>
<p>持续存储在二级存储中: 在分配在存储设备中的数据块中</p>
<p>当需要时加载进内存:</p>
<p>卷控制块: 当文件系统挂载时进入内存</p>
<p>文件控制块: 当文件被访问时进入内存</p>
<p>目录节点: 在遍历一个文件路径时进入内存</p>
<h2 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h2><p>数据块按需读入内存:</p>
<p>提供 <code>read()</code> 操作</p>
<p>预读: 预先读取后面的数据块</p>
<p>数据块使用后被缓存:</p>
<p>假设数据将会再次被使用</p>
<p>写操作可能被缓存和延迟写入</p>
<p>两种数据块缓存方式:</p>
<p>普通缓冲区缓存</p>
<p>页缓存: 同一缓存数据块和内存页</p>
<p>分页要求: 当需要一个页时才将其载入内存</p>
<p>支持存储: 一个页(在虚拟地址空间中)可以被映射到一个本地文件中(在二级存储中)</p>
<h2 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h2><p>打开文件描述:</p>
<p>每个被打开的文件一个</p>
<p>文件状态信息</p>
<p>目录项,当前文件指针,文件操作设置等</p>
<p>打开文件表:</p>
<p>一个进程一个</p>
<p>一个系统级的</p>
<p>每个卷控制块也会保存一个列表</p>
<p>所以如果有文件被打开将不能被卸载</p>
<p>一些操作系统和文件系统提供该功能</p>
<p>调节对文件的访问</p>
<p>强制和劝告:</p>
<p>强制 - 根据锁保持情况和需求拒绝访问</p>
<p>劝告 - 进程可以查找锁的状态来决定怎么做</p>
<h2 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h2><p>大多数文件都很小:</p>
<p>需要对小文件提供强力的支持</p>
<p>块空间不能太小</p>
<p>一些文件非常大:</p>
<p>必须支持大文件(64-bit 文件偏移)</p>
<p>大文件访问需要相当高效</p>
<p>如何为一个文件分配数据块</p>
<p>分配方式:</p>
<p>连续分配</p>
<p>链式分配</p>
<p>索引分配</p>
<p>指标:</p>
<p>高效: 如存储利用(外部碎片)</p>
<p>表现: 如访问速度</p>
<p>连续分配:</p>
<p>文件头指定起始块和长度</p>
<p>位置,分配策略: 最先匹配,最佳匹配,…</p>
<p>优势: 文件读取表现好;高效的顺序和随机访问</p>
<p>劣势: 碎片;文件增长问题</p>
<p>链式分配:</p>
<p>文件以数据块链表方式存储</p>
<p>文件头包含了到第一块和最后一块的指针</p>
<p>优势: 创建,增大,缩小很容易;没有碎片</p>
<p>劣势: 不可能进行真正的随机访问;可靠性</p>
<p>索引分配:</p>
<p>为每个文件创建一个名为索引数据块的非数据数据块(到文件数据块的指针列表)</p>
<p>文件头包含了索引数据块</p>
<p>优势: 创建,增大,缩小很容易;没有碎片;支持直接访问</p>
<p>劣势: 当文件很小时,存储索引的开销大;处理大文件难</p>
<h2 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h2><p>跟踪在存储中的所有未分配的数据块</p>
<p>空闲空间列表存储在哪里?</p>
<p>空闲空间列表的最佳数据结构怎么样?</p>
<p>用位图代表空闲数据块列表: 11111101101110111 如果 i &#x3D; 0表明数据块i是空闲的,反之是分配的</p>
<p>使用简单但是可能会是一个big vector:</p>
<p>160GB disk → 40M blocks → 5MB worth of bits</p>
<p>然而,如果空闲空间在磁盘中均匀分布,那么再找到”0”之前需要扫描 磁盘上数据块总数 &#x2F; 空闲块的数目</p>
<p>需要保护:</p>
<p>指向空闲列表的指针</p>
<p>位图:</p>
<p>必须保存在磁盘上;在内存和磁盘拷贝可能有所不同;不允许block[i]在内存中的状态为bit[i]&#x3D;1而在磁盘中bit[i]&#x3D;0</p>
<p>解决:</p>
<p>在磁盘上设置bit[i] &#x3D; 1; 分配block[i]; 在内存中设置bit[i] &#x3D; 1</p>
<h2 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理 - RAID"></a>多磁盘管理 - RAID</h2><p>通常磁盘通过分区来最大限度减小寻道时间:</p>
<p>一个分区是一个柱面的集合</p>
<p>每个分区都是逻辑上独立的磁盘</p>
<p>分区: 硬件磁盘的一种适合操作系统指定格式的划分</p>
<p>卷: 一个拥有一个文件系统实例的可访问的存储空间(通常常驻在磁盘的单个分区上)</p>
<p>使用多个并行磁盘来增加: 吞吐量(通过并行),可靠性和可用性(通过冗余)</p>
<p>RAID - 冗余磁盘阵列: 各种磁盘管理技术;RAID levels: 不同RAID分类,如RAID-0,RAID-1,RAID-5</p>
<p>实现: 在操作系统内核: 存储,卷管理; RAID硬件控制器(IO)</p>
<p>RAID-0</p>
<p>数据块分成多个子块, 存储在独立的磁盘中: 和内存交叉相似</p>
<p>通过更大的有效块大小来提供更大的磁盘带宽</p>
<p>RAID-1</p>
<p>可靠性成倍增长</p>
<p>读取性能线性增加(向两个磁盘写入,从任何一个读取)</p>
<p>RAID-4</p>
<p>数据块级磁带配有专用奇偶校验磁盘: 允许从任意一个故障磁盘中恢复</p>
<p>条带化和奇偶校验按byte-by-byte或者bit-by-bit: RAID-0,4,5: block-wise ;RAID-3: bit-wise</p>
<p>RAID-5</p>
<p>每个条带快有一个奇偶校验块,允许有一个磁盘错误</p>
<p>RAID-6</p>
<p>两个冗余块,有一种特殊的编码方式,允许两个磁盘错误</p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>读取或写入时,磁头必须被定位在期望的磁道,并从所期望的扇区开始</p>
<p>寻道时间: 定位到期望的磁道所花费的时间</p>
<p>旋转延迟: 从扇区的开始处到到达目的处花费的时间</p>
<p>平均旋转延迟时间 &#x3D; 磁盘旋转一周时间的一半</p>
<p>寻道时间是性能上区别的原因</p>
<p>对单个磁盘,会有一个IO请求数目</p>
<p>如果请求是随机的,那么会表现很差</p>
<p>FIFO:</p>
<p>按顺序处理请求</p>
<p>公平对待所有进程</p>
<p>在有很多进程的情况下,接近随机调度的性能</p>
<p>最短服务优先:</p>
<p>选择从磁臂当前位置需要移动最少的IO请求</p>
<p>总是选择最短寻道时间</p>
<p>skan:</p>
<p>磁臂在一个方向上移动,满足所有为完成的请求,直到磁臂到达该方向上最后的磁道</p>
<p>调换方向</p>
<p>c-skan:</p>
<p>限制了仅在一个方向上扫描</p>
<p>当最后一个磁道也被访问过了后,磁臂返回到磁盘的另外一端再次进行扫描</p>
<p>c-loop(c-skan改进):</p>
<p>磁臂先到达该方向上最后一个请求处,然后立即反转</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>/2022/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-1、计算机网络在信息时代的作用"><a href="#1-1、计算机网络在信息时代的作用" class="headerlink" title="1.1、计算机网络在信息时代的作用"></a>1.1、计算机网络在信息时代的作用</h1><ul>
<li>计算机网络已由一种<strong>通信基础设施</strong>发展成为一种重要的<strong>信息服务基础设施</strong></li>
<li>计算机网络已经像水，电，煤气这些基础设施一样，成为我们<strong>生活中不可或缺</strong>的一部分</li>
<li><span id="more"></span></li>
</ul>
<h2 id="我国互联网发展状况"><a href="#我国互联网发展状况" class="headerlink" title="我国互联网发展状况"></a>我国互联网发展状况</h2><p><a href="https://link.juejin.cn/?target=http://www.cnnic.net.cn">中国互联网络信息中心CNNIC</a></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103619.png" alt="image-20201006160618748"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103648.png" alt="image-20201006160645887"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103659.png" alt="image-20201006160715764"></p>
<h1 id="1-2、因特网概述"><a href="#1-2、因特网概述" class="headerlink" title="1.2、因特网概述"></a>1.2、因特网概述</h1><h2 id="1、网络、互连网（互联网）和因特网"><a href="#1、网络、互连网（互联网）和因特网" class="headerlink" title="1、网络、互连网（互联网）和因特网"></a>1、网络、互连网（互联网）和因特网</h2><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103711.png" alt="image-20201006163406232"></p>
<p>互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103716.png" alt="image-20201006163857236"></p>
<p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103720.png" alt="image-20201006164114523"></p>
<blockquote>
<p><strong>internet与Internet的区别</strong></p>
<ul>
<li>**internet(互联网或互连网)**是一个通用名词，它泛指**多个计算机网络互连而成的网络**。在这些网络之间的通信协议可以是任意的。</li>
<li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</li>
</ul>
<p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103731.png" alt="image-20201010233227407"></p>
<h2 id="2、因特网发展的三个阶段"><a href="#2、因特网发展的三个阶段" class="headerlink" title="2、因特网发展的三个阶段"></a>2、因特网发展的三个阶段</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103739.png" alt="image-20201006164655173"></p>
<p><strong>因特网服务提供者<code>ISP</code>(<code>I</code>nternet <code>S</code>ervice <code>P</code>rovider)</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103744.png" alt="image-20201006165117756"></p>
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<p><strong>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103801.png" alt="image-20201006165738879"></p>
<p><strong>基于ISP的三层结构的因特网</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103810.png" alt="image-20201006170140504"></p>
<blockquote>
<p>一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p>
</blockquote>
<h2 id="3、因特网的标准化工作"><a href="#3、因特网的标准化工作" class="headerlink" title="3、因特网的标准化工作"></a>3、因特网的标准化工作</h2><ul>
<li>因特网的标准化工作对因特网的发展起到了非常重要的作用。</li>
<li>因特网在指定其标准上的一个很大的特点是<strong>面向公众。</strong><ul>
<li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li>
<li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li>
</ul>
</li>
<li><strong>因特网协会ISOC</strong>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。<ul>
<li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发；</li>
<li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li>
<li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103816.png" alt="image-20201006170959060"></p>
<ul>
<li><p>制订因特网的正式标准要经过一下<strong>4个阶段</strong>：</p>
<p>1、因特网草案（在这个阶段还不是RFC文档）</p>
<p>2、建议标准（从这个阶段开始就成为RFC文档）</p>
<p>3、草案标准</p>
<p>4、因特网标准</p>
</li>
</ul>
<h2 id="4、因特网的组成"><a href="#4、因特网的组成" class="headerlink" title="4、因特网的组成"></a>4、因特网的组成</h2><ul>
<li><p>边缘部分</p>
<p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p>
</li>
<li><p>核心部分</p>
<p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103822.png" alt="image-20201006180725282"></p>
<blockquote>
<p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p>
<p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p>
<p><strong>端系统在功能上可能有很大的差别：</strong></p>
<ol>
<li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li>
<li>大的端系统则可以是一台非常昂贵的大型计算机。</li>
<li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</li>
</ol>
</blockquote>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p><strong>端系统之间通信的含义</strong></p>
<p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p>
<p>端系统之间的通信方式通常可划分为两大类：</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103829.png" alt="image-20201010234145371"></p>
<p><strong>客户-服务器方式：</strong></p>
<ul>
<li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li>
<li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li>
<li>客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<blockquote>
<p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p>
</blockquote>
<p><strong>对等连接方式：</strong></p>
<ul>
<li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li>
<li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li>
<li>双方都可以下载对方已经存储在硬盘中的共享文档。</li>
</ul>
<h1 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h1><p>网络核心部分是互联网中最复杂的部分。</p>
<p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p>
<p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p>
<p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p>
<h2 id="1、电路交换（Circuit-Switching）"><a href="#1、电路交换（Circuit-Switching）" class="headerlink" title="1、电路交换（Circuit Switching）"></a>1、电路交换（Circuit Switching）</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103836.png" alt="image-20201006182240000"></p>
<blockquote>
<p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p>
<p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103840.png" alt="image-20201006182634249"></p>
<ul>
<li><p>电话交换机接通电话线的方式称为电路交换；</p>
</li>
<li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p>
</li>
<li><p>电路交换的三个步骤：</p>
<p>1、建立连接（分配通信资源）</p>
<p>2、通话（一直占用通信资源）</p>
<p>3、释放连接（归还通信资源）</p>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103845.png" alt="image-20201006183020317"></p>
<blockquote>
<p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p>
<p>这是因为计算机数据是突发式地出现在传输线路上的。</p>
<p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p>
</blockquote>
<h2 id="2、分组交换（Packet-Switching）"><a href="#2、分组交换（Packet-Switching）" class="headerlink" title="2、分组交换（Packet Switching）"></a>2、分组交换（Packet Switching）</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103852.png" alt="image-20201006183312843"></p>
<blockquote>
<p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p>
<p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p>
<p>首部包含了<strong>分组的目的地址</strong></p>
<p>分组从源主机到目的主机，可走不同的路径。</p>
</blockquote>
<p>发送方</p>
<ul>
<li>构造分组</li>
<li>发送分组</li>
</ul>
<p>路由器</p>
<ul>
<li>缓存分组</li>
<li>转发分组</li>
<li>简称为“分组转发”</li>
</ul>
<blockquote>
<p>在路由器中的输入和输出端口之间没有直接连线。</p>
<p>路由器处理分组的过程是：</p>
<ol>
<li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li>
<li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li>
<li>把分组送到适当的端口<strong>转发</strong>出去。</li>
</ol>
</blockquote>
<p>接收方</p>
<ul>
<li>接收分组</li>
<li>还原报文</li>
</ul>
<h2 id="3、报文交换（Message-Switching）"><a href="#3、报文交换（Message-Switching）" class="headerlink" title="3、报文交换（Message Switching）"></a>3、报文交换（Message Switching）</h2><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p>
<h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><blockquote>
<p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103900.png" alt="image-20201006184451671"></p>
<p>分析：</p>
<p>电路交换：</p>
<ul>
<li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li>
<li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li>
</ul>
<p>报文交换：</p>
<ul>
<li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li>
<li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li>
</ul>
<p>分组交换：</p>
<ul>
<li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li>
<li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103949.png" alt="image-20201006185601460"></p>
<h1 id="1-4-计算机网络的定义和分类"><a href="#1-4-计算机网络的定义和分类" class="headerlink" title="1.4 计算机网络的定义和分类"></a>1.4 计算机网络的定义和分类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>计算机网络的精确定义并未统一</li>
<li>计算机网络的最简单的定义是：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong>。<ul>
<li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li>
<li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li>
<li>集合：是指至少需要两台计算机；</li>
</ul>
</li>
<li>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。<ul>
<li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li>
<li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li>
</ul>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>按交换技术分类：</strong></p>
<ul>
<li>电路交换网络</li>
<li>报文交换网络</li>
<li>分组交换网络</li>
</ul>
<p><strong>按使用者分类：</strong></p>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<p><strong>按传输介质分类：</strong></p>
<ul>
<li>有线网络</li>
<li>无线网络</li>
</ul>
<p><strong>按覆盖范围分类：</strong></p>
<ul>
<li>广域网WAN（Wide Area Network）</li>
</ul>
<p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p>
<ul>
<li>城域网MAN</li>
</ul>
<p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p>
<ul>
<li>局域网LAN</li>
</ul>
<p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit&#x2F;s 以上），但地理上范围较小（1 km 左右）</p>
<ul>
<li>个域网PAN</li>
</ul>
<p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p>
<p><strong>按拓扑结构分类：</strong></p>
<ul>
<li>总线型网络</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016103958.png" alt="image-20201007005149993"></p>
<ul>
<li>星型网络</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104005.png" alt="image-20201007005203129"></p>
<ul>
<li>环形网络</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104009.png" alt="image-20201007005212345"></p>
<ul>
<li>网状型网络</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104015.png" alt="image-20201007005249137"></p>
<h1 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104021.png" alt="image-20201007012419698"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104026.png" alt="image-20201007012439769"></p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104031.png" alt="image-20201007012943970"></p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104038.png" alt="image-20201007013119621"></p>
<blockquote>
<p>带宽1 Gb&#x2F;s的以太网，代表其额定速率是1 Gb&#x2F;s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb&#x2F;s的以太网，可能实际吞吐量只有 700 Mb&#x2F;s，甚至更低。</p>
<p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p>
</blockquote>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p>
<p>网络时延由几部分组成：</p>
<ul>
<li>发送时延</li>
</ul>
<p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p>
<ul>
<li>传播时延</li>
</ul>
<p>电磁波在信道中传播一定的距离需要花费的时间。</p>
<ul>
<li>处理时延</li>
</ul>
<p>主机或路由器在收到分组时要花费一定时间进行处理</p>
<ul>
<li>排队时延</li>
</ul>
<p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p>
<blockquote>
<p>有时会把排队时延看成<strong>处理时延 一部分</strong></p>
<p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104045.png" alt="image-20201007014139333"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104050.png" alt="image-20201007015401505"></p>
<blockquote>
<p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p>
</blockquote>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 * 带宽</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104057.png" alt="image-20201007115317347"></p>
<h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104104.png" alt="image-20201007115647631"></p>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104110.png" alt="image-20201012164544306"></p>
<h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104116.png" alt="image-20201007132900210"></p>
<h1 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h1><h2 id="1、常见的计算机网络体系结构"><a href="#1、常见的计算机网络体系结构" class="headerlink" title="1、常见的计算机网络体系结构"></a>1、常见的计算机网络体系结构</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104122.png" alt="image-20201007133848212"></p>
<blockquote>
<p>如今用的最多的是TCP&#x2F;IP体系结构，现今规模最大的、覆盖全球的、基于TCP&#x2F;IP的互联网并未使用OSI标准。</p>
<p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p>
<p>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104127.png" alt="image-20201007135220030"></p>
<blockquote>
<p>在用户主机的操作系统中，通常都带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p>
<p>而用于网络互连的路由器中，也带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p>
<p>只不过路由器一般只包含网络接口层和网际层。</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104135.png" alt="image-20201007135518050"></p>
<blockquote>
<p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p>
<p><strong>网际层</strong>：它的核心协议是IP协议。</p>
<p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p>
<p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p>
</blockquote>
<blockquote>
<p><strong>IP协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP协议和UDP协议（运输层）</strong>提供网络互连服务</p>
<p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p>
<p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p>
</blockquote>
<blockquote>
<p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104142.png" alt="image-20201007141110338"></p>
<blockquote>
<p>教学时把TCP&#x2F;IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p>
</blockquote>
<h2 id="2、计算机网络体系结构分层的必要性"><a href="#2、计算机网络体系结构分层的必要性" class="headerlink" title="2、计算机网络体系结构分层的必要性"></a>2、计算机网络体系结构分层的必要性</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104151.png" alt="image-20201007141318411"></p>
<p><strong>物理层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104156.png" alt="image-20201007141806675"></p>
<blockquote>
<p>这图说明</p>
<ul>
<li>第一，严格来说，传输媒体并不属于物理层</li>
<li>计算机传输的信号，并不是图示的方波信号</li>
</ul>
<p>这样举例只是让初学者容易理解</p>
</blockquote>
<p><strong>数据链路层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104204.png" alt="image-20201007142049812"></p>
<p><strong>网络层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104211.png" alt="image-20201007142408792"></p>
<p><strong>运输层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104216.png" alt="image-20201007142631029"></p>
<blockquote>
<p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程</p>
</blockquote>
<p><strong>应用层问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104224.png" alt="image-20201007142755720"></p>
<blockquote>
<p>应用层该用什么方法（应用层协议）去解析数据</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104231.png" alt="image-20201007204006284"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104235.png" alt="image-20201007143138937"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104241.png" alt="image-20201007195641140"></p>
<h2 id="3、计算机网络体系结构分层思想举例"><a href="#3、计算机网络体系结构分层思想举例" class="headerlink" title="3、计算机网络体系结构分层思想举例"></a>3、计算机网络体系结构分层思想举例</h2><p>例子：主机的浏览器如何与Web服务器进行通信</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104246.png" alt="image-20201007144900565"></p>
<p><strong>解析：</strong></p>
<p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104254.png" alt="image-20201007145242020"></p>
<p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p>
<p><strong>1、发送方发送</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104300.png" alt="image-20201007145441370"></p>
<blockquote>
<p>第一步：</p>
<ul>
<li><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></li>
<li>应用层将<strong>HTTP请求报文</strong>交付给<strong>运输层</strong>处理</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104304.png" alt="image-20201007145720661"></p>
<blockquote>
<p>第二步：</p>
<ul>
<li><strong>运输层</strong>给<strong>HTTP请求报文</strong>添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></li>
<li><strong>TCP报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</li>
<li><strong>运输层</strong>将T<strong>CP报文段</strong>交付给<strong>网络层</strong>处理</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104309.png" alt="image-20201007150234909"></p>
<blockquote>
<p>第三步：</p>
<ul>
<li><strong>网络层</strong>给<strong>TCP报文段</strong>添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></li>
<li><strong>IP数据报的首部格式</strong>作用是使<strong>IP数据报</strong>可以在互联网传输，也就是被路由器转发</li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong>处理</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104314.png" alt="image-20201007150723365"></p>
<blockquote>
<p>第四步：</p>
<ul>
<li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> （图示右边为首部，左边为尾部）</li>
<li>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</li>
<li>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</li>
<li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104319.png" alt="image-20201007151342502"></p>
<blockquote>
<p>第五步：</p>
<ul>
<li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络N1假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li>
<li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li>
<li><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104325.png" alt="image-20201007151900254"></p>
<blockquote>
<p>第六步：</p>
<ul>
<li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li>
</ul>
</blockquote>
<p><strong>2、路由器转发</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104331.png" alt="image-20201007152029458"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104337.png" alt="image-20201007152138961"><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104346.png" alt="image-20201007152253899"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104350.png" alt="image-20201007152627778"></p>
<blockquote>
<p>在路由器中</p>
<ul>
<li><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></li>
<li><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104356.png" alt="image-20201007152650863"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104400.png" alt="image-20201007152812431"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104404.png" alt="image-20201007153714840"></p>
<blockquote>
<p>在路由器中</p>
<ul>
<li>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></li>
<li><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></li>
<li><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li>
<li>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></li>
</ul>
</blockquote>
<p><strong>3、接收方接收</strong></p>
<blockquote>
<p>和发送方（主机）发送过程的封装正好是反着来</p>
<p>在Web 服务器上</p>
<ul>
<li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></li>
<li><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></li>
<li><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li>
</ul>
<p><strong>发回响应报文的步骤和之前过程类似</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104410.png" alt="image-20201007155051275"></p>
<h2 id="4、计算机网络体系结构中的专用术语"><a href="#4、计算机网络体系结构中的专用术语" class="headerlink" title="4、计算机网络体系结构中的专用术语"></a>4、计算机网络体系结构中的专用术语</h2><p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP&#x2F;IP的四层体系结构和五层协议体系结构</p>
<p><strong>实体</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104417.png" alt="image-20201007155444920"></p>
<p><strong>协议</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104423.png" alt="image-20201007155545934"></p>
<blockquote>
<p>协议：控制两个对等实体进行逻辑通信的规则的集合</p>
<p>协议三要素：</p>
<ul>
<li>语法：定义所交换信息的格式</li>
<li>语义：定义收发双方所要完成的操作</li>
<li>同步：定义收发双发的时序关系</li>
</ul>
</blockquote>
<p><strong>服务</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104434.png" alt="image-20201007160246561"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104757.png" alt="image-20201016104750288"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016104806.png" alt="image-20201007162620250"></p>
<h1 id="2-1、物理层的基本概念"><a href="#2-1、物理层的基本概念" class="headerlink" title="2.1、物理层的基本概念"></a>2.1、物理层的基本概念</h1><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110045.png" alt="image-20201008130211749"></p>
<h1 id="2-2、物理层下面的传输媒体"><a href="#2-2、物理层下面的传输媒体" class="headerlink" title="2.2、物理层下面的传输媒体"></a>2.2、物理层下面的传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p>
<p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p>
<h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p>
<p><strong>同轴电缆</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110056.png" alt="image-20201008132050917"></p>
<p><strong>双绞线</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110104.png" alt="image-20201008132225715"></p>
<p><strong>光纤</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110109.png" alt="image-20201008132403903"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110115.png" alt="image-20201011001240573"></p>
<blockquote>
<p><strong>多模光纤</strong></p>
<ul>
<li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li>
</ul>
<p><strong>单模光纤</strong></p>
<ul>
<li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li>
</ul>
</blockquote>
<p><strong>电力线</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110122.png" alt="image-20201008132709015"></p>
<h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><p>非导引型传输媒体是指自由空间。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110129.png" alt="image-20201008132857833"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110137.png" alt="image-20201008132943176"></p>
<p><strong>无线电波</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110142.png" alt="image-20201008133135659"></p>
<p><strong>微波</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110148.png" alt="image-20201008133317293"></p>
<p><strong>红外线</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110155.png" alt="image-20201008133421986"></p>
<p><strong>可见光</strong></p>
<p><a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110204.png" alt="image-20201008133718810"></p>
<h1 id="2-3、传输方式"><a href="#2-3、传输方式" class="headerlink" title="2.3、传输方式"></a>2.3、传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110211.png" alt="image-20201008135603009"></p>
<blockquote>
<p><strong>串行传输</strong>：</p>
<ul>
<li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li>
</ul>
<p><strong>并行传输</strong>：</p>
<ul>
<li>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</li>
<li>并行传输的优点是比串行传输的速度n倍，但成本高</li>
</ul>
<p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>
</blockquote>
<h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110224.png" alt="image-20201008140209430"></p>
<blockquote>
<p><strong>同步传输</strong>：</p>
<ul>
<li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li>
<li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li>
<li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li>
</ul>
<p>所以要使收发双发时钟保持同步</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110231.png" alt="image-20201008140850958"></p>
<blockquote>
<p><strong>异步传输</strong>：</p>
<ul>
<li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li>
<li>接收端仅在每个字节的起始处对字节内的比特实现同步</li>
<li>通常在每个字节前后分别加上起始位和结束位</li>
</ul>
</blockquote>
<h2 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h2><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p>
<p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p>
<p><strong>单向通信</strong>：</p>
<p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110239.png" alt="image-20201008141345239"></p>
<p><strong>双向交替通信</strong>：</p>
<p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110244.png" alt="image-20201008141921924"></p>
<p><strong>双向同时通信</strong>：</p>
<p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110250.png" alt="image-20201008142037846"></p>
<blockquote>
<p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p>
<p><strong>双向同时通信</strong>的传输效率最高</p>
</blockquote>
<h1 id="2-4、编码与调制"><a href="#2-4、编码与调制" class="headerlink" title="2.4、编码与调制"></a>2.4、编码与调制</h1><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110305.png" alt="image-20201008144616896"></p>
<blockquote>
<p><strong>常用术语</strong></p>
<ul>
<li><strong>数据 (data)</strong> —— 运送消息的实体。</li>
<li><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。</li>
<li><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。</li>
<li><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。</li>
<li><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</li>
<li><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li>
<li>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong> (modulation)。</li>
</ul>
</blockquote>
<p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110345.png" alt="image-20201008145747263"></p>
<h2 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a>传输媒体与信道的关系</h2><blockquote>
<p><strong>信道的几个基本概念</strong></p>
<ul>
<li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li>
<li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。</li>
</ul>
</blockquote>
<p>严格来说，传输媒体不能和信道划等号</p>
<p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110354.png" alt="image-20201008145304974"></p>
<p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110359.png" alt="image-20201008145329540"></p>
<blockquote>
<p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p>
</blockquote>
<h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><p><strong>不归零编码</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110404.png" alt="image-20201008150058039"></p>
<blockquote>
<ul>
<li>正电平表示比特1&#x2F;0</li>
<li>负电平表示比特0&#x2F;1</li>
</ul>
<p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110410.png" alt="image-20201008150528228"></p>
<blockquote>
<p>这需要发送方的发送与接收方的接收做到严格的同步</p>
<ul>
<li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li>
<li><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</li>
</ul>
<p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p>
</blockquote>
<p><strong>归零编码</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110416.png" alt="image-20201008195033189"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110421.png" alt="image-20201008151347028"></p>
<blockquote>
<p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p>
</blockquote>
<p><strong>曼彻斯特编码</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110427.png" alt="image-20201008195148727"></p>
<blockquote>
<p>在每个码元时间的中间时刻，信号都会发生跳变</p>
<ul>
<li>负跳变表示比特1&#x2F;0</li>
<li>正跳变表示比特0&#x2F;1</li>
<li>码元中间时刻的跳变即表示时钟，又表示数据</li>
</ul>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
<p>传统以太网使用的就是曼切斯特编码</p>
</blockquote>
<p><strong>差分曼彻斯特编码</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110432.png" alt="image-20201008195235561"></p>
<blockquote>
<p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p>
<ul>
<li><strong>跳变仅表示时钟</strong></li>
<li><strong>码元开始处电平是否变换表示数据</strong><ul>
<li>变化表示比特1&#x2F;0</li>
<li>不变化表示比特0&#x2F;1</li>
</ul>
</li>
</ul>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
<p>比曼彻斯特编码变化少，更适合较高的传输速率</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110438.png" alt="image-20201008153522501"></p>
<h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK&#x2F;直接序列扩频DSSS&#x2F;正交频分复用OFDM等<strong>调制</strong>方式。</p>
<p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p>
<p><strong>基本调制方法</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110446.png" alt="image-20201008155429044"></p>
<blockquote>
<ul>
<li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li>
<li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li>
<li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li>
</ul>
<p>但是使用基本调制方法，1个码元只能包含1个比特信息</p>
</blockquote>
<p><strong>混合调制</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110451.png" alt="image-20201008155804617"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110455.png" alt="image-20201008155835940"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110500.png" alt="image-20201008155955169"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110504.png" alt="image-20201008160133748"></p>
<blockquote>
<p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110509.png" alt="image-20201008160208060"></p>
<h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p>
<h1 id="2-5、信道的极限容量"><a href="#2-5、信道的极限容量" class="headerlink" title="2.5、信道的极限容量"></a>2.5、信道的极限容量</h1><ul>
<li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</li>
<li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110515.png" alt="image-20201010204336400"></p>
<p>失真的原因：</p>
<ul>
<li>码元传输的速率越高</li>
<li>信号传输的距离越远</li>
<li>噪声干扰越大</li>
<li>传输媒体质量越差</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110520.png" alt="image-20201010204818976"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110527.png" alt="image-20201010204928756"></p>
<p>奈氏准则和香农公式对比：</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110532.png" alt="image-20201010205029346"></p>
<h1 id="补充：信道复用技术"><a href="#补充：信道复用技术" class="headerlink" title="补充：信道复用技术"></a>补充：信道复用技术</h1><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p>
<h2 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h2><p>复用 (multiplexing) 是通信技术中的基本概念。</p>
<p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110539.png" alt="image-20201011001949479"></p>
<p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p>
<ul>
<li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>
<li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110544.png" alt="image-20201011002236208"></p>
<p><strong>时分复用TDM (Time Division Multiplexing)</strong></p>
<ul>
<li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li>
<li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110547.png" alt="image-20201011002540041"></p>
<ul>
<li><strong>时分复用可能会造成线路资源的浪费</strong><ul>
<li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110552.png" alt="image-20201011002842704"></p>
<p><strong>统计时分复用 STDM (Statistic TDM)</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110556.png" alt="image-20201011002953703"></p>
<h2 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h2><p>波分复用 WDM(Wavelength Division Multiplexing)</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016110602.png" alt="image-20201011003214653"></p>
<h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>码分复用 CDM (Code Division Multiplexing)</p>
<ul>
<li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li>
<li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li>
<li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>
</ul>
<h1 id="3-1、数据链路层概述"><a href="#3-1、数据链路层概述" class="headerlink" title="3.1、数据链路层概述"></a>3.1、数据链路层概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>
<p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111415.png" alt="image-20201011102531462"></p>
<p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111422.png" alt="image-20201014004326549"></p>
<p><strong>从层次上来看数据的流动</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111428.png" alt="image-20201011102618878"></p>
<p><strong>仅从数据链路层观察帧的流动</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111433.png" alt="image-20201011102653161"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113628.png" alt="image-20201011102733584"></p>
<blockquote>
<p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p>
<p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p>
</blockquote>
<p><strong>数据链路层使用的信道</strong></p>
<p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111444.png" alt="image-20201014004459744"></p>
<blockquote>
<p><strong>局域网属于数据链路层</strong></p>
<p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p>
<p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p>
</blockquote>
<h2 id="三个重要问题"><a href="#三个重要问题" class="headerlink" title="三个重要问题"></a>三个重要问题</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong></p>
<p><strong>封装成帧</strong></p>
<ul>
<li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li>
<li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111452.png" alt="image-20201011103650253"></p>
<p><strong>差错控制</strong></p>
<p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111458.png" alt="image-20201011103917512"></p>
<p><strong>可靠传输</strong></p>
<p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p>
<p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p>
<p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111504.png" alt="image-20201011105314053"></p>
<blockquote>
<p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p>
</blockquote>
<p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p>
<p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111515.png" alt="image-20201011105824466"></p>
<p>可以用编址（地址）的来解决</p>
<p>将帧的目的地址添加在帧中一起传输</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111521.png" alt="image-20201011110017415"></p>
<p>还有数据碰撞问题</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111530.png" alt="image-20201011110129994"></p>
<blockquote>
<p>随着技术的发展，交换技术的成熟，</p>
<p>在 有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了</p>
<p>共享式局域网</p>
<p>在无线局域网中仍然使用的是共享信道技术</p>
</blockquote>
<h1 id="3-2、封装成帧"><a href="#3-2、封装成帧" class="headerlink" title="3.2、封装成帧"></a>3.2、封装成帧</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p>
<ul>
<li><strong>帧头和帧尾中包含有重要的控制信息</strong></li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111538.png" alt="image-20201011110851301"></p>
<p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p>
<p>答：需要帧头和帧尾来做<strong>帧定界</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111546.png" alt="image-20201011111334052"></p>
<p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111553.png" alt="image-20201011111729324"></p>
<blockquote>
<p>前导码</p>
<ul>
<li>前同步码：作用是使接收方的时钟同步</li>
<li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li>
</ul>
</blockquote>
<p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111559.png" alt="image-20201011112450187"></p>
<h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><blockquote>
<p><strong>透明</strong></p>
<p>指某一个实际存在的事物看起来却好像不存在一样。</p>
</blockquote>
<p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p>
<p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中， 恰好也包含这个特定数值，接收方就不能正确接收</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111606.png" alt="image-20201011113207944"></p>
<blockquote>
<p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p>
</blockquote>
<p><strong>解决透明传输问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111611.png" alt="image-20201011113804721"></p>
<ul>
<li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li>
<li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li>
</ul>
<p><strong>帧的数据部分长度</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111617.png" alt="image-20201011115008209"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111623.png" alt="image-20201011115049672"></p>
<h1 id="3-3、差错检测"><a href="#3-3、差错检测" class="headerlink" title="3.3、差错检测"></a>3.3、差错检测</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111635.png" alt="image-20201011133757804"></p>
<h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111643.png" alt="image-20201011234428217"></p>
<h2 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111655.png" alt="image-20201011234605045"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111703.png" alt="image-20201011234701845"></p>
<p><strong>例题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111710.png" alt="image-20201011235128869"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111718.png" alt="image-20201011235325022"></p>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111730.png" alt="image-20201011235726437"></p>
<blockquote>
<p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p>
</blockquote>
<h1 id="3-4、可靠传输"><a href="#3-4、可靠传输" class="headerlink" title="3.4、可靠传输"></a>3.4、可靠传输</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>下面是比特差错</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111737.png" alt="image-20201012153605893"></p>
<p><strong>其他传输差错</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111744.png" alt="image-20201012153811724"></p>
<ul>
<li>分组丢失</li>
</ul>
<p>路由器输入队列快满了，主动丢弃收到的分组</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111750.png" alt="image-20201012154910921"></p>
<ul>
<li>分组失序</li>
</ul>
<p>数据并未按照发送顺序依次到达接收端</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111756.png" alt="image-20201012155300937"></p>
<ul>
<li>分组重复</li>
</ul>
<p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111803.png" alt="image-20201012160026362"></p>
<h2 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h2><ul>
<li>停止-等待协议SW</li>
<li>回退N帧协议GBN</li>
<li>选择重传协议SR</li>
</ul>
<blockquote>
<p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p>
</blockquote>
<h2 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h2><h3 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h3><p><strong>确认与否认</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111812.png" alt="image-20201012162009780"></p>
<p><strong>超时重传</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111818.png" alt="image-20201012162112151"></p>
<p><strong>确认丢失</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111823.png" alt="image-20201012162318298"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111827.png" alt="image-20201012162348428"></p>
<blockquote>
<p>既然数据分组需要编号，确认分组是否需要编号？</p>
<p>要。如下图所示</p>
</blockquote>
<p><strong>确认迟到</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111831.png" alt="image-20201012162815885"></p>
<blockquote>
<p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p>
</blockquote>
<p><strong>注意事项</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111835.png" alt="image-20201012164008780"></p>
<h3 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h3><p>假设收发双方之间是一条直通的信道</p>
<ul>
<li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li>
<li><strong>RTT</strong>：是收发双方之间的往返时间</li>
<li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li>
</ul>
<p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111840.png" alt="image-20201012164924635"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111844.png" alt="image-20201012181005719"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111848.png" alt="image-20201012181047665"></p>
<blockquote>
<p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p>
</blockquote>
<h2 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h2><h3 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h3><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111852.png" alt="image-20201012190027828"></p>
<p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111857.png" alt="image-20201012190632086"></p>
<h3 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h3><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111901.png" alt="image-20201012191936466"></p>
<p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111905.png" alt="image-20201012192932035"></p>
<p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111910.png" alt="image-20201012193212419"></p>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111915.png" alt="image-20201012194304696"></p>
<blockquote>
<p>累计确认</p>
<p>优点:</p>
<ul>
<li>即使确认分组丢失，发送方也可能不必重传</li>
<li>减小接收方的开销</li>
<li>减小对网络资源的占用</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li>
</ul>
</blockquote>
<h3 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h3><p>例如</p>
<p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111925.png" alt="image-20201012195440780"></p>
<p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111930.png" alt="image-20201012195629368"></p>
<p>接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111935.png" alt="image-20201012195836902"></p>
<p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111940.png" alt="image-20201012200120166"></p>
<p>如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111947.png" alt="image-20201012200454557"></p>
<p>若WT超过取值范围，例如WT&#x3D;8，会出现什么情况？</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016111955.png" alt="image-20201012201109774"></p>
<p>习题</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112002.png" alt="image-20201012202419107"></p>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112009.png" alt="image-20201012202222138"></p>
<ul>
<li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li>
<li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li>
<li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li>
</ul>
<h2 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112016.png" alt="image-20201012203638722"></p>
<p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1c4411d7jb?p=27">具体流程请看视频</a></p>
<p><strong>习题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112023.png" alt="image-20201012205250996"></p>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112029.png" alt="image-20201012204742870"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112033.png" alt="image-20201012205133924"></p>
<h1 id="3-5、点对点协议PPP"><a href="#3-5、点对点协议PPP" class="headerlink" title="3.5、点对点协议PPP"></a>3.5、点对点协议PPP</h1><ul>
<li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li>
<li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li>
<li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112038.png" alt="image-20201012210844629"></p>
<ul>
<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112044.png" alt="image-20201012211423528"></p>
<h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>必须规定特殊的字符作为帧定界符</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112053.png" alt="image-20201012211826281"></p>
<h2 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h2><p>必须保证数据传输的透明性</p>
<p>实现透明传输的方法</p>
<ul>
<li>面向字节的异步链路：字节填充法（插入“转义字符”）</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112059.png" alt="image-20201012212148803"></p>
<ul>
<li>面向比特的同步链路：比特填充法（插入“比特0”）</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112104.png" alt="image-20201012212255550"></p>
<h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112109.png" alt="image-20201012212558654"></p>
<h2 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h2><ul>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li>
<li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112117.png" alt="image-20201012213021860"></p>
<blockquote>
<p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p>
</blockquote>
<h1 id="3-6、媒体接入控制（介质访问控制）——广播信道"><a href="#3-6、媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="3.6、媒体接入控制（介质访问控制）——广播信道"></a>3.6、媒体接入控制（介质访问控制）——广播信道</h1><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p>
<blockquote>
<p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p>
</blockquote>
<p><strong>局域网的数据链路层</strong></p>
<ul>
<li>局域网最主要的<strong>特点</strong>是：<ul>
<li>网络为一个单位所拥有；</li>
<li>地理范围和站点数目均有限。</li>
</ul>
</li>
<li>局域网具有如下<strong>主要优点</strong>：<ul>
<li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li>
<li>提高了系统的可靠性、可用性和残存性。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112123.png" alt="image-20201013201521915"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112127.png" alt="image-20201013201533445"></p>
<p><strong>数据链路层的两个子层</strong></p>
<p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p>
<ol>
<li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li>
<li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li>
</ol>
<p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。 <strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112133.png" alt="image-20201013201133903"></p>
<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>为什么要媒体接入控制（介质访问控制）？</p>
<p><strong>共享信道带来的问题</strong></p>
<p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112139.png" alt="image-20201013152007335"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112143.png" alt="image-20201013152453425"></p>
<blockquote>
<p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p>
</blockquote>
<h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>信道复用</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112148.png" alt="image-20201013153642544"></p>
<p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p>
<ul>
<li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>
<li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112156.png" alt="image-20201013153947668"></p>
<p><strong>时分复用TDM (Time Division Multiplexing)</strong></p>
<ul>
<li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li>
<li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112201.png" alt="image-20201013154142540"></p>
<p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112206.png" alt="image-20201013202218132"></p>
<blockquote>
<p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p>
<p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p>
</blockquote>
<p><strong>码分复用 CDM (Code Division Multiplexing)</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112215.png" alt="image-20201013203126625"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112228.png" alt="image-20201013203324709"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112236.png" alt="image-20201013203459640"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112240.png" alt="image-20201013203819578"></p>
<h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><p>受控接入</p>
<p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p>
<p><strong>随机接入</strong></p>
<p><strong>重点</strong></p>
<h2 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h2><p><strong>总线局域网使用协议：CSMA&#x2F;CD</strong></p>
<h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p>
<blockquote>
<p><strong>以太网（Ethernet）**是一种计算机**局域网技术**。IEEE组织的IEEE 802.3标准制定了</strong>以太网（Ethernet）**的技术标准</p>
<p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112250.png" alt="image-20201013211620687"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112258.png" alt="image-20201013213102777"></p>
<h3 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h3><p>表示许多主机以多点接入的方式连接在一根总线上。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112304.png" alt="image-20201013215400688"></p>
<h3 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h3><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112309.png" alt="image-20201013215530979"></p>
<p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p>
<h3 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h3><ul>
<li>**“碰撞检测”**就是计算机**边发送数据边检测**信道上的信号电压大小。</li>
<li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li>
<li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li>
<li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li>
<li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li>
<li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112322.png" alt="image-20201013221240514"></p>
<blockquote>
<p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112328.png" alt="image-20201013221834942"></p>
<p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p>
</blockquote>
<h3 id="CSMA-x2F-CD-协议工作流程"><a href="#CSMA-x2F-CD-协议工作流程" class="headerlink" title="CSMA&#x2F;CD 协议工作流程"></a>CSMA&#x2F;CD 协议工作流程</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112333.png" alt="image-20201013221705893"></p>
<h3 id="CSMA-x2F-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-x2F-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）"></a>CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112340.png" alt="image-20201013223235305"></p>
<h3 id="CSMA-x2F-CD-协议工作——最小帧长"><a href="#CSMA-x2F-CD-协议工作——最小帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最小帧长"></a>CSMA&#x2F;CD 协议工作——最小帧长</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112347.png" alt="image-20201013224051932"></p>
<h3 id="CSMA-x2F-CD-协议工作——最大帧长"><a href="#CSMA-x2F-CD-协议工作——最大帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最大帧长"></a>CSMA&#x2F;CD 协议工作——最大帧长</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112356.png" alt="image-20201013225400777"></p>
<h3 id="CSMA-x2F-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-x2F-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA&#x2F;CD 协议工作——截断二进制指数退避算法"></a>CSMA&#x2F;CD 协议工作——截断二进制指数退避算法</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112403.png" alt="image-20201013230717856"></p>
<h3 id="CSMA-x2F-CD-协议工作——信道利用率"><a href="#CSMA-x2F-CD-协议工作——信道利用率" class="headerlink" title="CSMA&#x2F;CD 协议工作——信道利用率"></a>CSMA&#x2F;CD 协议工作——信道利用率</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112412.png" alt="image-20201013231430295"></p>
<h3 id="CSMA-x2F-CD-协议工作——帧接收流程"><a href="#CSMA-x2F-CD-协议工作——帧接收流程" class="headerlink" title="CSMA&#x2F;CD 协议工作——帧接收流程"></a>CSMA&#x2F;CD 协议工作——帧接收流程</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112420.png" alt="image-20201013231703302"></p>
<h3 id="CSMA-x2F-CD-协议的重要特性"><a href="#CSMA-x2F-CD-协议的重要特性" class="headerlink" title="CSMA&#x2F;CD 协议的重要特性"></a>CSMA&#x2F;CD 协议的重要特性</h3><ul>
<li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li>
<li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li>
<li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li>
</ul>
<blockquote>
<p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p>
<p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CS协议</strong></p>
</blockquote>
<h2 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h2><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong></p>
<h3 id="为什么无线局域网要使用CSMA-x2F-CA协议"><a href="#为什么无线局域网要使用CSMA-x2F-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA&#x2F;CA协议"></a>为什么无线局域网要使用CSMA&#x2F;CA协议</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112427.png" alt="image-20201014192811760"></p>
<h3 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112435.png" alt="image-20201014200149717"></p>
<h3 id="CSMA-x2F-CA协议的工作原理"><a href="#CSMA-x2F-CA协议的工作原理" class="headerlink" title="CSMA&#x2F;CA协议的工作原理"></a>CSMA&#x2F;CA协议的工作原理</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112441.png" alt="image-20201014200833233"></p>
<blockquote>
<p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p>
<ul>
<li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li>
</ul>
<p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p>
<ul>
<li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112446.png" alt="image-20201014201511741"></p>
<blockquote>
<p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p>
<p>防止多个站点同时发送数据而产生碰撞</p>
</blockquote>
<p><strong>使用退避算法的时机</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112451.png" alt="image-20201014201927680"></p>
<h3 id="CSMA-x2F-CA协议的退避算法"><a href="#CSMA-x2F-CA协议的退避算法" class="headerlink" title="CSMA&#x2F;CA协议的退避算法"></a>CSMA&#x2F;CA协议的退避算法</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112457.png" alt="image-20201014202213766"></p>
<p><strong>退避算法的示例</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112503.png" alt="image-20201014202819851"></p>
<h3 id="CSMA-x2F-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-x2F-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA&#x2F;CA协议的信道预约和虚拟载波监听"></a>CSMA&#x2F;CA协议的信道预约和虚拟载波监听</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112508.png" alt="image-20201014203119710"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112512.png" alt="image-20201014203506878"></p>
<p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112517.png" alt="image-20201014203859033"></p>
<h1 id="3-7、MAC地址、IP地址以及ARP协议"><a href="#3-7、MAC地址、IP地址以及ARP协议" class="headerlink" title="3.7、MAC地址、IP地址以及ARP协议"></a>3.7、MAC地址、IP地址以及ARP协议</h1><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112523.png" alt="image-20201014222831663"></p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><blockquote>
<ul>
<li>使用点对点信道的数据链路层不需要使用地址</li>
<li>使用广播信道的数据链路层必须使用地址来区分各主机</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112531.png" alt="image-20201014223659993"></p>
<h3 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112536.png" alt="image-20201014224732019"></p>
<blockquote>
<p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p>
</blockquote>
<h3 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112542.png" alt="image-20201014225358570"></p>
<blockquote>
<p><strong>组织唯一标识符OUI</strong></p>
<ul>
<li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li>
</ul>
<p><strong>网络接口标识符</strong></p>
<ul>
<li>由获得OUI的厂商自行随意分配</li>
</ul>
<p><strong>EUI-48</strong></p>
<ul>
<li>48是这个MAC地址的位数</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112546.png" alt="image-20201014230248959"></p>
<blockquote>
<p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p>
</blockquote>
<p><strong>关于无效的 MAC 帧</strong></p>
<ul>
<li>数据字段的长度与长度字段的值不一致；</li>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
</ul>
<blockquote>
<p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong></p>
</blockquote>
<h3 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112552.png" alt="image-20201014230625182"></p>
<h3 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112557.png" alt="image-20201014230822305"></p>
<blockquote>
<p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112602.png" alt="image-20201014231244655"></p>
<blockquote>
<p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p>
<p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p>
<p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p>
<p>并将该帧交给其上层处理</p>
</blockquote>
<h3 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112607.png" alt="image-20201014231754669"></p>
<blockquote>
<p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112611.png" alt="image-20201014232132424"></p>
<blockquote>
<p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p>
</blockquote>
<h3 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112616.png" alt="image-20201014232714791"></p>
<blockquote>
<p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p>
<p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p>
<p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112622.png" alt="image-20201015001243584"></p>
<blockquote>
<p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112627.png" alt="image-20201015001535528"></p>
<blockquote>
<p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112632.png" alt="image-20201015002054876"></p>
<blockquote>
<p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p>
<p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p>
<p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p>
</blockquote>
<blockquote>
<p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p>
</blockquote>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p>
<p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p>
<h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112643.png" alt="image-20201015104441580"></p>
<h3 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112648.png" alt="image-20201015104913755"></p>
<h3 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h3><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112654.png" alt="image-20201015105455043"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112701.png" alt="image-20201015105619301"></p>
<blockquote>
<p>如何从IP地址找出其对应的MAC地址？</p>
<p>ARP协议</p>
</blockquote>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>如何从IP地址找出其对应的MAC地址？</p>
<p>ARP（地址解析协议）</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112708.png" alt="image-20201015113826197"></p>
<p>ARP高速缓存表</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112714.png" alt="image-20201015114052206"></p>
<blockquote>
<p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112718.png" alt="image-20201015114444263"></p>
<blockquote>
<p>ARP请求报文有具体的格式，上图的只是简单描述</p>
<p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p>
<p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112722.png" alt="image-20201015114811501"></p>
<blockquote>
<p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p>
<p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p>
<p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112728.png" alt="image-20201015115212170"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112733.png" alt="image-20201015115236673"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112738.png" alt="image-20201015115252972"></p>
<p>动态与静态的区别</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112742.png" alt="image-20201015115831543"></p>
<p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112746.png" alt="image-20201015120108028"></p>
<blockquote>
<p>ARP协议的使用是逐段链路进行的</p>
</blockquote>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112752.png" alt="image-20201015120707150"></p>
<blockquote>
<p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>
</blockquote>
<h1 id="3-8、集线器与交换机的区别"><a href="#3-8、集线器与交换机的区别" class="headerlink" title="3.8、集线器与交换机的区别"></a>3.8、集线器与交换机的区别</h1><h2 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112800.png" alt="image-20201015144628691"></p>
<blockquote>
<ul>
<li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li>
<li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li>
<li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li>
<li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA&#x2F;CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li>
</ul>
</blockquote>
<h3 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h3><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112808.png" alt="image-20201015145732275"></p>
<blockquote>
<ul>
<li><strong>优点</strong><ol>
<li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li>
<li>扩大了以太网覆盖的地理范围。</li>
</ol>
</li>
<li><strong>缺点</strong><ol>
<li>碰撞域增大了，但总的吞吐量并未提高。</li>
<li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>碰撞域</strong></p>
<ul>
<li>**碰撞域（collision domain）**又称为**冲突域**，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li>
<li>碰撞域越大，发生碰撞的概率越高。</li>
</ul>
<h2 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>扩展以太网更常用的方法是在数据链路层进行。</li>
<li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112814.png" alt="image-20201015150620067"></p>
<blockquote>
<p><strong>网桥</strong></p>
<ul>
<li>网桥工作在数据链路层。</li>
<li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li>
<li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</li>
</ul>
<p><strong>交换机</strong></p>
<ul>
<li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li>
<li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li>
<li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li>
</ul>
</blockquote>
<h3 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a>集线器HUB与交换机SWITCH区别</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112819.png" alt="image-20201015152232158"></p>
<blockquote>
<p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p>
<p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112824.png" alt="image-20201015152858146"></p>
<blockquote>
<p><strong>以太网交换机的交换方式</strong></p>
<ul>
<li>存储转发方式<ul>
<li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li>
</ul>
</li>
<li>直通 (cut-through) 方式<ul>
<li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li>
<li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li>
</ul>
</li>
</ul>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><strong>对比集线器和交换机</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112831.png" alt="image-20201015153907268"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112839.png" alt="image-20201015154523036"></p>
<blockquote>
<p>多台主机同时给另一台主机发送单播帧</p>
<p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p>
<p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p>
<p><strong>单播</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112849.png" alt="image-20201015155408692"></p>
<p><strong>广播</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112855.png" alt="image-20201015155440402"></p>
<p><strong>多个单播</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112900.png" alt="image-20201015155526386"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112904.png" alt="image-20201015155706698"></p>
<p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112909.png" alt="image-20201015160146482"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112914.png" alt="image-20201015160526999"></p>
<blockquote>
<p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p>
</blockquote>
<h1 id="3-9、以太网交换机自学习和转发帧的流程"><a href="#3-9、以太网交换机自学习和转发帧的流程" class="headerlink" title="3.9、以太网交换机自学习和转发帧的流程"></a>3.9、以太网交换机自学习和转发帧的流程</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016114148.png" alt="image-20201015161015165"></p>
<h2 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h2><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p>
<p><strong>A -&gt; B</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112928.png" alt="image-20201015161458528"></p>
<blockquote>
<ol>
<li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li>
<li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li>
<li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li>
<li>交换机向除接口 1 以外的所有的接口广播这个帧</li>
<li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li>
<li>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</li>
<li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li>
<li>主机B发现是给自己的帧，接受该帧</li>
</ol>
</blockquote>
<p><strong>B -&gt; A</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112933.png" alt="image-20201015162310922"></p>
<blockquote>
<ol>
<li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li>
<li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li>
<li>主机 A 发现目的地址是它，就接受该帧</li>
<li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li>
</ol>
</blockquote>
<p><strong>E -&gt; A</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112939.png" alt="image-20201015162622462"></p>
<blockquote>
<ol>
<li>E 向 A发送一帧</li>
<li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li>
<li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li>
<li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li>
<li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li>
<li>主机 A 发现目的地址是它，就接受该帧</li>
</ol>
</blockquote>
<p><strong>G -&gt; A</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112944.png" alt="image-20201015163157140"></p>
<blockquote>
<p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p>
<ol>
<li>主机 G 发送给 主机 A 一个帧</li>
<li>主机 A 和 交换机接口 1都能接收到</li>
<li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li>
<li>交换机 1收到该帧后，首先进行登记工作</li>
<li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li>
<li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 讲帧转发出去，因为这是没有必要，于是丢弃该帧</li>
</ol>
</blockquote>
<p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016112950.png" alt="image-20201015164210543"></p>
<blockquote>
<p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p>
<p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p>
</blockquote>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>交换机自学习和转发帧的步骤归纳</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113001.png" alt="image-20201015170656500"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113006.png" alt="image-20201015170739679"></p>
<h1 id="3-10、以太网交换机的生成树协议STP"><a href="#3-10、以太网交换机的生成树协议STP" class="headerlink" title="3.10、以太网交换机的生成树协议STP"></a>3.10、以太网交换机的生成树协议STP</h1><h2 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113013.png" alt="image-20201015171453001"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113040.png" alt="image-20201015171515481"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113046.png" alt="image-20201015171900775"></p>
<h2 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113052.png" alt="image-20201015172204419"></p>
<blockquote>
<ul>
<li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (Spanning Tree Protocol)。</li>
<li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113105.png" alt="image-20201015202257756"></p>
<h1 id="3-11、虚拟局域网VLAN"><a href="#3-11、虚拟局域网VLAN" class="headerlink" title="3.11、虚拟局域网VLAN"></a>3.11、虚拟局域网VLAN</h1><h2 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h2><p><strong>广播风暴</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113314.png" alt="image-20201015202859124"></p>
<p><strong>分割广播域的方法</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113321.png" alt="image-20201015203113654"></p>
<blockquote>
<p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p>
</blockquote>
<h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113335.png" alt="image-20201015203559548"></p>
<blockquote>
<ul>
<li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li>
<li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>： <strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li>
<li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li>
<li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li>
<li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li>
</ul>
</blockquote>
<h2 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h2><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p>
<ul>
<li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li>
<li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113343.png" alt="image-20201015204639599"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113350.png" alt="image-20201015204749141"></p>
<p><strong>Access端口</strong></p>
<p>交换机与用户计算机之间的互连</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113355.png" alt="image-20201015205311757"></p>
<blockquote>
<p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p>
</blockquote>
<p><strong>Truck端口</strong></p>
<p>交换机之间或交换机与路由器之间的互连</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113402.png" alt="image-20201015205947636"></p>
<p><strong>小例题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113407.png" alt="image-20201015210417695"></p>
<p><strong>华为交换机私有的Hybrid端口类型</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113415.png" alt="image-20201015211031361"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113422.png" alt="image-20201015211349531"></p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201016113427.png" alt="image-20201015211512622"></p>
<blockquote>
<p><strong>虚拟局域网优点</strong></p>
<p>虚拟局域网（VLAN）技术具有以下主要优点：</p>
<ol>
<li>改善了性能</li>
<li>简化了管理</li>
<li>降低了成本</li>
<li>改善了安全性</li>
</ol>
</blockquote>
<h1 id="4-1、网络层概述"><a href="#4-1、网络层概述" class="headerlink" title="4.1、网络层概述"></a>4.1、网络层概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152202.png" alt="image-20201017134630948"></p>
<blockquote>
<p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p>
<p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p>
<p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p>
</blockquote>
<ul>
<li><p>要实现网络层任务，需要解决一下主要问题：</p>
<ul>
<li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li>
</ul>
<p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p>
<ul>
<li>网络层寻址问题</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152233.png" alt="image-20201017135644630"></p>
<ul>
<li>路由选择问题</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152238.png" alt="image-20201017135710478"></p>
<blockquote>
<p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p>
<p><strong>依据数据包的目的地址和路由器中的路由表</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152251.png" alt="image-20201017135914985"></p>
<p>但在实际当中，路由器是怎样知道这些路由记录？</p>
<ul>
<li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li>
<li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152256.png" alt="image-20201017142545630"></p>
<blockquote>
<p>补充 <strong>网络层（网际层）**除了 **IP协议**外，还有之前介绍过的**地址解析协议ARP**，还有</strong>网际控制报文协议ICMP<strong>，</strong>网际组管理协议IGMP**</p>
</blockquote>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152302.png" alt="image-20201017140623851"></p>
<h1 id="4-2、网络层提供的两种服务"><a href="#4-2、网络层提供的两种服务" class="headerlink" title="4.2、网络层提供的两种服务"></a>4.2、网络层提供的两种服务</h1><ul>
<li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li>
<li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li>
</ul>
<h2 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2><p><strong>一种观点：让网络负责可靠交付</strong></p>
<ul>
<li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li>
<li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。</li>
<li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152309.png" alt="image-20201017141425892"></p>
<p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p>
<blockquote>
<ul>
<li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li>
<li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li>
</ul>
</blockquote>
<h2 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2><p><strong>另一种观点：网络提供数据报服务</strong></p>
<ul>
<li>互联网的先驱者提出了一种崭新的网络设计思路。</li>
<li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li>
<li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li>
<li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152316.png" alt="image-20201017141851030"></p>
<p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p>
<blockquote>
<p><strong>尽最大努力交付</strong></p>
<ul>
<li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li>
<li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li>
<li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li>
</ul>
</blockquote>
<h2 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h2><table>
<thead>
<tr>
<th><strong>对比的方面</strong></th>
<th><strong>虚电路服务</strong></th>
<th><strong>数据报服务</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>思路</strong></td>
<td><strong>可靠通信应当由网络来保证</strong></td>
<td><strong>可靠通信应当由用户主机来保证</strong></td>
</tr>
<tr>
<td><strong>连接的建立</strong></td>
<td><strong>必须有</strong></td>
<td><strong>不需要</strong></td>
</tr>
<tr>
<td><strong>终点地址</strong></td>
<td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td>
<td><strong>每个分组都有终点的完整地址</strong></td>
</tr>
<tr>
<td><strong>分组的转发</strong></td>
<td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td>
<td><strong>每个分组独立选择路由进行转发</strong></td>
</tr>
<tr>
<td><strong>当结点出故障时</strong></td>
<td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td>
<td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td>
</tr>
<tr>
<td><strong>分组的顺序</strong></td>
<td><strong>总是按发送顺序到达终点</strong></td>
<td><strong>到达终点时不一定按发送顺序</strong></td>
</tr>
<tr>
<td><strong>端到端的差错处理和流量控制</strong></td>
<td><strong>可以由网络负责，也可以由用户主机负责</strong></td>
<td><strong>由用户主机负责</strong></td>
</tr>
</tbody></table>
<h1 id="4-3、IPv4"><a href="#4-3、IPv4" class="headerlink" title="4.3、IPv4"></a>4.3、IPv4</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152333.png" alt="image-20201017143206060"></p>
<h2 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152339.png" alt="image-20201017144317166"></p>
<ul>
<li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li>
<li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li>
<li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li>
</ul>
<p><strong>A类地址</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152344.png" alt="image-20201017145210533"></p>
<p><strong>B类地址</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152350.png" alt="image-20201017145508001"></p>
<p><strong>C类地址</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152356.png" alt="image-20201017150204774"></p>
<p><strong>练习</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152401.png" alt="image-20201017150543386"></p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><strong>IP 地址的指派范围</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152407.png" alt="image-20201017152911541"></p>
<p><strong>一般不使用的特殊的 IP 地址</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152412.png" alt="image-20201017152959586"></p>
<p><strong>IP 地址的一些重要特点</strong></p>
<p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p>
<ul>
<li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li>
<li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li>
</ul>
<p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p>
<ul>
<li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li>
</ul>
<p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p>
<p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p>
<h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><h3 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h3><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p>
<ul>
<li>IP 地址空间的利用率有时很低。</li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li>
<li>两级的 IP 地址不够灵活。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152418.png" alt="image-20201017154645198"></p>
<p>如果想要将原来的网络划分成三个独立的网路</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152423.png" alt="image-20201017154852896"></p>
<p>所以是否可以从主机号部分借用一部分作为子网号</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152428.png" alt="image-20201017155026814"></p>
<blockquote>
<p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p>
<p>所以就有了划分子网的工具：<strong>子网掩码</strong></p>
<ul>
<li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li>
<li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li>
<li>划分子网已成为互联网的正式标准协议。</li>
</ul>
</blockquote>
<h3 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h3><p>基本思路</p>
<ul>
<li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li>
<li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152434.png" alt="image-20201017155930011"></p>
<ul>
<li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li>
<li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li>
<li>最后就将 IP 数据报直接交付目的主机。</li>
</ul>
<p>划分为三个子网后对外仍是一个网络</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152440.png" alt="image-20201017160116239"></p>
<blockquote>
<ul>
<li><strong>优点</strong><ol>
<li>减少了 IP 地址的浪费</li>
<li>使网络的组织更加灵活</li>
<li>更便于维护和管理</li>
</ol>
</li>
<li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li>
</ul>
</blockquote>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152446.png" alt="image-20201017160252066"></p>
<blockquote>
<p><strong>(IP 地址) AND (子网掩码) &#x3D; 网络地址</strong> 重要，下面很多相关知识都会用到</p>
</blockquote>
<p>举例</p>
<p>例子1</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152453.png" alt="image-20201017161651058"></p>
<p>例子2</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152459.png" alt="image-20201017161719339"></p>
<p><strong>默认子网掩码</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152505.png" alt="image-20201017162807076"></p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152510.png" alt="image-20201017162938612"></p>
<blockquote>
<ul>
<li>子网掩码是一个网络或一个子网的重要属性。</li>
<li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li>
<li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li>
<li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li>
</ul>
</blockquote>
<h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><h3 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h3><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152517.png" alt="image-20201017164031532"></p>
<blockquote>
<p><strong>CIDR 最主要的特点</strong></p>
<ul>
<li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li>
<li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li>
</ul>
</blockquote>
<h3 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152523.png" alt="image-20201017165037268"></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152527.png" alt="image-20201017165113442"></p>
<h3 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152532.png" alt="image-20201017165615915"></p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152717.png" alt="image-20201020152711493"></p>
<h2 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h2><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p>
<h3 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152733.png" alt="image-20201018143550103"></p>
<p><strong>划分子网的IPv4就是定长的子网掩码</strong></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152739.png" alt="image-20201018140809079"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152743.png" alt="image-20201018140916631"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152905.png" alt="image-20201020152900871"></p>
<blockquote>
<p>通过上面步骤分析，就可以从子网1<del>8中任选5个分配给左图中的N1</del>N5</p>
<p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p>
<p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p>
</blockquote>
<h3 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152921.png" alt="image-20201018143632352"></p>
<p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152926.png" alt="image-20201018142333145"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152934.png" alt="image-20201018143344440"></p>
<h1 id="4-4、IP数据报的发送和转发过程"><a href="#4-4、IP数据报的发送和转发过程" class="headerlink" title="4.4、IP数据报的发送和转发过程"></a>4.4、IP数据报的发送和转发过程</h1><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152939.png" alt="image-20201018144335297"></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152943.png" alt="image-20201018151314019"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152947.png" alt="image-20201018150151171"></p>
<p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152952.png" alt="image-20201018150223497"></p>
<blockquote>
<p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p>
<ul>
<li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li>
<li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li>
</ul>
</blockquote>
<p>主机C如何知道路由器R的存在？</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020152957.png" alt="image-20201018145501063"></p>
<blockquote>
<p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong></p>
<p>例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153001.png" alt="image-20201018150029179"></p>
<blockquote>
<p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p>
</blockquote>
<p>路由器收到IP数据报后如何转发？</p>
<ul>
<li>检查IP数据报首部是否出错：<ul>
<li>若出错，则直接丢弃该IP数据报并通告源主机</li>
<li>若没有出错，则进行转发</li>
</ul>
</li>
<li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul>
<li>若找到匹配的条目，则转发给条目中指示的吓一跳</li>
<li>若找不到，则丢弃该数据报并通告源主机</li>
</ul>
</li>
</ul>
<p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153006.png" alt="image-20201018151108989"></p>
<p>接下来路由器对该IP数据报进行查表转发</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153011.png" alt="image-20201018151528027"></p>
<blockquote>
<p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153016.png" alt="image-20201018151956275"></p>
<p>路由器是隔离广播域的</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153021.png" alt="image-20201018152040610"></p>
<h1 id="4-5、静态路由配置及其可能产生的路由环路问题"><a href="#4-5、静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5、静态路由配置及其可能产生的路由环路问题"></a>4.5、静态路由配置及其可能产生的路由环路问题</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153027.png" alt="image-20201018155702081"></p>
<h2 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h2><p><strong>静态路由配置</strong></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153032.png" alt="image-20201018160349375"></p>
<p><strong>默认路由</strong></p>
<p>举例</p>
<p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153037.png" alt="image-20201018160906284"></p>
<p><strong>特定主机路由</strong></p>
<p>举例</p>
<p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p>
<p>一般用于网络管理人员对网络的管理和测试</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153043.png" alt="image-20201018161440257"></p>
<blockquote>
<p>多条路由可选，匹配路由最具体的</p>
</blockquote>
<p><strong>静态路由配置错误导致路由环路</strong></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153049.png" alt="image-20201018161542579"></p>
<p>假设将R2的路由表中第三条目录配置错了下一跳</p>
<p>这导致R2和R3之间产生了路由环路</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153158.png" alt="image-20201020153154773"></p>
<p><strong>聚合了不存在的网络而导致路由环路</strong></p>
<p>举例</p>
<p>正常情况</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153203.png" alt="image-20201018162333671"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153208.png" alt="image-20201018162759562"></p>
<p>错误情况</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153213.png" alt="image-20201018163323343"></p>
<p>解决方法</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153218.png" alt="image-20201018163933715"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153222.png" alt="image-20201018164453398"></p>
<blockquote>
<p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p>
</blockquote>
<p><strong>网络故障而导致路由环路</strong></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153228.png" alt="image-20201018164811811"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153232.png" alt="image-20201018164913684"></p>
<p>解决方法</p>
<p>添加故障的网络为黑洞路由</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153237.png" alt="image-20201018165122023"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153241.png" alt="image-20201018165153517"></p>
<p>假设。一段时间后故障网络恢复了</p>
<p>R1又自动地得出了其接口0的直连网络的路由条目</p>
<p>针对该网络的黑洞网络会自动失效</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153246.png" alt="image-20201018165328319"></p>
<p>如果又故障</p>
<p>则生效该网络的黑洞网络</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153251.png" alt="image-20201018165521938"></p>
<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153255.png" alt="image-20201018165709294"></p>
<h1 id="4-6、路由选择协议"><a href="#4-6、路由选择协议" class="headerlink" title="4.6、路由选择协议"></a>4.6、路由选择协议</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153301.png" alt="image-20201019134827343"></p>
<p><strong>因特网所采用的路由选择协议的主要特点</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153308.png" alt="image-20201019134946971"></p>
<p><strong>因特网采用分层次的路由选择协议</strong></p>
<ul>
<li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153312.png" alt="image-20201019135122326"></p>
<blockquote>
<p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153317.png" alt="image-20201019135328925"></p>
<blockquote>
<p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p>
<p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p>
<p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p>
</blockquote>
<p><strong>常见的路由选择协议</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153324.png" alt="image-20201019140009740"></p>
<p><strong>路由器的基本结构</strong></p>
<p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153328.png" alt="image-20201019140234652"></p>
<p>路由器结构可划分为两大部分：</p>
<p>1、<strong>分组转发部分</strong></p>
<p>由三部分构成</p>
<ul>
<li><p>交换结构</p>
</li>
<li><p>一组输入端口：</p>
<p>信号从某个输入端口进入路由器</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153334.png" alt="image-20201019141149194"></p>
<p>物理层将信号转换成比特流，送交数据链路层处理</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153338.png" alt="image-20201019141210774"></p>
<p>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153342.png" alt="image-20201019141242246"></p>
<p>如果送交网络层的分组是普通待转发的数据分组</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153346.png" alt="image-20201019141305650"></p>
<p>则根据分组首部中的目的地址进行查表转发</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153351.png" alt="image-20201019141327380"></p>
<p>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p>
</li>
<li><p>一组输出端口</p>
<p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153357.png" alt="image-20201019141745375"></p>
<p>数据链路层将数据分组封装成帧，交给物理层处理</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153401.png" alt="image-20201019141838032"></p>
<p>物理层将帧看成比特流将其变换成相应的电信号进行发送</p>
</li>
</ul>
<blockquote>
<p>路由器的各端口还会有输入缓冲区和输出缓冲区</p>
<ul>
<li>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</li>
<li>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153407.png" alt="image-20201019143040253"></p>
<p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p>
</blockquote>
<p>2、<strong>路由选择部分</strong></p>
<ul>
<li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p>
<p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153414.png" alt="image-20201019142228360"></p>
<p>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153427.png" alt="image-20201019142415055"></p>
<p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153432.png" alt="image-20201019142924889"></p>
</li>
</ul>
<h2 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153437.png" alt="image-20201019144915687"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153442.png" alt="image-20201019145247606"></p>
<p><strong>RIP的基本工作过程</strong></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153453.png" alt="image-20201019145510947"></p>
<p><strong>RIP的路由条目的更新规则</strong></p>
<p>举例1</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153457.png" alt="image-20201019145627339"></p>
<blockquote>
<p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p>
<p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153501.png" alt="image-20201019150120900"></p>
<blockquote>
<p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153505.png" alt="image-20201019150412666"></p>
<p>举例2</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153510.png" alt="image-20201019150525711"></p>
<p><strong>RIP存在“坏消息传播得慢”的问题</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153514.png" alt="image-20201019151041492"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153518.png" alt="image-20201019151135255"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153522.png" alt="image-20201019151332767"></p>
<p>解决方法</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153526.png" alt="image-20201019151639181"></p>
<blockquote>
<p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p>
</blockquote>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153531.png" alt="image-20201019152526098"></p>
<blockquote>
<p>RIP 协议的优缺点</p>
<p>优点：</p>
<ol>
<li>实现简单，开销较小。</li>
</ol>
<p>缺点：</p>
<ol>
<li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li>
<li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li>
<li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li>
</ol>
</blockquote>
<h2 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h2><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p>
<p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p>
<p><strong>概念</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153537.png" alt="image-20201019161841695"></p>
<p><strong>问候（Hello）分组</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153542.png" alt="image-20201019161653875"></p>
<blockquote>
<p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p>
</blockquote>
<p><strong>发送链路状态通告LSA</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153547.png" alt="image-20201019162341151"></p>
<blockquote>
<p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p>
</blockquote>
<p><strong>链路状态数据库同步</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153552.png" alt="image-20201019162933483"></p>
<p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153556.png" alt="image-20201019163148068"></p>
<p><strong>OSPF五种分组类型</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153602.png" alt="image-20201019163250129"></p>
<p><strong>OSPF的基本工作过程</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153606.png" alt="image-20201019163746254"></p>
<p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p>
<p>如果不采用其他机制，将会产生大量的多播分组</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153611.png" alt="image-20201019164657606"></p>
<blockquote>
<p>若DR出现问题，则由BDR顶替DR</p>
</blockquote>
<p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p>
<ul>
<li>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</li>
<li>每个区域都有一个32比特的区域标识符</li>
<li>主干区域的区域标识符必须为0，主干区域用于连通其他区域</li>
<li>其他区域的区域标识符不能为0且不相同</li>
<li>每个区域一般不应包含路由器超过200个</li>
<li>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153618.png" alt="image-20201019170100568"></p>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153623.png" alt="image-20201019170217622"></p>
<h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153629.png" alt="image-20201019191438399"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153637.png" alt="image-20201019191718506"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153642.png" alt="image-20201019191836397"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153647.png" alt="image-20201019192031087"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153651.png" alt="image-20201019192059962"></p>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153834.png" alt="image-20201020153832824"></p>
<h2 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153841.png" alt="image-20201019192800829"></p>
<h1 id="4-7、IPv4数据报的首部格式"><a href="#4-7、IPv4数据报的首部格式" class="headerlink" title="4.7、IPv4数据报的首部格式"></a>4.7、IPv4数据报的首部格式</h1><h2 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><ul>
<li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li>
<li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li>
<li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153846.png" alt="image-20201019205931748"></p>
<p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153851.png" alt="image-20201019211719880"></p>
<blockquote>
<p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p>
<p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153855.png" alt="image-20201019212617006"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153903.png" alt="image-20201019220435415"></p>
<p><strong>对IPv4数据报进行分片</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153909.png" alt="image-20201019221021157"></p>
<p>现在假定分片2的IP数据报经过某个网络时还需要进行分片</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153916.png" alt="image-20201019221246870"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153923.png" alt="image-20201019222512112"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153930.png" alt="image-20201019222552444"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153936.png" alt="image-20201019222729797"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020153943.png" alt="image-20201019223101434"></p>
<h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154034.png" alt="image-20201020154031295"></p>
<h1 id="4-8、网际控制报文协议ICMP"><a href="#4-8、网际控制报文协议ICMP" class="headerlink" title="4.8、网际控制报文协议ICMP"></a>4.8、网际控制报文协议ICMP</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154040.png" alt="image-20201019232539898"></p>
<p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p>
<p>ICMP 报文的格式</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154046.png" alt="image-20201020001035813"></p>
<h2 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h2><h3 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154050.png" alt="image-20201019230838587"></p>
<h3 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154054.png" alt="image-20201019231022291"></p>
<h3 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154059.png" alt="image-20201019231230798"></p>
<h3 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154103.png" alt="image-20201019231355471"></p>
<h3 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154107.png" alt="image-20201019231553990"></p>
<h3 id="不应发送ICMP差错报告报文"><a href="#不应发送ICMP差错报告报文" class="headerlink" title="不应发送ICMP差错报告报文"></a>不应发送ICMP差错报告报文</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154113.png" alt="image-20201019231733673"></p>
<h2 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h2><h3 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154118.png" alt="image-20201019233817921"></p>
<h3 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154123.png" alt="image-20201019234123026"></p>
<p><strong>tracert命令的实现原理</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154129.png" alt="image-20201019234718107"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154135.png" alt="image-20201019234741268"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154141.png" alt="image-20201019234758693"></p>
<h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154147.png" alt="image-20201019234909146"></p>
<h1 id="4-9、虚拟专用网VPN与网络地址转换NAT"><a href="#4-9、虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="4.9、虚拟专用网VPN与网络地址转换NAT"></a>4.9、虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h2><ul>
<li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li>
<li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li>
<li>假定在一个机构内部的计算机通信也是采用 TCP&#x2F;IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154153.png" alt="image-20201019235534728"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154157.png" alt="image-20201019235631474"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154202.png" alt="image-20201019235718010"></p>
<blockquote>
<p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p>
<p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154207.png" alt="image-20201020000136443"></p>
<blockquote>
<p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p>
<p>私有地址只能用作本地地址而不能用作全球地址</p>
<p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p>
<p><strong>本地地址与全球地址</strong></p>
<ul>
<li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li>
<li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。</li>
<li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li>
</ul>
</blockquote>
<p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154212.png" alt="image-20201020000618797"></p>
<p>部门A向部门B发送数据流程</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154216.png" alt="image-20201020001107425"></p>
<blockquote>
<p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p>
<p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154220.png" alt="image-20201020001528569"></p>
<p>因此也被称为IP隧道技术</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154225.png" alt="image-20201020001935801"></p>
<h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154230.png" alt="image-20201020002020607"></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154234.png" alt="image-20201020002439942"></p>
<blockquote>
<p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p>
<p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154238.png" alt="image-20201020002734192"></p>
<blockquote>
<p>专有NAT软件的路由器叫做NAT路由器</p>
<p>它至少有一个有效的外部全球IP地址</p>
<p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p>
</blockquote>
<p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154243.png" alt="image-20201020003238729"></p>
<p>因特网上的这台主机给源主机发回数据报</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154248.png" alt="image-20201020003411024"></p>
<p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154252.png" alt="image-20201020003658349"></p>
<p>这种基本转换存在一个问题</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154257.png" alt="image-20201020003733863"></p>
<p>解决方法</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201020154302.png" alt="image-20201020003840584"></p>
<blockquote>
<p>我们现在用的很多家用路由器都是这种NART路由器</p>
</blockquote>
<p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p>
<p>否定</p>
<h1 id="5-1、运输层概述"><a href="#5-1、运输层概述" class="headerlink" title="5.1、运输层概述"></a>5.1、运输层概述</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><p><strong>进程之间的通信</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023182939.png" alt="image-20201020211725185"></p>
<ul>
<li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023182950.png" alt="image-20201020211339131"></p>
<p><strong>进程之间通信流程</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023182956.png" alt="image-20201020213721054"></p>
<p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p>
<blockquote>
<p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p>
<p>在运输层使用不同的端口，来对应不同的应用进程</p>
<p>然后通过网络层及其下层来传输应用层报文</p>
<p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p>
<p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183002.png" alt="image-20201020220439303"></p>
<h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183007.png" alt="image-20201020220545411"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183014.png" alt="image-20201020222828878"></p>
<h1 id="5-2、运输层端口号、复用与分用的概念"><a href="#5-2、运输层端口号、复用与分用的概念" class="headerlink" title="5.2、运输层端口号、复用与分用的概念"></a>5.2、运输层端口号、复用与分用的概念</h1><h2 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183023.png" alt="image-20201020223242364"></p>
<h2 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183032.png" alt="image-20201020223920225"></p>
<blockquote>
<p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p>
<p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做 <strong>分用</strong>。</p>
</blockquote>
<h2 id="TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183037.png" alt="image-20201020224521744"></p>
<h2 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h2><p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183317.png" alt="image-20201020224658524"></p>
<blockquote>
<p>在浏览器输入域名，回车浏览</p>
<p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p>
<p>DNS查询请求报文需要使用运输层的UDP协议</p>
<p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p>
<p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183325.png" alt="image-20201020225830336"></p>
<blockquote>
<p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183358.png" alt="image-20201020230059196"></p>
<blockquote>
<p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p>
<p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p>
<p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p>
<p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p>
<p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183406.png" alt="image-20201020231032812"></p>
<blockquote>
<p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183412.png" alt="image-20201020231308120"></p>
<blockquote>
<p>用户PC收到该数据报后，从中解封出UDP用户数据报</p>
<p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p>
<p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p>
</blockquote>
<p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183417.png" alt="image-20201020231935656"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183423.png" alt="image-20201020232517383"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183428.png" alt="image-20201020232132890"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183434.png" alt="image-20201020232548833"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183438.png" alt="image-20201020232337332"></p>
<h1 id="5-3、UDP和TCP的对比"><a href="#5-3、UDP和TCP的对比" class="headerlink" title="5.3、UDP和TCP的对比"></a>5.3、UDP和TCP的对比</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><ul>
<li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP&#x2F;IP体系结构<strong>运输层</strong>中的两个重要协议</li>
<li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li>
<li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li>
</ul>
<p>可靠信道与不可靠信道</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183445.png" alt="image-20201021192221061"></p>
<ul>
<li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</li>
<li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</li>
<li>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183449.png" alt="image-20201021193640130"></p>
<p>UDP的通信是无连接的，不需要套接字（Socket）</p>
<p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p>
<h2 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h2><p>可以发送广播</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183502.png" alt="image-20201021194104694"></p>
<p>可以向某个多播组发送多播</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183506.png" alt="image-20201021194225567"></p>
<p>还可以发送单播</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183511.png" alt="image-20201021194341256"></p>
<blockquote>
<p>UDP 支持单播、多播以及广播</p>
<p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p>
</blockquote>
<p>运输过程</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183519.png" alt="image-20201021195034383"></p>
<blockquote>
<p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p>
<p>换句话说，UDP是面向应用报文的</p>
</blockquote>
<p>UDP向上层提供无连接不可靠传输服务</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183525.png" alt="image-20201021204152175"></p>
<p>UDP结构</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183530.png" alt="image-20201021205214512"></p>
<h2 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h2><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183538.png" alt="image-20201021194557102"></p>
<p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183542.png" alt="image-20201021194749562"></p>
<blockquote>
<p>很显然，TCP仅支持单播，也就是一对一的通信</p>
</blockquote>
<p>运输过程</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183547.png" alt="image-20201021195435677"></p>
<blockquote>
<p>发送方</p>
<ul>
<li>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</li>
<li>并将他们编号，并存储在自己发送缓存中</li>
<li>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</li>
</ul>
<p>接收方</p>
<ul>
<li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li>
<li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li>
<li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p>
<p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p>
</blockquote>
<p>TCP向上层提供面向连接的可靠传输服务</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183552.png" alt="image-20201021204508839"></p>
<p>TCP结构</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183557.png" alt="image-20201021205307406"></p>
<h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183602.png" alt="image-20201023004653315"></p>
<h1 id="5-4、TCP的流量控制"><a href="#5-4、TCP的流量控制" class="headerlink" title="5.4、TCP的流量控制"></a>5.4、TCP的流量控制</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183607.png" alt="image-20201021223432091"></p>
<p>举例</p>
<p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183612.png" alt="image-20201021231801076"></p>
<p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183616.png" alt="image-20201021231904707"></p>
<p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183622.png" alt="image-20201021231945653"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183627.png" alt="image-20201021232027721"></p>
<p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183632.png" alt="image-20201021232600497"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183637.png" alt="image-20201021232645300"></p>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p>
<p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p>
</blockquote>
<h2 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183642.png" alt="image-20201021234004254"></p>
<h1 id="5-5、TCP的拥塞控制"><a href="#5-5、TCP的拥塞控制" class="headerlink" title="5.5、TCP的拥塞控制"></a>5.5、TCP的拥塞控制</h1><h2 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183647.png" alt="image-20201022141057083"></p>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<p><strong>拥塞控制的一般原理</strong></p>
<ul>
<li>拥塞控制的前提：网络能够承受现有的网络负荷。</li>
<li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li>
<li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li>
<li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li>
</ul>
<p><strong>开环控制和闭环控制</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183652.png" alt="image-20201022142108309"></p>
<p><strong>监测网络的拥塞</strong></p>
<p>主要指标有：</p>
<ol>
<li>由于缺少缓存空间而被丢弃的分组的百分数；</li>
<li>平均队列长度；</li>
<li>超时重传的分组数；</li>
<li>平均分组时延；</li>
<li>分组时延的标准差，等等。</li>
</ol>
<p>上述这些指标的上升都标志着拥塞的增长。</p>
<h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183657.png" alt="image-20201022141423443"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183701.png" alt="image-20201022141556134"></p>
<blockquote>
<p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<p>下图的实例横纵坐标的意思</p>
<p>传输轮次：</p>
<ul>
<li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li>
<li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li>
<li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li>
</ul>
<p>拥塞窗口：</p>
<ul>
<li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li>
</ul>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><h4 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h4><ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183708.png" alt="image-20201022145631052"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183742.png" alt="image-20201022144725100"></p>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h4 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h4><ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183748.png" alt="image-20201022150143886"></p>
<p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183759.png" alt="image-20201022145749592"></p>
<p>这个时候又回到了慢开始</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183804.png" alt="image-20201022145544163"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183809.png" alt="image-20201022145824004"></p>
<h4 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h4><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183814.png" alt="image-20201022150236926"></p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183820.png" alt="image-20201022150902709"></p>
<h4 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h4><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183827.png" alt="image-20201022151250183"></p>
<h4 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h4><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183833.png" alt="image-20201022151819265"></p>
<h4 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h4><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183839.png" alt="image-20201022152041751"></p>
<h1 id="5-6、TCP超时重传时间的选择"><a href="#5-6、TCP超时重传时间的选择" class="headerlink" title="5.6、TCP超时重传时间的选择"></a>5.6、TCP超时重传时间的选择</h1><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183844.png" alt="image-20201022152651184"></p>
<blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183849.png" alt="image-20201022152708875"></p>
<blockquote>
<p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183853.png" alt="image-20201022153244047"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183858.png" alt="image-20201022153518218"></p>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183903.png" alt="image-20201022153758413"></p>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183908.png" alt="image-20201022154045440"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183913.png" alt="image-20201022154137911"></p>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183919.png" alt="image-20201022154350745"></p>
<p><strong>总结</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183924.png" alt="image-20201022154418863"></p>
<h1 id="5-7、TCP可靠传输的实现"><a href="#5-7、TCP可靠传输的实现" class="headerlink" title="5.7、TCP可靠传输的实现"></a>5.7、TCP可靠传输的实现</h1><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183954.png" alt="image-20201022161436801"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023183959.png" alt="image-20201022161734997"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184004.png" alt="image-20201022164339902"></p>
<h1 id="5-8、TCP的运输连接管理"><a href="#5-8、TCP的运输连接管理" class="headerlink" title="5.8、TCP的运输连接管理"></a>5.8、TCP的运输连接管理</h1><h2 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184010.png" alt="image-20201022193215183"></p>
<h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><ul>
<li>TCP 建立连接的过程叫做<strong>握手</strong>。</li>
<li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li>
<li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<h3 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184652.png" alt="image-20201022193418673"></p>
<h3 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h3><ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
</ul>
<p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p>
<p>过程</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184016.png" alt="image-20201022194219693"></p>
<blockquote>
<p>最初两端的TCP进程都处于关闭状态</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184020.png" alt="image-20201022194350899"></p>
<blockquote>
<p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p>
<p>之后，就准备接受TCP客户端进程的连接请求</p>
<p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p>
</blockquote>
<p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184024.png" alt="image-20201022194926877"></p>
<blockquote>
<p>TCP客户进程也是首先创建传输控制块</p>
</blockquote>
<p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184028.png" alt="image-20201022195108616"></p>
<blockquote>
<p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p>
<p>TCP连接请求报文段首部中</p>
<ul>
<li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li>
</ul>
<p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184032.png" alt="image-20201022195847144"></p>
<blockquote>
<p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p>
<p>TCP连接请求确认报文段首部中</p>
<ul>
<li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li>
<li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li>
</ul>
<p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184037.png" alt="image-20201022202010182"></p>
<blockquote>
<p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p>
<p>普通的TCP确认报文段首部中</p>
<ul>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li>
<li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li>
</ul>
<p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184041.png" alt="image-20201022202932905"></p>
<blockquote>
<p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p>
<p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p>
</blockquote>
<p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p>
<p>下图实例是“两报文握手”</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184046.png" alt="image-20201022203744174"></p>
<blockquote>
<p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p>
</blockquote>
<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184050.png" alt="image-20201022204422775"></p>
<h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><ul>
<li>TCP 连接释放过程比较复杂。</li>
<li>数据传输结束后，通信的双方都可释放连接。</li>
<li>TCP 连接释放过程是<strong>四报文握手</strong>。</li>
</ul>
<h3 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h3><ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
<li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li>
</ul>
<p>过程</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184057.png" alt="image-20201022205124204"></p>
<blockquote>
<p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p>
<p>TCP客户进程的应用进程通知其主动关闭TCP连接</p>
<p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p>
<p>TCP连接释放报文段首部中</p>
<ul>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li>
</ul>
<p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184103.png" alt="image-20201022210030419"></p>
<blockquote>
<p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p>
<p>普通的TCP确认报文段首部中</p>
<ul>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184108.png" alt="image-20201022232158631"></p>
<blockquote>
<p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p>
<p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p>
<p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p>
<p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184112.png" alt="image-20201022233050922"></p>
<blockquote>
<p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p>
<p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p>
<p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184117.png" alt="image-20201022233941557"></p>
<blockquote>
<p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p>
<p>该报文段首部中</p>
<ul>
<li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li>
<li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li>
<li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184122.png" alt="image-20201022234741310"></p>
<blockquote>
<p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p>
<p>该报文段首部中</p>
<ul>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li>
</ul>
<p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p>
</blockquote>
<p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184129.png" alt="image-20201022234942562"></p>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p>
</blockquote>
<h3 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h3><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p>
<p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p>
<p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184135.png" alt="image-20201022235800155"></p>
<h1 id="5-9、TCP报文段的首部格式"><a href="#5-9、TCP报文段的首部格式" class="headerlink" title="5.9、TCP报文段的首部格式"></a>5.9、TCP报文段的首部格式</h1><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184141.png" alt="image-20201023000859363"></p>
<h2 id="各字段的作用-1"><a href="#各字段的作用-1" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><p>源端口和目的端口</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184145.png" alt="image-20201023005210010"></p>
<p>序号、确认号和确认标志位</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184150.png" alt="image-20201023003826059"></p>
<p>数据偏移、保留、窗口和校验和</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184155.png" alt="image-20201023004227265"></p>
<p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184200.png" alt="image-20201023005001450"></p>
<p>选项和填充</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201023184206.png" alt="image-20201023005132426"></p>
<h1 id="6-1、应用层概述"><a href="#6-1、应用层概述" class="headerlink" title="6.1、应用层概述"></a>6.1、应用层概述</h1><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112509.png" alt="image-20201023195112701"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112606.png" alt="image-20201023200511781"></p>
<p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112613.png" alt="image-20201023200819770"></p>
<p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP&#x2F;IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112620.png" alt="image-20201023201028141"></p>
<p>常见的应用</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112626.png" alt="image-20201023201101024"></p>
<p>总结</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112636.png" alt="image-20201023201137047"></p>
<h1 id="6-2、客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#6-2、客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="6.2、客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>6.2、客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h1><h2 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112644.png" alt="image-20201023201308269"></p>
<h2 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112701.png" alt="image-20201023201610088"></p>
<h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112708.png" alt="image-20201023202017683"></p>
<h2 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112857.png" alt="image-20201025112851738"></p>
<h1 id="6-3、动态主机配置协议DHCP"><a href="#6-3、动态主机配置协议DHCP" class="headerlink" title="6.3、动态主机配置协议DHCP"></a>6.3、动态主机配置协议DHCP</h1><h2 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h2><ul>
<li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li>
<li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li>
</ul>
<h2 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h2><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112918.png" alt="image-20201023205719672"></p>
<blockquote>
<p>如果主机数很多，就工作量大，容易出错</p>
</blockquote>
<p>如果我们给网络中添加一台DHCP服务器</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112924.png" alt="image-20201023210345650"></p>
<h2 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h2><p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li>
<li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li>
<li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li>
</ul>
<p><strong>DHCP 工作方式</strong></p>
<ul>
<li>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</li>
<li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li>
</ul>
<p><strong>DHCP交互过程</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112937.png" alt="image-20201023211525686"></p>
<blockquote>
<p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p>
<ul>
<li>事务ID</li>
<li>DHCP客户端的MAC地址</li>
</ul>
<p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p>
<p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p>
<p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112942.png" alt="image-20201023213058543"></p>
<blockquote>
<p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p>
<ul>
<li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li>
<li>配置信息：<ul>
<li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li>
<li>子网掩码</li>
<li>地址租期</li>
<li>默认网关</li>
<li>DNS服务器</li>
</ul>
</li>
</ul>
<p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p>
<p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p>
</blockquote>
<p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112948.png" alt="image-20201023214542329"></p>
<blockquote>
<p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p>
<ul>
<li>事务ID</li>
<li>DHCP客户端的MAC地址</li>
<li>接收的租约中的IP地址</li>
<li>提供此租约的DHCP服务器端的IP地址</li>
</ul>
<p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p>
<p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p>
</blockquote>
<p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025112954.png" alt="image-20201023215341522"></p>
<blockquote>
<p>源地址：DHCP服务器1的IP地址</p>
<p>目的地址：广播地址</p>
<p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p>
<p><strong>在使用前还会进行ARP检测</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113000.png" alt="image-20201023215652859"></p>
</blockquote>
<p>剩下流程图示</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113145.png" alt="image-20201025113140803"></p>
<h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113151.png" alt="image-20201023221111923"></p>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
<h2 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113157.png" alt="image-20201023221251022"></p>
<h1 id="6-4、域名系统DNS"><a href="#6-4、域名系统DNS" class="headerlink" title="6.4、域名系统DNS"></a>6.4、域名系统DNS</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>域名相比IP地址更容易记忆</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113249.png" alt="image-20201025113245213"></p>
<p>因特网是否可以只使用一台DNS服务器？</p>
<p>不行</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113255.png" alt="image-20201023235123151"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113303.png" alt="image-20201023235231869"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113310.png" alt="image-20201023235457857"></p>
<blockquote>
<p>名称相同的域名其等级未必相同</p>
</blockquote>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113319.png" alt="image-20201023235617575"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113439.png" alt="image-20201025113436842"></p>
<h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113446.png" alt="image-20201024000255580"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113451.png" alt="image-20201024000335147"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113457.png" alt="image-20201024000408396"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113502.png" alt="image-20201024002135210"></p>
<h2 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113508.png" alt="image-20201024002224354"></p>
<h1 id="6-5、文件传送协议FTP"><a href="#6-5、文件传送协议FTP" class="headerlink" title="6.5、文件传送协议FTP"></a>6.5、文件传送协议FTP</h1><h2 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113516.png" alt="image-20201024132745558"></p>
<h2 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h2><p>FTP采用C&#x2F;S方式（客户&#x2F;服务器方式）</p>
<p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113521.png" alt="image-20201024133155327"></p>
<p>FTP客户计算机也可以从FTP服务器计算机下载文件</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113525.png" alt="image-20201024133247537"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113530.png" alt="image-20201024133400777"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113534.png" alt="image-20201024133601943"></p>
<h2 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h2><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p>
<p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113538.png" alt="image-20201024134319922"></p>
<p>下图为建立数据通道的TCP连接</p>
<p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113543.png" alt="image-20201024134624114"></p>
<blockquote>
<p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p>
</blockquote>
<p>下图实例为被动模式</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113550.png" alt="image-20201024135018620"></p>
<p>两种模式对比</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113557.png" alt="image-20201024135050743"></p>
<blockquote>
<p>注意两种模式都是</p>
<p>控制连接在整个会话期间保持打开状态</p>
<p>数据连接传输完毕后就关闭</p>
</blockquote>
<h2 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113651.png" alt="image-20201025113647139"></p>
<h1 id="6-6、电子邮件"><a href="#6-6、电子邮件" class="headerlink" title="6.6、电子邮件"></a>6.6、电子邮件</h1><h2 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113657.png" alt="image-20201024151757221"></p>
<h2 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113706.png" alt="image-20201024152052056"></p>
<h2 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113713.png" alt="image-20201024152628966"></p>
<h2 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113721.png" alt="image-20201024153425016"></p>
<h2 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113728.png" alt="image-20201024153736033"></p>
<h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113734.png" alt="image-20201024154039565"></p>
<h2 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113823.png" alt="image-20201025113819151"></p>
<h1 id="6-7、万维网WWW"><a href="#6-7、万维网WWW" class="headerlink" title="6.7、万维网WWW"></a>6.7、万维网WWW</h1><h2 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h2><p><strong>概述</strong></p>
<ul>
<li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li>
<li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li>
<li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li>
<li>这种访问方式称为“<strong>链接</strong>”。</li>
</ul>
<p><strong>万维网的工作方式</strong></p>
<ul>
<li>万维网以<strong>客户 - 服务器</strong>方式工作。</li>
<li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li>
<li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li>
<li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113831.png" alt="image-20201024170819303"></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113839.png" alt="image-20201024171432743"></p>
<p><strong>万维网应用举例</strong></p>
<p>访问网页</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113844.png" alt="image-20201024170923530"></p>
<p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113850.png" alt="image-20201024171058583"></p>
<p><strong>万维网的文档</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113856.png" alt="image-20201024171724030"></p>
<h2 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h2><h3 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h3><ul>
<li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li>
<li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113901.png" alt="image-20201024222457800"></p>
<ul>
<li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li>
<li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li>
<li>最后，TCP 连接就被释放了。</li>
</ul>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113908.png" alt="image-20201024222825888"></p>
<h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p><strong>HTTP请求报文格式</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113917.png" alt="image-20201024224828528"></p>
<p><strong>HTTP响应报文格式</strong></p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025113924.png" alt="image-20201024224920638"></p>
<h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025114024.png" alt="image-20201024224945200"></p>
<h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025114030.png" alt="image-20201024224632514"></p>
<p>如果该请求有缓存</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025114034.png" alt="image-20201024224720124"></p>
<p>如果该请求没有缓存</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025114039.png" alt="image-20201024225013288"></p>
<blockquote>
<p>若WEb缓存的命中率比较高</p>
<p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p>
</blockquote>
<p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p>
<p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p>
<p>若未过期</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025114044.png" alt="image-20201024225504869"></p>
<p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025114049.png" alt="image-20201024225846863"></p>
<p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p>
<p><img src="https://gitee.com/BloothOfYouth/image/raw/master//20201025114054.png" alt="image-20201024230242550"></p>
]]></content>
  </entry>
</search>
